<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>《单片机原理及运用》学习笔记 | GanSer</title><meta name="keywords" content="知识,笔记"><meta name="author" content="GanSer"><meta name="copyright" content="GanSer"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="《单片机原理及运用》学习笔记"><meta name="application-name" content="《单片机原理及运用》学习笔记"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta name="description" content="📕📕《单片机原理及运用》，学习笔记(*^_^*)大家快来嘲笑我">
<meta property="og:type" content="article">
<meta property="og:title" content="《单片机原理及运用》学习笔记">
<meta property="og:url" content="https://www.gan1ser.top/post/dc68b377.html">
<meta property="og:site_name" content="GanSer">
<meta property="og:description" content="📕📕《单片机原理及运用》，学习笔记(*^_^*)大家快来嘲笑我">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.gan1ser.top/posts/1.webp/cover">
<meta property="article:published_time" content="2023-03-13T22:14:00.000Z">
<meta property="article:modified_time" content="2023-03-13T22:14:00.000Z">
<meta property="article:author" content="GanSer">
<meta property="article:tag" content="知识">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.gan1ser.top/posts/1.webp/cover"><link rel="shortcut icon" href="https://pic.imgdb.cn/item/63f16cddf144a010070697c8.jpg"><link rel="canonical" href="https://www.gan1ser.top/post/dc68b377"><link rel="preconnect" href="//npm.elemecdn.com"><meta name="google-site-verification" content="xxx"><meta name="baidu-site-verification" content="code-xxx"><meta name="msvalidate.01" content="xxx"><link rel="manifest" href="/manifest.json"><meta name="msapplication-TileColor" content="var(--anzhiyu-main)"><link rel="mask-icon" href="/img/siteicon/apple-icon-180.png" color="#5bbad5"><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/apple-icon-180.png"><link rel="apple-touch-icon-precomposed" sizes="180x180" href="/img/siteicon/apple-icon-180.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"><link rel="bookmark" href="/img/siteicon/apple-icon-180.png"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-2732.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2732-2048.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2388.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2388-1668.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1536-2048.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-1536.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2224.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2224-1668.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1620-2160.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2160-1620.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1290-2796.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2796-1290.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1179-2556.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2556-1179.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1284-2778.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2778-1284.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1170-2532.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2532-1170.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1125-2436.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2436-1125.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2688.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2688-1242.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-828-1792.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1792-828.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2208.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2208-1242.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-750-1334.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1334-750.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-640-1136.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1136-640.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><script>if ('serviceWorker' in navigator) {
  if (navigator.serviceWorker.controller) {
    navigator.serviceWorker.addEventListener('controllerchange', function() {
      location.reload()
    })
  }
  window.addEventListener('load', function() {
    navigator.serviceWorker.register('/service-worker.js')
  })
}</script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css#fontawesome_animation 如果有就会加载，示例值：https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/@fancyapps/ui@4.0.31/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  friends_vue_info: undefined,
  navMusic: true,
  changeMainColorPost: true,
  algolia: {"appId":"BUJ589YK96","apiKey":"6f398a28bd13fccc3f0ec369fe5b2c45","indexName":"GanSer","hits":{"per_page":10},"languages":{"input_placeholder":"键入后按下回车搜索！","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#465855","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://npm.elemecdn.com/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://npm.elemecdn.com/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'GanSer',
  title: '《单片机原理及运用》学习笔记',
  postAI: '',
  pageFillDescription: '一、单片机开发与仿真环境搭建, 1.1 Keil 软件, 1.1.1 Keil软件的简介, 1.1.2 Keil C51的工作界面, 1.1.3 Keil C51建立工程, 1.1.4 建立/编辑C语言源程序文件, 1.1.5 工程的设置, 1.1.6 Keil C51 的Debug, 1.1.7 存储空间资源的查看和修改, 1.2 Proteus软件, 1.2.1 Proteus软件的简介, 1.2.2 Proteus简单使用, 1.2.3 Proteus 8 与 Keil C51 的联合使用, 1.2.4 Proteus 画出单片机的最小系统, 1.2.5 实战教学：流水灯的实现, 1.3 STC-ISP软件, 1.3.1 STC-ISP软件的简介, 1.3.2 STC-ISP软件的使用, 1.3.3 实战教学： 点亮第一个LED灯, 1.4 单片机最小系统, 1.4.1 电源, 1.4.2 晶振, 1.4.3 复位电路, 1.4.4 单片机看门狗, 1.5 LED小灯原理, 1.5.1 USB接口电路, 1.5.2 LED小灯电路, 1.5.3 单片机端口, 1.5.4 实际LED硬件连接, 1.5.4.1 三极管认识, 1.5.4.2 三八译码器, 1.6 蜂鸣器原理, 1.6.1 单片机IO端口电流, 1.6.2 有源蜂鸣器, 1.6.3 无源蜂鸣器, 1.6.4 无源蜂鸣器鸣叫, 1.7 独立按键, 1.7.1 独立按键与矩阵按键, 1.7.2 按键的原理, 1.7.3 按键用法, 1.7.4 按键模式, 1.7.5 不支持连按模式, 1.7.6 回归按键, 1.7.7 支持连按（全局变量）, 1.7.8 双模式函数封装, 1.8 外部中断, 1.8.1 寄存器, 1.8.1.1 单片机的内部资源, 1.8.1.2 IE0的作用, 1.8.1.3 IT0的作用, 1.8.2 中断函数, 1.8.2.1 中断函数的书写, 1.8.2.2 EX0和EA, 1.8.3 进一步理解中断函数, 1.8.3.1 外部中断1, 1.8.3.2 按键触发中断, 1.8.3.3 按键触发中断消抖, 1.9 定时器, 1.9.1 溢出, 1.9.2 两种定时模式, 1.9.3 定时器模式的选择, 1.9.4 定时时长的做法, 1.9.5 定时器简单运用, 1.9.6 定时器工作模式2, 1.9.7 定时器中断函数的使用, 1.9.8 定时器初始化优化, 1.9.9 初始化需要注意的点, 1.9.10 代码参考, 1.9.11 微调定时精确时间, 1.9.12 封装函数, 1.9.13 呼吸灯, 1.10 舵机, 1.10.1 认识舵机, 1.10.2 舵机控制原理, 1.10.3 按键控制舵机, 1.10.4 呼吸灯与舵机, 1.11 串口通信, 1.11.1 串口通信入门, 1.11.2 软件设置, 1.11.3 串口配置函数, 1.11.4 ASCII码与通信数据, 1.11.5 printf系列的函数实现, 1.12 1602液晶屏, 二、实战教学以及作品展示, 2.1 LED, 2.1.1 点亮第一个LED灯, 2.1.1.1 源码, 2.1.1.2 仿真, 2.1.1.3 实物, 2.1.2 闪烁的LED灯, 2.1.2.1 源码, 2.1.2.2 仿真, 2.1.2.3 实物, 2.1.3 三个小灯同时闪烁, 2.1.3.1 源码, 2.1.3.2 仿真, 2.1.3.3 实物, 2.1.3.4 优化, 2.1.4 流水灯, 2.1.4.1 源码, 2.1.4.2 仿真, 2.1.4.3 实物, 2.1.4.4 优化, 2.1.4 交通灯的实现, 2.1.4.1 源码, 2.1.4.2 仿真, 2.1.5 花式流水灯, 2.1.5.1 右移流水灯源码, 2.1.5.2 循环流水灯, 2.1.5.3 奇偶流水灯, 2.1.5.4 按键控制流水灯, 2.2 蜂鸣器, 2.2.1 蜂鸣器驱动代码, 2.2.2 蜂鸣器鸣叫, 2.2.3 控制蜂鸣器, 2.2.4 蜂鸣器+LED实际案例, 2.3 数码管, 2.3.1 数码管原理, 2.3.2 静态数码管显示, 2.3.3 动态数码管显示, 2.3.4 4只数码管滚动显示0~3, 2.3.4.1 源码, 2.3.4.2 仿真, 2.3.5 8只数码管滚动显示8~F, 2.3.5.1 源码, 2.3.5.2 仿真, 2.3.6 8只数码管显示不同字符, 2.3.6.1 源码, 2.3.6.2 仿真, 2.4 独立按键, 2.4.1 按下按键LED小灯亮, 2.4.2 按键按下蜂鸣器鸣响, 2.4.3 测试按键按下时P2.7的状态持续的时间到底是多长, 2.4.4 按键控制灯亮灯灭, 2.4.5 不支持连按模式, 2.4.6 回归按键, 2.4.7 支持连按, 2.4.8 优化不支持连按的代码, 2.4.9 双模式函数封装, 2.4.10 综合案例, 2.5 多模块编程, 2.5.1 带返回值的函数（不支持连按的按键）, 2.5.2 支持连按的按键, 2.5.3 最终按键程序, 2.5.4 最终的Function文件, 2.6 外部中断, 2.6.1 IE0的作用, 2.6.2 中断函数, 2.6.3 外部中断1, 2.6.4 按键控制中断, 2.7 定时器, 2.7.1 工作模式一之流水灯, 2.7.2 定时器中断, 三、单片机C语言, 3.1 特殊功能寄存器和位定义, 3.1.1 sfr P0=0x80, 3.1.2 sbit LED = P0^0, 3.1.3 单片机的特殊功能寄存器, 3.2 Delay()函数, 3.2.1 空操作循环运行的时间, 3.2.2 存在的问题, 3.2.3 设计精确的5s, 3.3 移位, 3.4 静态变量, 3.5 多文件编程, 3.5.1 前期设置, 3.5.2 硬件的初始化, 3.5.3 小灯的初始化, 3.5.4 function.h的内容, 3.5.5 数码管显示函数, 3.5.6 带返回值的函数, 3.6 typedef关键字, 3.7 指针, 3.7.1 指针的概念与指针变量的声明, 3.7.1.1 变量的地址, 3.7.1.2 指针变量的声明, 3.7.1.3 简单示例, 3.7.2 指向数组元素的指针, 3.7.2.1 指向数组元素的指针和运算法则, 3.7.2.1 指向数组元素指针的实例单片机原理及运用开课了要好好学习搞钱啊感谢站猪知弦的教学指导文章中安装的软件和软件在我的个人网盘这里要感谢吕老师上传的教学文件以及孜孜不倦的教导文章中涉及的源码均以我自己的单片机为准例如我的灯有总开关如果你没有请自行修改代码祝你学有所成我会注明实际和理论的代码一单片机开发与仿真环境搭建简单的部分我就直接照搬吕老师的课件了部分需要注意的地方我会做演示侵删软件软件的简介大家安装完软件肯定是要学习使用的这里不建议将软件汉化软件本来原生态的样子就很看要学会适应英化的软件是德国公司现已被收购推出的系列的集成开发环境它不仅支持汇编语言开发更支持等高级语言开发单片机其可以完成从工程建立和管理编译链接目标代码生成软件仿真调试等完整的开发流程的工作界面建立工程首先你需要在电脑文件资源管理器中新建一个文件夹用来存放你的工程下面是新建工程的演示注意的是吕老师要求的如果不一样请换成你们的如果直接找是找不到的要先找对应的厂商然后点击就可以看到相对应的芯片型号了建立编辑语言源程序文件下面是演示比较简单一定要记得后缀是以上我们就完成了最基本的软件使用下面是一些进阶使用工程的设置在工程建立后还需要对工程进行设置在的上方工具栏中右击工程名框旁的魔术棒即打开工程设置对话框啊好多我也不懂看老师吧这些你说重要吧它也不是那么重要看一遍过去吧的大家都知道在调试程序中重要地位所以我将的单独拿出来学习源程序编写完毕后还需要编译和链接才能够进行软件和硬件仿真编译排错在程序的编译链接中如果用户程序出现错误还需要修正错误后重新编译链接重新烧录程序查看错误现象十分消耗时间因此需要单步调试一步一步的查看代码运行效果来加快对错误的排查速度进入模式后黄色箭头为汇编程序运行位置光标蓝黄三角形为当前语言运行位置指向当前等待运行程序行其界面如下其中单个黄色箭头为汇编程序运行位置光标汇编一生之痛在中有种运行方式单步跟踪单步运行运行到光标处全速运行下面是使用进行调试的录像测试用例如下理论存储空间资源的查看和修改这一部分对我来说还是太早了先看吧软件软件的简介是英国公司推出的用于仿真单片机及其外围设备的工具软件与配合使用可以在不需要硬件投入的情况下完成单片机语言应用系统的仿真开发具有高级原理布图混合模式仿真设计以及自动布线等功能简单使用继续看吧一定要看啊我是太懒了就不想打字与的联合使用下面进行基本演示将源程序编译链接生成文件这里需要将工程设置中的设置中的勾选上画出单片机的最小系统使用选择元器件的方法如下电气连接方法如下实战教学流水灯的实现实际搭建如图所示仿真电路这里采用共阳极二极管接法然后对源码进行编译生成文件之后导入芯片中软件软件的简介是一款又研发的单片机程序下载烧录软件是针对系列单片机而设计的可下载系列系列和等系列的单片机使用简便软件的使用安装好和驱动后当我们电脑插上板子之后打开设备管理器查看端口我这里是实战教学点亮第一个灯实际单片机最小系统单片机最小系统也叫做单片机最小应用系统是指用最少的原件组成单片机可以工作的系统单片机最小系统的三要素就是电源晶振复位电路如下图所示电源晶振复位电路复位电路是一种用来使电路恢复到起始状态的电路设备它的操作原理与计算器有着异曲同工之妙只是启动原理和手段有所不同复位电路就是利用它把电路恢复到起始状态就像计算器的清零按钮的作用一样以便回到原始状态重新进行计算和计算器清零按钮有所不同的是复位电路启动的手段有所不同一是在给电路通电时马上进行复位操作二是在必要时可以由手动操作三是根据程序或者电路运行的需要自动地进行复位电路都是比较简单的大都是只有电阻和电容组合就可以办到了再复杂点就有三极管等配合程序来进行了上电复位和手动复位和程序自动复位上电复位假如我们的单片机程序有行当某一次运行到第行的时候突然停电了这个时候单片机内部有的区域数据会丢失掉有的区域数据可能还没丢失那么下次打开设备的时候我们希望单片机能正常运行所以上电后单片机要进行一个内部的初始化过程这个过程就可以理解为上电复位上电复位保证单片机每次都从一个固定的相同的状态开始工作这个过程跟我们打开电脑电源开电脑的过程是一致的手动复位当我们的程序运行时如果遭受到意外干扰而导致程序死机或者程序跑飞的时候我们就可以按下一个复位按键让程序重新初始化重新运行这个过程就叫做手动复位最典型的就是我们电脑的重启按钮程序自动复位当程序死机或者跑飞的时候我们的单片机往往有一套自动复位机制比如看门狗具体应用以后再了解在这种情况下如果程序长时间失去响应单片机看门狗模块会自动复位重启单片机还有一些情况是我们程序故意重启复位单片机程序跑飞是指系统受到某种干扰后程序计数器的值偏离了给定的唯一变化历程导致程序运行偏离正常的运行路径程序跑飞因素及后果往往是不可预计的在很多情况下程序跑飞后系统会进入死循环而导致死机单片机看门狗看门狗是一个定时器看门狗是用来防止万一单片机程序出错造成重大损失的防错的原理很简单它在硬件上就是一个定时器当它溢出的时候就会让单片机强制复位使程序重新开始执行正常的情况下是不能让它溢出的所以在程序上每隔一段时间要给他置一次值俗称喂狗只要程序中正常给它喂他就不会溢出一旦程序跑飞了有干扰或者进入死循环之类的情况时不能正常执行程序了那么就永远执行不到喂狗的指令了但此时定时器是硬件控制的仍然会走所以溢出了单片机就复位了一般安全性要求比较高的系统跑飞了会造成重大事故的都会加一个狗保安全通常看门狗的溢出时间越短越灵敏跑飞之后复位的时间越短也就越安全但是喂狗的操作也要更频繁小灯原理即发光二极管俗称小灯它的种类很多参数也不尽相同我们板子上用的是普通的贴片发光二极管这种二极管通常的正向导通电压是到之间工作电流一般在之间其中当电流在之间变化时随着通过的电流越来越大我们的肉眼会明显感觉到这个小灯越来越亮而当电流从之间变化时我们看到的发光二极管的亮度变化就不是太明显了当电流超过时就会有烧坏的危险了电流越大烧坏的也就越快所以我们在使用过程中应该特别注意它在电流参数上的设计要求接口电路通过线电脑给我们的开发板供电和下载程序以及实现电脑和开发板之间的通信从图上可以看出座共有个接口其中脚和脚是数据通信引脚脚和脚是电源引脚脚是正电源脚是即地线脚和脚是外壳我们直接接到了上大家可以观察一下开发板上的这个座的个引脚我们现在主要来看脚和脚脚通过自恢复保险丝接到右侧在正常工作的情况下保险丝可以直接看成导线因此左右两边都是电源自恢复保险丝的作用是当你后级电路哪个地方有发生短路的时候保险丝会自动切断电路保护开发板以及电脑的口当电路正常后保险丝会恢复畅通正常工作右侧有条支路第一条是在和接了一个的电容电容是隔离直流的所以这条支路是没有电流的电容的作用我们下节课再介绍这节课我们主要看第二条支路我们把第二条支路摘取出来就是如图这个样子小灯电路发光二极管是二极管中的一种因此和普通二极管一样这个二极管也有阴极和阳极习惯上也称之为负极和正极我们接入的电压是发光二极管自身压降大概是那么在右边这个电阻上承受的电压就是现在我们要求电流范围是的话就可以根据欧姆定律把这个电阻的上限和下限值求出来当电流是的时候电阻值是当电流是的时候电阻值是欧也就是的取值范围是欧姆这个电阻值大小的变化直接可以限制整条通路的电流的大小因此这个电阻我们通常称之限流电阻同理我们在板子后级开关控制的地方又添加了一个发光二极管作用就是当我们打开开关时这个二极管才会亮起这里的开关虽然只有一个但是是路的路开关并联能更好的确保给后级提供更大的电流电容和都是隔离断开直流的把右侧的去掉改成一个单片机的口如图所示我们把右侧的原处接到单片机引脚上那么如果我们单片机输出一个低电平也就是跟一样的电压就可以让小灯发光了我们可以让这个引脚输出一个高电平就是跟一样的电压那么这个时候左侧电压和右侧的的电压是一致的那就没有电压差没有电压差就不会产生电流没有电流小灯就不会亮也就是会处于熄灭状态单片机端口芯片有个端口可以供我们用程序输出高低电平拿表示它可以一次性控制个引脚端口输出每个引脚想输出的电平状态是一个寄存器它的功能是控制所对应的个口如果我们控制单个端口输出低电平这个端口输出高电平程序中使用这条语句为什么是呢语言中的十六进制用二进制表示我们就知道了单片机的排在这八个位的最低端我们控制单个端口输出低电平其他端口输出高电平则是二进制表示显然我们使用就是强制把其他个端口都输出了固定高电平状态要想实现单独控制一个端口这时我们用这条语句来声明也就是只控制一个位此时想让单独的输出低电平只需即可不过是表示所用的名字而已你可以根据喜好改写这个名字值得注意的是程序书写中如果没有这个提前定义直接这样书写是不符合语法的必须先给端口一个命名而且这样的写法同样也不符合语法规定是还有我们也不能命名已经在头文件中已有的名字查看头文件内容可知有些名字已经被使用像这样定义会编译报错的因为命名冲突了头文件中已有的名字我们后期会使用到的实际硬件连接三极管认识先看左边的图想要点亮灯只需要和处于短接状态即可那么型三极管就是起到被单片机端口控制是否允许此处短接的作用也叫三极管是否导通如果单片机端口输出的是低电平此时我们可以直观的认为那端与单片机端口形成压差有电流通过而电流流向正如箭头所示则表明此时与是短接状态三极管导通灯就被点亮了如果单片机端口输出的是高电平时则没有形成压差也就产生不了电流那么箭头不能代表此时有电流流向这个方向所以与是断开状态灯没有被点亮箭头起到的就是辅助我们理解的优势这样我们可以根据箭头很形象的判断出单片机端口输出什么电平状态时就可以点亮电阻起到的是限流保护右图使用的是型三极管那么单片机端口输出高电平时点亮输出低电平时点不亮详细的可以看宋老师的手把说教你单片机的第节三八译码器该元器件只需要用到我们单片机三个端口就可以控制它的八个引脚其中的一个输出低电平开发板就用到这种叫三八译码器我们省略它的电源供电引脚画出需要讲解的引脚首先有三个引脚需要固定给它默认的电平它才能正常工作俗称使能器件此时个单片机端口输出不一样的电平时的其中一个引脚就会输出低电平而其他个都是输出高电平当我们的三个端口这样输出时则有以下情况三个端口输出的三个值从端口端口端口排成二进制数的得数就是哪个输出低电平比如三个端口这样输出此时二进制值为十进制的那么就输出低电平其他输出高电平蜂鸣器原理单片机端口电流不知道大家有没有发现绝大部分单片机上的小灯电路基本都是确定正压而让单片机口输出低电平使小灯发光为什么呢我们来看看宋老师的讲解吧下面是两个小灯电路左边电路即使单片机端口输出高电平灯的亮度是很低的因为单片机端口流出来的电流太小无法驱动正常发光这个是关联到单片机内部的集成电路原因的大家可以上网上查查右边电路这时单片机端口输出低电平时灯却很亮原因这是电源供给的电流比较大所以可以使发光较亮举个例子充电宝的接口输出电压但是它流出的电流大所以给手机充电就快虽然电脑口接口电压也是但充电却非常慢原因是口电流太小这款芯片的这一共个端口由于内部硬件的原因上电的时候都是输出高电平的而一开始是一种不确定的状态有时是高有时是低但我们用的开发板已经把端口接了上拉电阻所以开发板的初始时也是输出高电平的有源蜂鸣器蜂鸣器分有源蜂鸣器和无源蜂鸣器两者表面长相相同有源蜂鸣器有正负极之分正极接负极接地就可以响和小灯一样我们可以从简到繁的理解有源蜂鸣器无源蜂鸣器开发板中无源蜂鸣器硬件连接除了一个续流二极管外就如有源蜂鸣器一样了无源蜂鸣器实物可以不分正负极接但它也标有符号也许是为了在我们不知道这是有源蜂鸣器还是无源蜂鸣器的情况上统一规定接法吧要让无源蜂鸣器发声需要我们在单片机端口上输出的脉冲频率信号用时间表示就是要输出周期为范围的方波这个周期内高电平时间和低电平时间各占一半无源蜂鸣器鸣叫输出方波图解现在要给单片机端口输出的方波其方波周期为高电平时间低电平时间独立按键独立按键是单片机最常用的硬件部分独立按键与矩阵按键个独立按键已经可以满足大部分的程序测试学会了独立按键矩阵按键是十分好学的首先看一下我们按键的分布看一下是按键的电路图我们让单片机的输出低电平按键被按下则被圈出部分的电压均为因为都接地了按键的原理单片机上的按键使用的是没有自锁的按钮当我们按下按键后两个断点就被短接起来松手后按键自动弹起两个断点恢复原来的状态不再短接使用进行理解我们按下按键则断点之间导通与连接被接地此时的端口为也就是低电平俗称被拉低这时候即使是程序令输出高电平都于事无补因为这是外部电路直接导致端口就是内部硬件也能感觉到这个信号属于被强制拉低因此程序中寄存器位的值是可以受外部电路影响而改变的基于以上我们对按键的认识我们理想中的按键过程图如下按键用法联系生活按键的常用做法就像生活中的电磁炉或者门铃那样按下电磁炉上的加热功能键后马上松开发现电磁炉上的数就增加了现在我们打算用开发板像按电磁炉上的按键一样按一下灯被点亮再按一次灯被熄灭这样的来回切换灯的状态的功能我们之前所讲的按键过程解析图只是理想中的效果真正的按键过程图是这样的按键的抖动按键按下的前期端口并不是马上就接通地而处在稳定状态的按键按下时端口有短暂的时间接通地之后又松开了这么的一个来回的过程这是自弹式按键本身的结构属性此处称作按键抖动如果我们一直按着不放这时端口就会处在一种很稳定的接触状态当我们松开按键时也会产生弹起抖动这种抖动持续时间一般少于在之前的实验中按键动作常速下稳定接触状态也会持续在这个时候程序去读取稳定的状态时是这样就可以判断是否按键已经按下按下了就执行相应的程序功能那么我们如何处理这种抖动状态呢我们在软件上可以这样处理当程序检测到上图的段时满足了条件但是因为按键的抖动会在短时间里时而变为时而变为所以我们在满足第一个条件的时候马上做延时等待抖动过去然后再次判断此时的还是等于吗是的话就执行切换灯的状态程序双层嵌套使用第一个判断是否为低电平延迟后判断是否是稳定态图解如下但是在代码实现后如果我们按下按键一直不松手则灯会一直闪烁这是因为稳定接触状态一直保持着长时间的低电平所以程序的二次判断一直满足条件就会在和之间来回切换再加上延时才会保持亮一段时间灭一段时间所体现的闪烁按键模式按键模式主要分为两种支持连按和不支持连按其中支持连按即我们使用遥控器放大电视的音量时只需按住键不放屏幕上的音量值在一直累加松手后就停止累加了这种就叫做按键支持连按功能不支持连按例如我们用的电磁炉上的键按下不松手时数值只加一次就不加了只有松手后再按才会进行数值的第二次累加两种按键模式在单片机开发中都会经常使用不支持连按模式我们要实现稳定接触状态的时间再怎么长只能执行一次功能代码的目的我们可以利用端口检测到按键按下然后执行完功能程序之后下一个语句就写如果端口还是保持着低电平不松手状态那程序就不往下执行了让程序在这里停止只有端口变成高电平已松手才允许放行程序去运行我们知道按键抖动的时间少于所以在满足第一次判断的时候只做的延时左右过了这段时间就是稳定接触状态了于是再去二次判断即可以上虽然我们仅用就把按键模式给切换了不过这条语句严格来说是有缺陷的如果我们编写更加复杂的程序时就成了了如果我们对按键按下不松手那程序就一直在循环等待不遇到高电平就不往下执行代码如果这时有重要的程序要执行那岂不是因按键而耽误要执行某些功能的语句即使我们不使用只要我们按键不松手每次都要执行这样的代码称不上高效率我们只能再次完善代码了所以我们需要改善我们的程序这里为了让程序做到通用性我们定义一个为类型的变量我们新定义的变量是用来记录此时按键端口的扫描值进一步分析当按键按下不松手时此时的等于也就是当按键松手后就等于了然后想进入执行功能语句时先过了这一关因为我们一直让在死循环里存取的值所以只要没有按键动作一直等于这样连进入功能语句的第一关都没有资格当有按键按下时等于了进入了第一关然后我们再设最后一关如果通过了最后一关就可以执行功能语句了最后一关是判断也就是说如果按键没松手就无法执行功能语句了没错我们这次的不支持连按模式是只有按键松手之后才去执行的上一讲则是按下之后过了就执行代码了大家可以根据这一思路写代码了回归按键按键的执行任务也可以封装为函数需要静态变量去定义因为它需要跟着变化而不是每次都被初始化为同一个值支持连按全局变量支持连按的代码就是在不支持连按代码的思路上把改为这样的话按键不松手程序就能一直进入的大括号里面然后我们定义一个变量如果一直按着不放就一直累加累加到意味着低电平已经持续了一定的时间我们就可以执行功能代码了如图所示全局变量就是先在所有函数前定义这种变量可以在所有函数中使用例如这个变量的值发生改变成为另一个值时假设是其他函数此时运用这个变量的值就是全局变量有利有弊可以自己学习一下双模式函数封装以上我们学会了两种按键模式不能连按模式和连按模式的代码我们现在决定将这两种模式封装成一个函数然后通过参数选择是支持连按还是不支持连按考虑到两种模式的选择现在利用两个按键来实现按键模式的切换负责用来给做支持连按还是不支持连按的选择这里可不是说各自负责一个模式在我的开发板的原理图在输出低电平的情况下就可以当独立按键大家可以自己想一下如何实现这一功能写写代码然后参考第二章的按键部分外部中断寄存器单片机的内部资源我们熟知的包括上图中的以及头文件中的等等都叫做寄存器这些寄存器都可以粗浅的认为就是一个位的变量其中像这个最低位就是控制单片机的外部端口输出高低电平而像这些有什么作用呢这就涉及到单片机的内部资源了的作用我们先看一下原理图中的端口寄存器中的每一位都在头文件中声明好了我们拿来说如果这个端口被外部电路拉低那么的第一位也就是就会被置在程序中变为我们来验证一下我们用一根杜邦线的一头插入的引脚然后另一头插入拉低请提前将和相连初始化硬件模块如果不等于了要保证熄灭如果不等于了要保证熄灭总要执行或者这个延时要保证其中一盏灯灭的时间保证总有灯闪烁的现象我们看到在不停的闪烁此时拔了连接那头的杜邦线看到熄灭不停的闪烁连着插拔几次观察得到当遇到低电平的时候会一直等于只有当为高电平时才会等于的作用再看看也就是我们把上面的代码中的改为的初始值是多少经测试初始值为若是我们再主函数开头赋值给为那么只有当从高电平变成低电平俗称下降沿就会被即使后面变成高电平也不会变成一直是这时需要我们在程序里让清零俗称软件清零才行我们把下面的代码下载进去详见第六章第讲初始化硬件模块只有当从高电平变成低电平这个瞬间下降沿才会被置后面不管是一直保持高电平还是低电平被清之后都不会再次被置只有再次产生下降沿才会被置即使杜邦线一直都插着端口也就是都保持着低电平也不会闪烁只有不断拔插杜邦线才会有亮灭的跳变所以当等于时遇到下降沿就会被置我们软件把这个位清之后如果没有再次遇到下降沿都不会被置中断函数根据上述当赋值为时遇到下降沿被置要想使自动清零需要引用中断函数中断函数就是当它满足一定的条件时就会暂停主函数的执行内容转而去执行中断函数中断函数的书写中断函数与其他我们封装过的子函数的写法不同有个区分标志至于后面为什么会有个数字我们后面会了解到以上函数名是可以随意取的只要不跟以前封装定义好的函数名冲突就行这里我们取作为函数名是模仿单片机的写法和想要进入中断函数必须满足它的一些前提条件这里和要初始化赋值给才能进入中断程序取执行任务叫做中断总开关是针对的外部中断的开关也就是说想要进入中断子程序必须满足两个开关都要闭合进一步理解中断函数外部中断以上我们注意到我们使用标志这表明我们使用的是外部中断的功能还有一个外部中断的功能想要使用外部中断代码中需要把改为改为后面的要改为函数名我们改为下降沿触发模式初始化硬件电路为什么是呢按键触发中断每次要把和外部拉低或释放都需要拔插杜邦线这样太麻烦我们可以用按键来取代这些拔插动作按键按下不放就相当于一直拉低跟杜邦线一直插着一个效果松开按键就跟杜邦线没插一样把杜邦线这样接让和一起相连的按键动作可以使和同步电平详见第六章第讲下降沿触发模式初始化硬件模块初始化按键功能模块按键触发中断消抖以上按键似乎没能很灵敏的按一下松手就跳变一次亮或灭的效果那是因为我们没有延时消抖一个按键动作就存在好几个下降沿了导致中断函数被执行了几遍在中断函数中加延时就可以消除这种失灵现象了不过在以后编程里不能在中断函数里使用延时这样会使程序的执行效率大打折扣我们本次只是作为测试代码才在中断函数里用延时详见第六章第讲下降沿触发模式初始化硬件模块初始化按键功能模块请把和用杜邦线连接起来去抖动是否还处于低电平的稳定接触状态已在中定义好了定时器以上对中断知识的了解外部中断这种需要物理动作才能触发中断函数执行但很多情况下我们需要的是中断函数在适当时刻可以自动的去执行所以就需要定时器来辅助了定时器是单片机内部的一个硬件资源用生活常见现象举例定时器相当于一个闹钟我们调分钟后闹钟就响在这分钟里我们想做什么就做什么相当于我们自己是主函数里的任务想运行什么任务就运行什么也不用去理会闹钟还剩多少时间就响我们只是一直做我们想做的事就行之后闹钟响了这时我们不能再任性去做主函数的事了得赶紧把中断函数里的事办完先也就是要去执行中断函数了主函数的事要暂停不做先执行完中断函数之后继续回到主函数做我们的事可是又过了分钟闹钟又响了没办法我们又要放停自己的事去执行中断函数了当然闹钟是可以关闭的这就相当于是把中断函数的触发开关给断开了溢出我们知道秒表计时到秒的时候再过秒就变成了同理当我们的类型的变量的数值为时再加就变为了的变量如果此时的值为后面再加也同样成为这些都叫溢出再举一个例子来理解定时器溢出概念中学时我们做过一些化学实验其中有一种容器叫做试管如果试管是空的我们用一个导管往试管里加水导管的水流流速是均匀不变的试管里的水要想溢出需要的是个单位的时间如果我们想把距离溢出的时间缩短为一半那我们提前把试管里的水装满到一半这样就可以改变了溢出时间通过这个例子我们就可以明白要想确定好定时器溢出产生中断的间隔时间我们就要往这个试管提前装好合适的水量两种定时模式试管有个刻度的型号也有个刻度的型号不过我们的导管水流流速是永远不变的如果我们用的是大试管个刻度那么溢出时间我们可以控制的长一些也就是定时时间可以多一点我们要是想定时个单位刻度的时间那就先往试管装好个刻度的水量先这样等到水位到达那个刻度时再加一个刻度就溢出了这时溢出的就是个单位刻度的时间试管每次水溢出试管里的水就会消失不见归如果我们还想定时个单位刻度的时间还需要重新把个刻度的水量再次装好给试管如果我们用的是小试管个刻度虽然它的定时时间远远没有大试管的定时时间长但是只要我们第一次装好水量每次它溢出之后不会马上归而是试管里的水重新归为我们第一次那个时候装好的水量所以只要在第一次确定了水量也就确定了以后的所有定时时长这种叫做试管的东西就是我们单片机内部的另一个寄存器单片机有两个定时器分别叫做定时器和定时器跟外部中断有和的两个硬件资源一样这里我们先拿定时器来讲解定时器大体原理都一样定时器模式的选择我们想选用哪个试管作为定时时长首先需要初始化寄存器相对应的位的值先看到下面这张图可以看到圈出来的左右两个紫色框位是控制定时器的位是控制定时器的我们要确定选择的定时器模式们主要看和两个参数如果选用的是大试管定时模式如果选用的是小试管定时模式因为我们暂时没有使用到定时器所以位俗称高四位可以全置为位用不到也是置为我们先选择大使馆作为定时模式所以这个寄存器初始化为这里注意因为和在头文件中并没有的内容所以我们初始化只能是一次性操作个位而在程序里书写或是错位的之后我们把使用大试管称为定时器的工作模式使用小试管称为定时器的工作模式定时时长的做法定时器有两个寄存器分别是和大家再次粗浅的把和认为是两个位的变量吧因为我们用的是定时器的工作模式这两个位的变量相当于组合成了位的变量是高位是低位假如此时再过一个刻度的时间就溢出那么此时会有等于等于因为二进制的等于十进制的再加就溢出嘛因为我们用的是的晶振所以每增加花费的时间是秒如果我们用定时器的工作模式定时毫秒后触发中断该怎么实现呢首先我们先往这两个寄存器填充数值可以看到两个位的变量从高到低合起来成为位的变量至于定时为什么是这样填充我们先用反推法给大家演示十六进制的换算成十进制的值为于是定时的时长为个刻度的单位时间秒毫秒我们再正推要定时毫秒怎么给和赋初值设距离溢出还剩个刻度解得所以需要提前装好个刻度的水量也就是填充给和合成的位的变量的值就是换算成十六进制为所以要定时毫秒那么定时器简单运用注我们知道和合成的位的变量的初值最小要为不能是负数所以我们要满足解得秒毫秒也就是用定时器的工作模式最长的定时时间为毫秒左右而已下面我们来学习定时器的简单运用这方便我们理解相关的理论知识首先定时器也是有开关的这个相当于我们的导管是否打开让水流进试管里因为我们用的是定时器这个位就是控制定时器是否打开或关闭所以就是打开了定时器开始计时是关闭了定时器计时功能只要打开了定时器和合成的位的变量就会每过秒就自加直到定时器溢出我们的定时器一旦溢出就会被置如果我们不使用中断函数也是可以在主函数里等待判断跟外部中断的一样被置了需要软件清零用定时器来实现间隔的流水灯实验初始化硬件模块设置定时器位工作模式色湖之定时时间位启动定时器判断定时器是否溢出每隔就可以进入一次这个语句内部软件清零定时器溢出后清溢出标志重新赋值保证下次溢出时间间隔还是每盏灯的点亮时间都保持者用定时器来实现间隔的流水灯实验详见第六章第讲初始化硬件模块设置定时器为工作模式设置定时时间为启动定时器判断定时器是否溢出每隔就可以进入一次这个语句定时器溢出后清溢出标志重新赋初值保证下次溢出间隔时间还是每盏灯的点亮时间都保持着定时器工作模式这里我们讲解一下定时器的工作模式也就是使用小试管的方式的初始化就为我们知道工作模式的最长溢出时间仅为秒微秒我们想实现间隔的流水灯实验该怎么做我们需要利用循环首先我们定义一个变量用来记录每次的溢出次数然后我们的定时时间为微秒因为最大定时只有微秒记录的值等于的时候证明时间已经过去了于是再去执行流水灯的任务我们已经知道工作模式是不需要在溢出之后再填充初始值的比如我们定时的时间为微秒那么计算出距离溢出的刻度就为实际计算出的是所以定时为微秒误差就不大所以给赋初值为那么也是给初值为这是保证每次溢出之后新的初始值是等于的值的所以定时器工作模式又叫做位自动重装载模式初始化硬件模块设置定时器为工作模式定时启动定时器每隔加定时器溢出软件清零记录溢出次数溢出次数为时表明过去了执行流水灯保证每个流水灯亮定时器中断函数的使用定时器和掩饰其的概念不同延时函数需要占用的使用权正在延时的时候其他任务没有使用权就会拖慢执行效率而定时器是不需要占用的使用权它是独立运行的所以上面的代码的实现原理就是每隔微妙有个变量会自动加过了个微妙的时候的状态才会发生改变可以说在的时间里基本什么都没有做只是在微妙到了的时候做了的工作与外部中断一样定时器中断也有中断函数同理程序去执行中断函数就会把的中断标志位自动清所以只要我们用了定时器中断函数那么就可以不用再出现在程序书写中了外部中断定时器的中断函数后面的数字为什么是这些编号是为了区分哪些硬件资源的相关中断函数如果我们同时使用两个定时器那么只能用和来区分谁是谁的中断函数了使用作为函数名也是模仿定时器中断函数名的写法如果我们使用的是工作模式每次触发中断函数的执行内容首先就是再次给和赋初值保证下次的定时时间还是一样这里我们使用中断函数的执行方式来实现的间隔流水灯算出和合成的位的变量要填充的值为在中断函数里也是可以定义局部变量的当然如果这个变量是用来辅助流水灯的那么肯定是要定义成静态变量的初始化硬件模块打开总中断开关设置定时器为工作模式设置定时时间为打开定时器中断的开关启动定时器重新设定时间为流水灯向左移动觉得的流速太快想改为的话修改一下中断函数即可通过重复次实现定时定时器初始化优化之前我们对定时器进行初始化即填充初始值我们写我们这样写是因为我们提前计算了需要装填的数字显然如果没有注释我们很难指导这是要定时多长时间所以为了增强程序的可读性我们需要优化定时器初始化的写法要优化初始化的写法首先要明白在程序书写过程中赋值给寄存器的值可以书写成进制的数也可以是十进制的数填充的是高八位填充的是低位那么如果这个位的变量的十进制值是二进制的值就是所以高八位的值位低八位的值是我们也可以认为是右移了位等于简化书写就是而是舍去了高位等于简化书写就是下面是图解以一个位的变量的十进制值是二进制的值是所以高八位的值是第八位的值是综上所述我们要定时的话给和赋值方式可以为我们通过对和传递十进制数字对初始化过程进行了优化但这仍需要我们自己进行计算假定定时的时间为算出要填的位的变量为按照之前的写法就是而我们也可以像下面这样写以打掉相同的效果因为有了这个思路我们就可以将初始化赋值过程的写法改写为一串数字公式即可比如我们定时的最小单位时间为微秒那么定时微秒毫秒就可以这样写来给和赋初值这里的代表定时的是秒也就是毫秒如果要定时其他毫秒数数字公式中的其他数字我们不需要修改只需要把改为想定时的时间就可以了计算过程交给单片机算出来我们也就不需要自己用计算器把最终值算出来再赋给和这么麻烦了我们再化简上式就是初始化需要注意的点按上一讲说的书写方式实现定时间隔的流水灯初始化硬件电路打开中断总开关设置定时器为工作模式设置定时时间为启动定时器中断的开关启动定时器重新初始化填充下载进开发板发现根本不是间隔靠这是为什么呢首先我们要知道单片机能存储最大的一个整型数的大小只有个字节也就是最多能记忆这个数到的次方而在中明显不能把给临时存储因为这个等式的得数已经大过的次方所以我们的定时器才会无法实现准确的定时如果我们对编程没有一定的积累是很难察觉出这个隐形漏洞的解决办法就是我们的定时最小单位只能是微秒也就是定时的时间必须是微秒的整数倍书写如下把之前的和都去掉一个零这样就可以准确的定时了因为没有超过的次方读者自行修改本讲提供的代码中的处之后下载进开发板观察现象是不是又实现的间隔流水了但是这样好像不是很通用我们需要在此优化初始化的写法上述程序中的意为定时的是也就是微秒但我们希望潜意识里假如要定时微秒如果写成我们的思维还要绕个弯再把默默乘以才领悟出这是定时微秒倒不如这样我们看到关键的数字是多少那就是要定时多少微秒比如看到关键数字为时就知道定时的是微秒所以我们这样改写这样既保证了没有超过的次方也使更直观的让我们知道要定时的是微秒但是大家要记住关键数字必须是的整数倍如果想定时个微秒还是等于所以定时时间还是微秒代码参考我们分析如下的代码临时变量定时器计数频率计算所需的计数值计算定时器重载值补偿中断响应延时造成的误差定时器重载值拆分为高低字节清零的控制位配置为模式加载重载值使能中断启动第一句定时器的寄存器计数每加计数就是经过秒那么计数了次就是经过秒了经过秒计数就是这样我们就明白了第一条语句的意思第二句我们想定时需要的计数就是需要定时就是需要计数例如如果我们想定时那么需要的计数值就是定时器初始化当然也可以这样表达两种书写方式的功能作用都一样这里先不考虑中断响应延时造成的误差是两个全局变量为的是在中断函数中可以重新赋初值给寄存器和解释由于中断函数的执行有时需要消耗不同的时间所以定时时间会有误差导致进入中断函数时会产生与设想时的时间不同所以需要调整计数值也就是上面代码中的需要微调节成一个合适的数上面是固定加了这个数但是有时需要灵活改变这个微调值所以我们改为传入不同的参数来改变这个微调值基于微调我们改进以上代码上述代码定时的最小单位为下一章由于我们要学舵机需要定时的最小单位是所以我们的代码定时的最小单位必须是也就是看到我们的代码微调临时变量定时器计数频率计算所需的计数值计算定时器重载值微调计数值使其定时更精确到我们想要的定时时间定时器重载值拆分为高低字节清低四位设置定时器为工作模式加载重载值闭合定时器中断的开关启动定时器要想定时传入的参数就是我们的参数是数如果传入的是第二条语句就是与宋老师的代码原理一样不过需要记住的是改代码不能定时小于的时间最低单位只能是微调定时精确时间一般定时器中断函数里的内容最好是能够快速地去执行完比如只执行几条简单的语句这样与主函数配合才会使程序更加高效前面只使用定时器中断负责某个引脚间隔跳变或者使一个变量间隔自加的简单语句现在要实现间隔左右的时间让流水灯左右循环移动的同时还需要无源蜂鸣器一直响这样的功能思路该怎么去实现首先我们知道无源蜂鸣器要想鸣叫的比较尖锐那需要一个合适的脉冲信号这个信号打算使高低电平保持的时间为微秒不断循环所以我们用定时器中断实现的电平间隔跳变主函数里负责完成流水灯的任务即可微调临时变量定时器计数频率计算所需的计数值计算定时器重载值补偿中断响应延时造成的误差定时器重载值拆分为高低字节清低四位设置定时器为工作模式加载重载值闭合定时器中断的开关启动定时器初始化硬件模块闭合总中断开关用定时器定时不微调向左移向右移当大于等于之后其实也还是在之间变化让一直在之间变化重新加载重载值封装函数封装和详见第六章第讲微调临时变量定时器计数频率计算所需的计数值计算定时器重载值微调计数值使其定时更精确到我们想要的定时时间定时器重载值拆分为高低字节清低四位设置定时器为工作模式加载重载值闭合定时器中断的开关启动定时器微调临时变量定时器计数频率计算所需的计数值计算定时器重载值微调计数值使其定时更精确到我们想要的定时时间定时器重载值拆分为高低字节清高四位设置定时器为工作模式加载重载值闭合定时器中断的开关启动定时器微调微调呼吸灯呼吸灯的实现原理就是让小灯的端口在一段时间里由大到小变化的占空比输出接着又由小到大的占空比输出小灯显示效果就是时亮时暗地交替闪烁首先我们用定时器定时全局变量在其中断函数里执行简单的从到的循环自加这样周期就是假如主函数里我们这样执行那么端口输出的一直是周期为占空比为的波形这样盏小灯一直是处于较暗的显示状态不变要想实现呼吸灯就要不停改变波形的占空比所以我们使用定时器来做间隔地改变占空比我们再定义一个全局变量这个变量每隔就会在定时器中断函数中实现加或者减加到时又从减回到减回到又从开始加到的这样循环过程大家回去研究左右往复循环流水灯的代码就会明白都是一样的思路然后主函数这样执行每隔就会变化加或者减效果图如下初始化硬件模块闭合中断总开关定时是微调是定时时间更精确定时是微调使定时时间更精确每隔就会变化加一或者减一重新初始化在之间间隔每隔变化周期就为重新初始化占空比逐渐减小小灯逐渐变亮占空比逐渐增大小灯逐渐变暗舵机认识舵机舵机是单片机机械控制入门必学的模块在一些机器人关节中也是采用舵机作为控制学习并熟练掌握使用舵机是我们对单片机的进一步认识所以我们不能一直局限地使用开发板进行学习而是扩展一些电子模块来辅助我们更加深入了解单片机请自信购买舵机小型的舵机与大型的舵机控制原理几乎大同小异考虑到我没钱我肯定选择小型舵机作为入门学习和简单实用常见的小型舵机型号为舵机外观如下舵机控制原理我们使用的舵机为尺寸信号为这种舵机的作用角度为也就是舵机桨可以任意在某个角度卡死不动由于供电原因我们使用蛮力是很难掰动舵机桨的只有舵机掉电之后舵机桨才会任意地为我们所扭动舵机有三根线除了供电的两根电源线还有一根信号线我们使用的是电压功率的舵机所以其他电源线可以直接接到单片机的和上信号线的话就接到单片机的一个端口上这个端口通过输出控制舵机桨的角度在任意位置上固定停留这个的周期为高电平的时间在之间可以控制舵机桨角度的停留位置度度度度度我们把舵机的电源线接好然后信号线连接把代码下载进去舵机桨在上电后就会旋转到一个固定角度的位置上停留在那不动详见第六章第讲详见第八章第讲舵机信号线引脚初始化硬件模块闭合总中断开关定时是微调使定时精度更高重新加载重载值在之间间隔变化周期为高电平在周期为的中持续的时间为低电平持续的时间就是舵机桨在度处的位置停留不动按键控制舵机使用按键控制舵机桨在我们想要的位置上停留负责控制舵机桨往一个方向不停旋转则控制相反方向旋转按键模式为支持连按然后数码管显示高电平持续的时间如果数码管显示则高电平在周期里持续的时间为如果显示的是那就是持续的高电平时间舵机信号线引脚初始化硬件模块初始化按键模块闭合总中断开关定时是微调使定时精度更高定时用来刷新数码管显示定时精度要求不高可不微调支持连按高电平持续时间不能超过高电平持续时间不能低于重新加载重载值在之间间隔变化周期为的值决定舵机桨的停留位置重新加载重载值呼吸灯与舵机呼吸灯的程序思想如果用在舵机控制上那么舵机桨就是从度的位置转到度的位置又从度处转回度处如此循环往复现在我们动手改写一下呼吸灯的程序使其能融入舵机的控制中舵机信号线引脚初始化硬件模块初始化按键模块闭合总中断开关定时是微调使定时精度更高定时定时精度要求不高可以不微调重装初始值在之间间隔变化周期为的值决定舵机桨的停留位置重装初始值控制只能在之间变化占空比逐渐减少舵机桨往度的位置走动占空比逐渐增加舵机桨往度的位置走动测试发现已经是舵机桨的尽头无需写串口通信串口通信入门对于单片机来说通信则与传感器存储芯片外围控制芯片等技术紧密结合成为整个单片机系统的神经中枢即通用异步收发器串行通信是单片机最常用的一种通信技术通常用于单片机和电脑之间以及单片机和单片机之间的通信通信按照基本类型可以分为并行通信和串行通信并行通信时数据的各个位同时传送可以实现字节为单位通信但是通信线多占用资源多成本高比如我们前边用到的一次给的个口分别赋值同时进行信号输出类似于有个车道同时可以过去辆车一样这种形式就是并行的我们习惯上还称和为单片机的组并行总线而串行通信就如同一条车道一次只能一辆车过去如果一个这样一个字节的数据要传输过去的话假如低位在前高位在后的话那发送方式就是一位一位的发送出去的要发送次才能发送完一个字节有两个引脚是专门用来做串行通信的一个是一个是它们还分别有另外的名字叫做和由它们组成的通信接口就叫做串行接口简称串口用两个单片机进行串口通信基本的演示图如图所示图中表示单片机系统电源的参考地是串行发送引脚是串行接收引脚两个单片机之间要通信首先电源基准得一样所以我们要把两个单片机的相互连接起来然后单片机的引脚接到单片机的引脚上即此路为单片机发送而单片机接收的通道单片机的引脚接到单片机的引脚上即此路为单片机发送而单片机接收的通道当单片机想给单片机发送数据时比如发送一个这个数据用二进制形式表示就是在通信过程中是低位先发高位后发的原则那么就让首先拉低电平持续一段时间发送一位然后继续拉低再持续一段时间又发送了一位然后拉高电平持续一段时间发了一位一直到把位二进制数字全部发送完毕这里我们提及持续一段时间那么要持续多久呢下面我们学相关概念波特率波特率就是发送二进制数据位的速率习惯上用表示即我们发送一位二进制数据的持续时间在通信之前单片机和单片机首先都要明确的约定好它们之间的通信波特率必须保持一致收发双方才能正常实现通信常用的波特率为所谓指的是一秒钟单片机可以发送个数据位也就是秒钟的时间里单片机可以发送字节一个字节等于八个位一字节等于八比特因此一个字节等于八个二进制位我们知道了接受发送持续的时间那么如何确定起始或停止发送的呢规定当没有通信信号发生时通信线路保持高电平当要发送数据之前先发一位表示起始位然后发送位数据位数据位是先低后高的顺序数据位发完后再发一位表示停止位这样本来要发送一个字节的位数据而实际上我们一共发送了位多出来的两位其中一位起始位一位停止位而接收方呢原本一直保持的高电平一旦检测到了一位低电平那就知道了要开始准备接收数据了接收到位数据位后然后检测到停止位再准备下一个数据的接收我们以一个具体的例子感受一下单片机的是发送引脚也就是说要发送字符这个引脚的变化如下图所示单片机要发送一个字节给电脑端首先发送引脚需要先拉高然后拉低持续秒电脑端检测到这个低电平信号就会准备接收数据字节然后我们要发送的二进制位是但是串口通信发送的字节是低位在前高位在后所以上图的发送顺序就是反过来为一个字节发送完成之后还要发送一个停止位电脑端接收到这个停止位就认为一个字节发送完成了我们用定时器来实现引脚的持续时间怎么定时秒怎么设置计算一下就可以了解得因为定时时间间隔比较短所以我们使用定时器的工作模式就可以了填充的初始值就是因为在已有定义为我们可以直接使用通过按来启动发送字节数据清零低四位设置定时器为工作模式计算出波特率闭合定时器中断的开关启动定时器初始化硬件模块初始化按键模块闭合总中断开关定时秒关闭定时器开启定时器启动一个字节传输按一次一次发送字符的值为一直在之间变化变为发送起始位这次的中断函数就执行完了持续够秒之后再次进入中断函数然后就是发送数据字节的位的任务发送位数据位从低位开始引脚的变化为要么等于要么等于这样的引脚要么保持高电平要么保持低电平发送停止位关闭定时器结束一次字节传输下次按下按键发送的是这里简单说明一下我们按下启动了定时器然后第一次进入中断函数时做的任务就是拉低然后这次的中断函数的任务就结束了等过了秒之后再次进入中断函数上一次拉低的时间已经持续够秒了这第二次的中断函数任务就是拉高因为发送字符这个字节的最低位为持续够秒进入第三次执行中断函数拉低第四第五第六第七都是拉低发送以此类推到第次中断函数执行就是拉高发送停止位关闭定时器结束一次字节的传输要想再次发送需要按启动定时器表示下次发送的是这个数据再下次就是发送以此类推软件设置下载以上代码不断按下可以看见按输出等串口配置函数这里讲解一两处配置的知识首先是让寄存器的第位和第位的置其他位置是波特率设置的计算公式由于串口的使用是要占用定时器那么定时器的定时中断将不能使用所以必须使禁止其产生定时中断也就是使用了串口那么将不能再出现在程序书写中不过串口也有相应的中断函数像一样这些都是子开关串口中断的子开关为和就开启了串口的中断函数我们串口发送数据的时候会产生中断接收到数据的时候也会产生中断这两个瞬间我们在中断函数里需要执行相关任务要知道串口有动作的时候总会有或者被置前者意为接收到完整的位的数据也就使接收到一个字节然后就被置后者意为单片机发送完一个完整的字节了就被置这些瞬间都需要我们在串口中断函数中让其清零软件清零以备下次它们能再次被置下面实现的功能是电脑端通过串口发送一个数据给单片机这个数据被单片机接收到之后让这个数据再加然后单片机再通过串口把加后的数据发送回去给电脑端让它在窗口上显示缓存接收到的数据配置串口为模式清零的控制位配置为模式计算的重载值初值为重载值禁止中断使能串口中断开启定时器初始化硬件模块闭合总中断开关串口波特率设置为等于就满足条件语句意为接收到一个字节软件清零接受中断标志位接收到的数据保存到接收缓存变量中发送回去给电脑端的数据软件清零发送中断标志位这里的串口中断函数像和这些都是在串口中断函数中必须要执行的任务当然如果在其他函数里有清零这两个位可以不用在串口中断函数中书写但是一定要保证每次都要清是名字相同但作用不同的缓冲区在等于号前面意为这个是单片机发送给电脑端数据的缓冲区一旦出现这样的语句那就是单片机开始通过串口发送数据出去上图可以看见现象码与通信数据通过实验操作来熟悉码与通信数据之间的关系现在实现这样的功能在电脑端上发送十六进制模式或字符格式模式的字节给单片机数码管则显示出这些数据的十进制值然后观察数码管上显示的数值与发送数据的关系缓存接收到的数据配置串口为模式清零的控制位配置为模式计算重载值初始值为重载值禁止中断使能串口中断启动定时器初始化硬件模块闭合中断总开关配置波特率为定时用来刷新数码管显示定时精度要求不高可以不使用微调重新加载初始值手动清零接收中断标志位接收到的数据保存到接收缓存变量中接收到的数据又直接发回叫做用以提示用户输入的信息是否以正确接收软件清零发送中断标志位在发送窗口和接收窗口都选十六进制模式电脑端发送一个的数据也就是的字节给单片机然后单片机会发送回来这个数据给电脑端显示在窗口中此时开发板上的数码管显示的是接着我们在电脑端发送的是这是不要与十进制的混淆数码管显示的是所以发送的数据用十进制显示在数码管上是正确的我们切换到字符格式模式下发送字符数码管显示的是电脑端接收到单片机发送回来的数据是也就是十进制下的找到表字符对应的数刚好是如果把电脑端接收窗口改为字符格式显示那么显示的内容就跟发送窗口的字符一样了如果我们在电脑端发送窗口输入一串字符比如点击发送给单片机如果我们看到的是下面这个现象那么结合以下的程序代码分析也就是电脑端先发送字符给单片机单片机马上发送回字符给电脑端接着电脑端又发送字符如此执行下去直到发送完最后一个字符这些发送和接收过程是非常快的因为单片机接收缓存区每次只能暂存一个字节所以前面个字节都会很快被替换导致数码管在一瞬间里只显示字符的码值系列的函数实现懂得了单片机通过串口传输数据给电脑端口窗口查看那么有时我们需要发送字符串有时需要发送一个变量的数值是多少以及还要发送回车换行这三种情况所以我们把这三个功能函数封装起来方便后续的串口使用函数就是专门用来发送字符串给电脑端的函数发送的变量数值只支持显示十进制数也就是参数类型就是发送回车换行符这里的代码我们需要慢慢弄懂现在不懂也没有关系后面慢慢消化我们希望串口这部分功能模块也能像定时器那样封装一个单独文件使用所以创建号和文件复制以下代码详见第六章第讲配置串口为模式清零的控制位配置为模式计算重载值初值等于重载值禁止中断使能串口中断启动连续发送字符串数据直到检测到结束符等待字节发送完成被置就退出这个循环清标志位取值范围为把长整型数转换为位十进制的数组舍掉个位数重新装载从最高位起遇到不理会遇到非则退出循环剩余低位都如实发送出去如果此时的的值是那么电脑端窗口在字符格式模式下要想显示字符只需因为就是码值等待字节发送完成被置就退出这个循环清标志位发送回车换行符等待字节发送完成被置就退出这个循环清标志位等待字节发送完成被置就退出这个循环清标志位发送字符串发送参数的数值发送回车换行符详见第六章第讲初始化硬件模块初始化按键模块闭合总中断开关发送字符串发送变量的数值发送回车换行符接收到字节手动清零接收中断标志位在串口中断函数中我们没有再写那是因为我们在所有的发送函数中都做了的清处理所以可以在串口中断函数中不用再书写不断按下按键可以观察到串口助手出现字符串液晶屏二实战教学以及作品展示点亮第一个灯源码理论直接使用控制一个位低电平点灯死循环仿真实物实际使能三八译码器让三八译码器的输出低电平点亮最右边的灯闪烁的灯延时是单片机入门必学的应用源码有了前面的基础点灯肯定不是问题这里实现让从点亮一段时间到熄灭一段时间再点亮一段时间如此循环下去实现闪烁的功能为了实现这个目的我们需要实现延迟函数是最简单的延时语句理论仿真实物实际定义一个位无符号整形变量三八译码器使能使三八译码器的口输出低电平点亮最右边的小灯延迟一段时间熄灭最右边的小灯延迟一段时间关于单片机设计精确的延迟可以看这篇文章的第三章的函数实际延迟一秒定义两个位的变量使能三八译码器让三八译码器的输出低电平点亮最右端的灯延时熄灭最右端的灯延时三个小灯同时闪烁源码理论原理很简单控制口的高低电平即可引入单片机头文件定义引脚为定义引脚为定义引脚为无限循环延时一段时间使保持熄灭状态可根据需要调整延时时间将引脚置为高电平熄灭将引脚置为高电平熄灭将引脚置为高电平熄灭延时一段时间使保持熄灭状态可根据需要调整延时时间仿真实物实际引入单片机头文件定义引脚为定义引脚为定义引脚为开启总开关无限循环延时一段时间使保持熄灭状态可根据需要调整延时时间将引脚置为高电平熄灭将引脚置为高电平熄灭将引脚置为高电平熄灭延时一段时间使保持熄灭状态可根据需要调整延时时间优化理论通过控制通过实际流水灯实现流水灯的代码我们在第一章的教学中就已经给出了这里给出使用口实现的方式我们知道到控制的是个端口我们使用等控制语句能实现控制八个端口输出不同的高低电平那么我们来使用来实现一下源码理论只有最右边亮延迟延迟延迟延迟低电平依次向右移动控制不同的灯亮延迟延迟延迟仿真实物实际使能三八译码器使三八译码器口输出低电平只有最右边亮延迟延迟延迟延迟低电平依次向右移动控制不同的灯亮延迟延迟延迟优化理论使用语句使程序更加公正定义新的变量用来轮流调用不同的语句小细节实际使能三八译码器使三八译码器的口输出低电平数组理论延时需归使只能使用数组中的个元素防止使用到超出数组元素以外的值其实就是让在之间变化实际延时使能三八译码器让三八译码器的输出低电平需归使只能使用数组中的个元素防止使用到超出数组元素以外的值其实就是让在之间变化移位理论延时第一次运行这条语句是等于的先算出括号中的值左移位还是算出了括号中的值再去取反就得所以第一次运行这条语句时就相当于第二次循环运行时已经等于左移位就为取反得所以第二次执行这条语句是实际延时使能三八译码器让三八译码器的输出低电平第一次运行这条语句是等于的先算出括号中的值左移位还是算出了括号中的值再去取反就得所以第一次运行这条语句时就相当于第二次循环运行时已经等于左移位就为取反得所以第二次执行这条语句是交通灯的实现源码理论第一组红灯第一组黄灯第一组绿灯第二组红灯第二组黄灯第二组绿灯简单的延时函数第一组绿灯第二组红灯绿灯持续秒钟第一组黄灯第二组红灯黄灯持续秒钟第一组红灯第二组绿灯绿灯持续秒钟第一组红灯第二组黄灯黄灯持续秒钟陈同学版本主打就是一个位移大家可以体会一下他的逻辑注意是按位取或注意是按位取或就是说有取全取仿真花式流水灯当我们想实现花式流水灯时还是需要运用到数组的毕竟数组可以修改的状态值右移流水灯源码我将各种实现方法写在了一起大家根据自己的需要选取感谢陈兴龙同学提供的代码理论口数组移位循环流水灯奇偶流水灯感谢陈兴龙同学提供的数组代码理论移位方法延时函数偶数灯逐个点亮循环控制点亮偶数灯点亮第个灯偶数延时奇数灯逐个点亮循环控制点亮奇数灯点亮第个灯奇数延时全部点亮然后熄灭延时全灭延时奇偶逐个点亮后全灭全灭延时主函数循环偶数灯逐渐点亮奇数灯逐渐点亮所有灯全亮慢慢来数组奇数灯偶数灯按键控制流水灯感谢李肖坤同学提供了该部分的代码这里需要注意不能直接写语句的判断实际普中开发板延时按下给松开给防抖移位实际普中开发板按键控制左右循环流水灯延时按下给松开给防抖移位蜂鸣器蜂鸣器驱动代码无源蜂鸣器的硬件连接因为不像那样都接了很多其他器件来初始化所以驱动代码比较简单实际延时接近给保持了高电平时间低电平时间保持了我们可以尝试把两个语句里的改大一点就会发现鸣叫的音调变得低沉一些了蜂鸣器鸣叫实际简化蜂鸣器鸣叫通过就要以一定的时间间隔也可叫一定频率不停的高低电平切换这里小细节取非符号只需改变一次语句中的就可以实现不同音调的鸣叫了这里启发我们使用可以实现灯闪烁控制蜂鸣器我们先演示一个错误代码借助于控制小灯亮灭的启发我们可能写出如下的主要程序控制蜂鸣器的高低电平延迟延迟我们简单分析以上代码下面的图解可以看出来以上代码和上面的驱动代码的区别很明显使用延迟函数函数延迟控制不满足蜂鸣器的驱动条件用时间表示就是要输出周期为范围的方波这个周期内高电平时间和低电平时间各占一半那么我们要控制蜂鸣器的响与不响该如何做驱动代码之所以能一直响是因为在死循环里这些方波持续的时间无限长那么我们要让它响一段时间就让这个方波持续着这段时间然后把端口电平固定住不发生改变无源蜂鸣器没有脉冲信号所以就不响了这时我们再延时秒在这一秒里无源蜂鸣器不会响过了这一秒之后再让端口持续输出一段方波时间这时就可以再次弄响无源蜂鸣器就这样死循环下去也就达到自己想的目的实际延迟延时使用循环嵌套内层循环控制蜂鸣器一直鸣叫内层循环完成后电平不在发生变换蜂鸣器不在鸣叫延迟钟后继续进入内层循环进行鸣叫决定鸣叫的时长这里改为延时长一点把鸣叫音调调低一些延时蜂鸣器实际案例机器报警时灯亮的时候蜂鸣器就响灯灭的时候就不响实际控制蜂鸣器的高低电平延迟函数延时使能三八译码器让三八译码器的输出低电平灯亮同时蜂鸣器鸣叫软件调试出此处循环用了秒固定住蜂鸣器的电平使其不响其实这条语句也可不写因为上面的语句执行完就没有方波产生了也就不响了大家可以注释掉这个语句看看现象是不是一样的蜂鸣器不响灯灭延时数码管数码管原理静态数码管显示显示单个数字理论显示零到九的循环理论实际显示的真值表使用关键字使类型放入而不放入之所以放入是因为我们不需要改变该真值表的值记录中断次数记录经过的秒数使能选择数码管为赋初值启动设置为模式判断是否溢出溢出后清零中断标志并重新赋初值计数值自加判断溢出是否达到次达到次后计数值清零当前秒数对应的真值表中的值送到口秒数记录自加当秒数超过后重新从开始动态数码管显示的段选共阴极的线选线选为调小点是为了视觉残留的效果实际数码管显示字符转换表表数码管显示缓冲区初值确保启动时都不亮动态扫描索引记录中断次数记录经过的秒数设置模式为为设置初值为定时为高低启动判断是否溢出为重新赋值计数器自加判断溢出是否达到次达到次后计数值清零秒计数加以下代码将按十进制位从低到高依次提取并转为数码管显示字符以下代码完成数码管动态扫描刷新只数码管滚动显示源码理论数码管段选信号数组显示数字数组定义计数器延时函数定义计数器循环控制变量循环控制变量定义数码管位选信号口为输出定义数码管段选信号口为输出如果等于则将赋值为继续从开始将数码管位选信号设置为第位将数码管段选信号设置为对应数字延时计数器加循环控制变量每次加仿真只数码管滚动显示源码数码管段选信号数组显示数字数组定义计数器延时函数定义计数器循环控制变量循环控制变量定义数码管位选信号口为输出定义数码管段选信号口为输出如果等于则将赋值为继续从开始也负值为将数码管位选信号设置为第位将数码管段选信号设置为对应数字延时计数器加循环控制变量每次加仿真只数码管显示不同字符源码理论数码管段选信号数组显示数字数组定义计数器延时函数定义计数器循环控制变量定义数码管位选信号口为输出定义数码管段选信号口为输出将数码管位选信号设置为第位将数码管段选信号设置为对应数字延时延时够短人眼分辨不出来就行仿真独立按键按下按键小灯亮实际使能三八译码器使三八译码器的口输出低电平使能具备被拉低的条件很有意思这里独立按键就好像输出按下按键和松开按键一样时个小灯全亮时全灭按键按下蜂鸣器鸣响使用无源蜂鸣器按键按下时蜂鸣器就响松开不按时就不响我们知道在输出低电平的情况下按下的时候程序钟等于松开不按时等于所以我们想要实现目的可以在主函数中的死循环中用来一直等待被按下于是的值等于才能进入语句钟执行程序不按下时等于就不能进入执行程序之只能执行空循环实际让具备有被拉低的条件输出低电平不同时间的延时鸣叫的音调不同测试按键按下时的状态持续的时间到底是多长按键按下时的状态持续的时间到底是多长用流水灯的方式来查看按下之后迅速松开小灯会跳到哪里显示实际延时函数使能三八译码器使三八译码器的口输出低电平使具备被拉低的条件先点亮最右端的小灯根据网站的测试得出一下结论即使手速再怎么快地按下马上松开可在这段时间里点亮的跳到了点亮也就是说按键在物理上的导通时间超过了后面绝对大于因为亮所以有推出然后再有绝对大于在按键动作中被拉低的持续时间就有按键控制灯亮灯灭实际大家会发现这种方法是存在缺陷的使能三八译码器使三八译码器输出低电平使具备被拉低的条件延迟在此判断如果仍为就说明是稳定态的按下执行代码每进入一次都将改变一次的状态而进入需要判断的状态实现按键控制可是每个人的按键手速不同我们发现如果按下的时间稍微长一点没松手那么就会闪烁也就是被多次执行要是刻意快速按下就松手没反应所以这样的代码是做不到普遍通用的还有我们用做延时太影响的运行效率了所以我们要引入支持连按和不支持连按的按键概念不支持连按模式基于节的分析我们可以使用以下代码实现不支持连按模式可以发现无论我们的按下手速有多快或多慢只能被执行一次而已这样就像按电磁炉上的按键一样一次只能切换一回灯的亮灭即使不松手也不会出现灯的闪烁这就是不支持连按的代码书写方式不过这样的代码还是存在缺陷实际延时函数延时主函数使能三八译码器使三八译码器的口输出低电平使具备能被拉低的条件等待抖动过去二次判断如果端口还是保持低电平此时也就是没有松手那括号里的条件满足程序一直在循环这条语句所以程序停止不往下执行了直到等于也就是按键松手了里面的条件不成立才退出循环放行程序改善我们的代码实际金沙滩工作室开发板按下松开后小灯左移延时函数延时定义记录按键状态值的变量初始值为是为了避免程序一开始就进入使能三八译码器使三八译码器口输出低电平使具备能被拉低的条件先点亮灯只要不松手就会等于零只要在按键抬起之后才执行功能代码如果不松手就会等于假设这部分是要执行的其他程序实际金沙滩工作室单片机按下小灯左移松开不变延时函数延时定义记录按键状态值的变量初始值为是为了避免程序一开始就进入使能三八译码器使三八译码器口输出低电平使具备能被拉低的条件先点亮灯只要不松手就会等于零只要在按键抬起之后才执行功能代码如果不松手就会等于假设这部分是要执行的其他程序实际金沙滩工作室按键控制左右移流水灯延迟函数主函数用于监控的状态初值是为了避免直接进入掩码使能三八译码器使是三八译码器口输出低电平事先点亮一个使具有能被拉低的条件左移回归按键实际回归按键使用静态变量关键字延迟函数不支持连按如果不松手就会等于使能三八译码器使三八译码器的口输出低电平使具备被拉低的条件按键功能任务这里可以放其他程序支持连按这次我们把数码管显示的内容代码封装成函数定义一个全局变量在主函数中通过按键动作来改变这个值然后数码管负责显示这个数实验现象就是按着不放数码管显示的值一直累加数码管状态值初始化数码管显示缓存区可以在和中使用的全局变量数码管显示函数没有达到之前不更新的初始值没有达到之前不更新的初始值到达之后再加就溢出变为了这时候要再次熄灭这两个数码管端口状态全部熄灭数码管里的达到刷新作用定义记录按键状态值的变量初始值为避免程序一开始就进入了用来记录进入过按键判断语句的次数使能三八译码器让三八译码器的输出低电平让能具备有被拉低的条件先数码管显示任务按键功能部分之前是不支持连按现在改为就成为支持连按了按键端口一直是低电平就一直累加累加到意味低电平持续了一段时间了该执行功能代码了修改这个数的话那么自加的速度就会改变执行功能代码如果不松手就会等于优化不支持连按的代码在按键不支持连按即节的代码中死循环都有因为大多数时候主循环都要做很多事所以我们认为这的延时是很多复杂程序要执行所消耗的时间而正是因为这个延时函数的存在把按键的物理抖动给滤掉了误导了我们以为这样的不支持连按代码是合格的如果我们还是用这种写法去实现不支持连按功能那么请把下面的代码下载进开发板通过快按和慢按观察数码管的显示数码管状态值初始化数码管缓冲可以在和中使用的全局变量数码管显示函数没到达之前不更新的初始值没到达之前不更新的初始值到达之后再加就溢出变为了这时候要再次熄灭这两个数码管定义记录按键状态值的变量初始值为避免程序一开始就进入了用来记录进入过按键判断语句的次数使能三八译码器让三八译码器的输出低电平让能具备有被拉低的条件先数码管显示任务按键功能部分按键已弹起执行功能代码如果不松手就会等于我们多按几次会发现有时抬起之后就被加了或者更多也就是在一次按键的动作里被执行了两次这是因为的执行时间太短没有滤掉按键的抖动大家再次对照下图自己分析有了支持连按的代码思路实现消抖还是很容易的我们同样用上记录按键端口进入低电平的时间只要大于证明抖动的时间已经过去此时再判断按键是否抬起就可以决定该不该执行功能代码了很有意思数码管状态值初始化数码管缓冲可以在和中使用的全局变量数码管显示函数没到达之前不更新的初始值没到达之前不更新的初始值到达之后再加就溢出变为了这时候要再次熄灭这两个数码管定义记录按键状态值的变量初始值为避免程序一开始就进入了用来记录进入过按键判断语句的次数使能三八译码器让三八译码器的输出低电平让能具备有被拉低的条件先数码管显示任务用来记录进入过按键判断语句的次数按键功能部分低电平持续够一定的时间了证明抖动时间已经过去了如果现在按键已经抬起就执行功能代码执行功能代码如果不松手就会等于双模式函数封装题目我们用最左端的数码管来提示此时的是支持连按还是不支持连按这个数码管显示的时候不支持连按显示的时候支持连按用来切换按键模式的按键模式是不支持连按的按下松开就是把切换为另一种按键模式然后我们通过按同样右边的个数码管显示的值支持连按时按下不放就一直自动累加不支持连按时按下松开才累加数码管状态值初始化数码管显示缓存区全局变量在和里用数码管显示函数调整数码管的数字个位没到达之前不更新的初始值十位没到达之前不更新的初始值百位达到之后在加就溢出变为了这时候再次熄灭这两个数码管端口状态全部熄灭数码管里的达到刷新作用线选数码管并显示数字线选数码管并显示数字线选数码管并显示数字线选数码管并显示按键模式对应的数字按键按下所需要执行的任务用来记录进入过按键判断语句的次数可以拿来防抖等于该部分代码是用来实现支持连按的是为了让连按速度没那么快如果改为那么连按速度将加快等于该部分代码是用来实现不支持连按的这里的起到消抖的作用按键已抬起如果不松手就会等于初始时是不支持连按用来记录进入过按键判断语句的次数使能三八译码器使具有能被拉低的条件填充好数码管要显示的按键模式参数数码管显示函数的执行函数计数器的加法以下是按键的功能代码非及用来显示此时的是否支持连按显示表示不支持显示表示支持综合案例综合案例结合以上所学的知识针对数码管蜂鸣器按键的知识模拟得分的过程题目假设两个人完掷硬币游戏游戏规则如下和各持一枚硬币两人都出正面时得块钱两人都出反面时得块钱两人出一正一反时得块钱思路这样做模拟程序的开始定义两个全局变量和初始化为意为每人各持块钱用来显示在左右端的两个数码管上的钱显示在左边的数码管的钱显示在右边的数码管我们用作为给加块钱的同时也给减块的功能用作为给加块钱的同时也给减块的功能用作为给减块钱的同时给加块的功能三个按键都是不支持连按你也可以自由发挥搞一个封装玩玩规定谁先赢得元时就算胜利游戏结束比如的钱到达或超过块钱时的钱就不显示了这两个数码管熄灭如果是的钱到达或超过块时的钱就不显示了游戏结束蜂鸣器鸣响蜂鸣器就间隔鸣叫鸣叫的时候所有数码管熄灭不鸣叫的时候就只有个数码管亮着数码管呈现间隔显示蜂鸣器间隔鸣叫要想重新开始游戏必须复位开发板重启开发板细节初始化数组的时候第和第号元素为让数码管和数码管显示中间那一杠死循环执行完一次循环的时间比以往的例程要多所以的判断我们只需要它超过即可因为用上了个按键每个按键功能被封装为一个函数了所以我们定义了一个宏个按键的函数判断时只需书写即可以后我们写的代码死循环里比这次的例程执行一遍循环的时间还长的话把宏改为比还小的数就可以了模拟掷骰子使用吧比较简单不要放弃实际金沙滩开发板该程序主函数循环一次所要花费的时间比以往的长所以设置为数码管状态初始化数码管缓冲区初始化和的钱更新数码管显示缓存区数码管显示函数按键作用用来记录进入过按键判断语句的次数的钱加元的钱减元更新数码管显示缓存区按键任务用来记录进入过按键判断语句的次数的钱加的钱减更新数码管缓存区按键的任务用来记录进入过按键判断的次数的钱减的钱加更新数码管缓存区游戏结束蜂鸣器鸣叫决定鸣叫的时间表明游戏结束做循环和延时用使能三八译码器使具备能被拉低的条件初始化数码管缓存区数码管显示函数按键的任务按键的任务按键的任务游戏结束要完成的任务只要其中一方的钱达到块以上就结束游戏程序进入死循环赢得比赛的钱不再显示赢得比赛的钱不再显示熄灭所有数码管蜂鸣器鸣叫一段时间让数码管显示一段时间数码管显示函数加此延时是为了让数码管显示亮亿点点不然只循环数码管显示函数显示就会暗一些模拟掷硬币测试代码模拟次硬币正反面多模块编程多模块编程非常方便博主看很多教程都写但是我这边建议我们自己写的头文件最好是用表示由下面的代码我们可以简单理解为由建立了文件与的联系针对里面一些新的定义和简洁函数详情见第第三章第节文件只需要将和加入即可实际金沙滩开发板初始化硬件模块蜂鸣器响一下更新缓存区的内容首次显示在数码管上隔一段时间更新数码管显示的内容实际金沙滩开发板数码管状态值初始化初始化数码管显示缓存区延时让强制输出让和强制输出端口状态全部熄灭数码管里的达到刷新作用等于时就是等于时就是以此类推个缓冲区的值轮流赋给让在之间循环变化取值范围把长整型数转换为位十进制的数组舍掉个位数重新装载从最高位起遇到填充不显示的代码遇到非则退出循环剩余低位都如实转换为数码管显示字符实际金沙滩开发板对数据类型进行声明定义对数码管缓存区进行外部声明对数码管真值表进行外部声明只要在文件中封装有的函数都需要在头文件中声明一下带返回值的函数不支持连按的按键之前封装的函数都是类型无返回值的函数随着学习的深入我们需要把语言的精髓学到家前面讲的中没有提及过按键的函数封装按键功能函数都需要定义全局变量这种过多的使用全局变量是编程的大忌随着我们使用按键越来越灵活就不是简单的让一两个变量加加减减而已了所以现在我们要更加的去贴合嵌入式编程的方式那么按键的使用如果用函数封装的话需要用到函数返回值的相关知识死循环里的代码量少所以把阈值调大些用来读取按键动作的返回值初始化硬件模块让具备能被拉低的条件支持连按的按键实验现象就是按着按键不放那么出现的频率就会比不支持连按代码的时候多所以就会有左右不断流水的现象让流速慢一点用来读取按键动作的返回值是作为切换流水方向初始化硬件模块让能具备有被拉低的条件先先点亮执行功能代码让一直在之间变化向左移向右移当大于等于之后其实也还是在之间变化考虑到我们最常用的按键是所以只有输出低电平之后对应的个按键的端口才有被拉低的条件让输出低电平其他端口输出高电平这样就可以使能个按键了最终按键程序按键松开标志如果等于支持连按只要在等于时其中一个按键被按下就可以进入执行代码记录进入低电平的时间抖动的时间已经过去无按键按下假设我们传入的参数为进入函数第一次初始化时为然后没有去执行此时若没有按键按下则满足所以还是等于返回值为假设有按键按下持续够一定的低电平时间了抖动时间过去了清零让等于然后判断此时是哪个按键按下就返回对应的值返回对应的值之后如果我们一直按着不放第二次执行这个函数就会因为在前一次函数执行中已经等于所以我们就算按着按键不放也进入不了那么一次按键动作只能有一次返回值为或的机会其他时候都是返回如果我们按键松手了那就满足这样恢复为了下次按键动作又能够进入从而可以返回对应的按键值不支持连按模式就讲解完了参数为时总会执行所以按键按着不放函数的执行都会进入这样返回的按键值的机会比不支持连按时候还要多这就是等于时呈现的支持连按功能我们不再使用因为有时在各种不同的循环体里扫描返回值有些循环一次执行时间很快有些却很慢我们在第五章已经分析过这些情况了所以的值需要随机应变我们决定让作为按键程序的第二个参数这样在某些循环体里如果循环一次的时间很快我们调为循环一次的时间很慢就改为原理解析就讲解完了可以看到该代码在不支持连按模式下是按下之后就执行返回值了的而不是像以前一样要抬起按键之后才会执行返回值的语句所以不管我们的按键手速是快是慢程序都会在最快时间内去执行返回值的语句实际金沙滩开发板把改为就是支持连按了按键松开标志如果等于支持连按只要在等于时其中一个按键被按下就可以进入执行代码记录进入低电平的时间抖动的时间已经过去无按键按下让输出低电平其他输出高电平这样就可以使能个按键了用来读取按键动作的返回值初始化硬件模块初始化按键模块先点亮不支持连按模式判断阈值为执行功能代码执行功能代码执行功能代码执行功能代码最终的文件实际金沙滩开发板数码管状态值初始化初始化数码管显示缓存区延时让强制输出让和强制输出让输出低电平其他输出高电平这样就可以使能个按键了按键松开标志如果等于支持连按只要在等于时其中一个按键被按下就可以进入执行代码记录进入低电平的时间抖动的时间已经过去无按键按下端口状态全部熄灭数码管里的达到刷新作用等于时就是等于时就是以此类推个缓冲区的值轮流赋给让在之间循环变化取值范围把长整型数转换为位十进制的数组舍掉个位数重新装载从最高位起遇到填充不显示的代码遇到非则退出循环剩余低位都如实转换为数码管显示字符实际金沙滩开发板对数据类型进行声明定义对数码管缓存区进行外部声明对数码管真值表进行外部声明只要在文件中封装有的函数都需要在头文件中声明一下实际金沙滩开发板用来读取按键动作的返回值定义标志蜂鸣器允许鸣叫的变量为时可以鸣叫为时不能鸣叫初始化硬件模块初始化按键模块更新数码管缓存区内容不支持连按模式判断阈值为使自加使自减开启蜂鸣器鸣叫关闭蜂鸣器鸣叫这样我们的文件就囊括了之前所学的单片机外设的代码了大家要好好消化这一文件外部中断的作用请提前将和相连初始化硬件模块如果不等于了要保证熄灭如果不等于了要保证熄灭总要执行或者这个延时要保证其中一盏灯灭的时间保证总有灯闪烁的现象中断函数下降沿触发初始化硬件模块主函数什么事都不用做空循环这条语句看起来主函数什么内容也没有但是在拔插杜邦线的过程中触发了中断函数所以被执行跳变这就是中断函数的作用即使主函数一直执行中断函数还是能执行的了的把改为或者把改为再编译下载进去拔插杜邦线发现没有反应因为这样做已经不满足触发中断函数响应了外部中断想要使用外部中断代码中需要把改为改为后面的要改为函数名我们改为下降沿触发模式初始化硬件电路按键控制中断设置下降沿触发模式初始化电路初始化按键电路我们需要对按键进行消抖这样就可以达到按下松手一次的状态只能取反一次的灵敏效果通过在中断函数中添加延时函数消抖一般不这样做但编程本就是逆天而行设置下降沿触发初始化电路初始化键盘电路消抖是否还处于低电平的稳定接触状态已在中定义好了这样就可以达到按下松手一次的状态只能取反一次的灵敏效果如果我们一直按着不放也只是跳变一次而已有点像不支持连按功能这是因为的原因要是改为这样按键就有种支持连按的感觉从而就会不停闪烁了按键按下一直不放就会不停地进入中断函数通过在中断函数中添加延时函数消抖一般不这样做但编程本就是逆天而为低电平下触发中断初始化电路初始电路定时器工作模式一之流水灯定时器初始化硬件模块设置定时器位工作模式色湖之定时时间位启动定时器判断定时器是否溢出每隔就可以进入一次这个语句内部软件清零定时器溢出后清溢出标志重新赋值保证下次溢出时间间隔还是每盏灯的点亮时间都保持者定时器详见第六章第讲初始化硬件模块设置定时器为工作模式设置定时时间为启动定时器判断定时器是否溢出每隔就可以进入一次这个语句定时器溢出后清溢出标志重新赋初值保证下次溢出间隔时间还是每盏灯的点亮时间都保持着定时器中断右移流水灯定时时长为初始化硬件模块打开总中断开关设置定时器为工作模式设置定时时间为打开定时器中断的开关启动定时器重新设定时间为流水灯向左移动三单片机语言该章只记录博主不会的单片机相关语言知识不做语言的详细解释谁叫博主是个菜鸡呢对刚入门单片机编程的初学者来说以前我们语言基础上机操作的时候都是只见过别人的去定义变量而在单片机入门编程中看到的都是这样定义原因是单片机在入门的时候用的变量的取值都是和正整数正整数不包括所以才会用去定义无符号整形变量特殊功能寄存器和位定义这个关键字是单片机特有的它的作用是定义一个单片机特殊功能寄存器单片机内部有很多个小模块每个模块居住在拥有唯一房间号的房间内同时每个模块都有个控制开关就是一个功能模块就住在了这个房间里我们就是通过设置内部这个模块的个开关来让单片机的这个口输出高电平或者低电平的而单片机内部有很多寄存器如果我们想使用的话必须提前进行声明不过软件已经把所有这些声明都预先写好并保存到一个专门的文件中去了我们要用的话只要文件开头添加一行即可这个就是对刚才所说的里边的个开关其中的一个进行定义经过上边第二条语句后以后只要在程序里写就代表了口注意这个必须大写也就是说我们给又取了一个更形象的名字叫做单片机的特殊功能寄存器请注意每个型号的单片机都会配有生产厂商所编写的数据手册所以我们来看一下的数据手册从页到页全部是对特殊功能寄存器的介绍以及地址映射列表我们来看一下这个表其中口对标准的扩展我们先忽略它只看前边的这个每个口本身又有个控制端口这样就确定了我们的单片机一共有个口其中口所在的地址是一共有从到这个口控制位后边有个复位值这个很重要是我们看寄存器必看的一个参数个控制位复位值全部都是这就是告诉我们每当单片机上电复位的时候所有的引脚的值默认是都是即高电平我们在设计电路的时候也要充分的考虑这个问题函数前期我们在设计时间间隔时经常使用函数最近几位同学一直在研究这个函数简单的两层循环真的能很准确的设置延迟吗让我们看一下这个简单的延迟的函数简单的延时函数绿灯持续秒钟现在思考为什么我们调用函数就能延迟秒钟呢这里是根据我查阅了一些资料得到的一点理解如有不对请指正根据代码其实很明显调用函数延时的时长是通过循环执行空操作来实现的也就是说函数并没有真正的即使功能而是通过程序执行的速度来控制延时的时长因此实际上是在循环执行一定次数的空操作后才返回函数达到延时的效果具体来求解这个其实是要考虑很多因素的延时时长的计算与单片机所使用的时钟频率有关以一个的晶振为例每个时钟周期的时间为函数中的循环次数是通过将所需延时时间转换为循环次数来实现的计算公式为循环次数延时时间单次循环所需时间对于来说延时为即而单次循环所需时间是根据时钟频率计算得到的对于晶振单次循环所需时间为其中是空操作的指令执行数因此延迟需要执行的循环次数为次才能实现延迟秒的效果博主的单片机是的晶振是的让我计算一下以上代码是否真的是按照中的我们计算一下需要循环多少次根据上述原理我们每个时钟周期的时间为单次循环所需时间为这里是空操作的指令执行数见代码因此我们要延迟需要执行的循环次数为次但是我们使用一共循环了次不管是次还是次我们发现这都和我们传入的参数不符合呀麻了这是怎么回事呢这是因为以上计算公式都是基于单片机汇编语言的我们使用语言绝不能这样计算很明显一条语句应该是对应很多调汇编语句的你可以试试所以该方法是计算不出来的如何设计我们的循环达到想要的延迟效果综合上述所讲我们的误区就落在语言语句的执行时间那么我们来实际调试一下看看我们的代码到底运行多久空操作循环运行的时间第一组红灯第一组黄灯第一组绿灯第二组红灯第二组黄灯第二组绿灯简单的延时函数第一组绿灯第二组红灯验证空操作循环所需时间绿灯持续秒钟第一组黄灯第二组红灯黄灯持续秒钟第一组红灯第二组绿灯绿灯持续秒钟第一组红灯第二组黄灯黄灯持续秒钟首先将我们的晶振频率设置为因为新建工程时默认是开始调试为了验证的简单我们直接在函数中添加空操作循环打断点我们将断点打到第行和第行点击按钮然后返回函数按下键通过右侧时间可以看到当前程序执行到第行所用的时间可以看到程序运行到第行时花了我们继续执行第条语句查看时间为这条语句花了也就是微秒下面我们执行空操作循环语句我们继续将断点打在行为了计算时间如果不打断点程序会将行语句后面的程序全部执行完可以看到时间变成也就是说我们的空操作语句花了也就是毫秒接近如此我们就知道为什么我们调用就能够延迟秒了视为次就得到了存在的问题如果你调试时候我们的时间是有差异的那就说明我们使用空操作循环进行延时操作是不完全的这是为什么呢我们设置的时间参数利用空循环等待一段时间而这个时间正是通过计算机晶振时钟周期数来实现的它的具体时间取决于计算机的性能和系统负载情况也就是我们在调试时这样的结果还和我们的单片机计算机硬件有关因此存在误差是很正常其实我们会发现我们调试出的并不是而是我们用此循环次这样的误差会随着循环次数的增加被不断地放大为差了这太可怕了下面是一个验证的可以看到确实我后点按的倒计时所以我们单纯的使用空操作循环语句进行延迟实际上是不准确的但是勉强能用设计精确的要设计精确的我们可以借助于看门狗定时器或者再次调试后面更新博主困了拜拜移位在我们的语言当中有一个移位操作其中代表的是左移代表的是右移比如就是的结果等于左移一位大家注意移位都是指二进制移位那么移位完了本来在第位的移动到了第一位上移动完了低位是补的所以的值最终是等于还要学习另外一个运算符这个符号是按位取反的意思同理按位取反也是针对二进制而言比如的二进制是按位取反后就是那么的值就是了这里要注意的是二进制移位静态变量一般不用在主函数中大多数在中断函数和封装好的子函数里运用它的作用是保证在子函数或中断函数中定义的变量每次调用完之后都可以保持调用完时候的值也就是保证变量在两个函数中的值使相同且通用的下面是一个举例可以下载到单片机中观察现象数码管状态值初始化延时静态变量让在之间变化使能三八译码器只让数码管显示延时多文件编程运用多文件编程是为了使我们教程无需每次都贴出相同功能的代码编程的时候已经有很多代码完全可以前往以前的例程里复制即可后期的例程里代码量越来越大显然全部给出就不合适了所以我们把经常使用的功能模块代码封装起来放在另一个文件里提供给我们调用这个文件命名为以后我们提供的代码就是的内容这样教程供给的代码数量就会精简一些前期设置新建和并添加到在中添加以下代码对数据类型进行声明定义硬件的初始化回顾一下要点亮小灯需要的条件首先然后使能三八译码器让三八译码器的输出低电平上面这些条件满足了就叫的初始化也就是说要想使用硬件上的模块我们必须配置好它的端口输出情况或者设置好函数的参数使其能工作初始化不是放在循环中反复执行而是在主函数开头把相应的端口该输出低电平的输出低电平该输出高电平的输出高电平配置好这些器件它只需在主函数开头执行一次即可后面就是进入死循环去真正的实现相应的功能了小灯的初始化小灯要能正常工作就要满足的个端口的条件可以将小灯的初始化就封装为让强制输出让和强制输出当数码管工作时小灯是暂时发挥不了作用的因为三八译码器的端口的输出已经切换了数码管显示函数端口状态全部熄灭数码管理的达到刷新作用这段代码我们可以简化为端口状态全部熄灭数码管里的达到刷新作用等于时就是等于时就是一次类推个缓冲区的值轮流赋给让在之间循环变化的内容分析一下文件里发现有的个端口的定义那我们也可以懂得把之前的等放在中以及在封装有的函数和初始化的数组都需要在中声明一下比如在中定义好了在就要声明一下数码管显示函数有时我们需要个数码管显示我们想要看到的数字比如计算结果呈现在数码管上然而当要显示的数为时又不想前面的个数码管亮也就是高位为不显示我们把这部分功能代码封装为带参数的函数传入的参数就是要显示的数值参数定义的是类型也就是支持的数值的次方等于示例一示例二每次被调用都会从开始这两段代码都能实现我们想要的功能示例可读性强让人一看就明白了代码的作用而示例书写量少比较简洁但在阅读理解上需要我们转一下弯经过测试这两段代码的执行时间发现示例比示例快左右这种情况下毫无疑问我们肯定是选择示例暂时作为实用代码可是在后期的教程中用到定时器中断来扫描数码管显示时示例的代码效果不尽人意关于漏洞在哪大家后面可以尝试自己寻找在使用示例时虽然显示效果比示例的好但是费时长所以这两段代码都不是实用型代码代码参考取值范围把长整型数转换为位十进制的数组舍掉个位数重新装载从最高位起遇到填充不显示的代码遇到非则退出循环剩余低位都如实转换为数码管显示字符这部分代码我们来举个例子理解假如传入的参数为第一个循环就是实现以下功能第二个循环等于之后就退出了循环第三个循环是等于然后填充好要显示的给数码管缓存区带返回值的函数之前封装的函数都是类型无返回值的函数随着学习的深入我们需要把语言的精髓学到家前面讲的中没有提及过按键的函数封装按键功能函数都需要定义全局变量这种过多的使用全局变量是编程的大忌随着我们使用按键越来越灵活就不是简单的让一两个变量加加减减而已了所以现在我们要更加的去贴合嵌入式编程的方式那么按键的使用如果用函数封装的话需要用到函数返回值的相关知识举例首先我们定义一个不带参数且返回值为型的函数函数名为里面的内容跟以前的不支持连按函数都差不多只是我们把执行功能代码部分改为当按键按下抬起时我们函数的返回值为其他情况返回值为这样死循环里不断更新的值而大多数时候没有按键动作所以死循环里的的值都是有按键动作了等于就执行功能代码下一个循环没有按键动作了又等于就不执行功能代码了死循环里的代码量少所以把阈值调大些用来读取按键动作的返回值初始化硬件模块让具备能被拉低的条件关键字使用我们可以对代码进行简化比如的定义我们用声明就是用一个更加简洁的名字来取代区定义位的变量用的话就是用来定义位的变量或者像之前定义的数组也可以像这样去定义有时需要定义位的变量就用即可虽然与的作用有点意思相近但是不严谨的编写习惯不建议这样使用原因大家可上网了解指针指针是语言的灵魂利用指针可以直接而快速的处理内存中的各种数据结构中的数据特别是数组字符串和内存的动态分配等它为函数之间各类数据传递提供了简洁便利的方法指针的概念与指针变量的声明变量的地址要研究指针我们得先来深入理解内存地址这个概念打个比方整个内存就相当于一个拥有很多房间的大楼每个房间都有房间号比如从一直到我们可以说这些房间号就是房间的地址相对应的内存中的每个单元也都有自己的编号比如从一直到我们同样可以说这些编号就是内存单元的地址房间里可以住人对应的内存单元里就可以住进变量了假如一位名字叫的人住在房间我们可以说的住址就是或者就是的住址对应的假如一个名为的变量住在编号为的这个内存单元中那么我们可以说变量的内存地址就是或者就是变量的地址基本的内存单元是字节英文单词为我们所使用的单片机共有字节的就是我们所谓的内存但它分为内部字节和外部字节我们仅以内部的字节为例很明显其地址的编号从开始就是我们用语言定义的各种变量就存在的地址范围内而不同类型的变量会占用不同数量的内存单元即字节可以结合前面讲过的语言变量类型深入理解假如现在定义了这样个变量我们把这个变量分别放到内存中就会是表中所列的样子我们先来大概了解一下他们的存储方式变量和和之间的变量类型不同因此在内存中所占的存储单元也不一样和都占一个字节占了个字节而占了个字节那么的地址就是的地址就是的地址就是的地址就是它们的地址的表达方式可以写成这样就代表了相应变量的地址语言中变量前加一个表示取这个变量的地址在这里就叫做取址符讲到这里有一点延伸内容大家可以了解下比如变量是类型的占了个字节存储在了和这两个内存地址上那么是它的低字节还是高字节呢这个问题由所用的编译器与单片机架构共同决定单片机类型不同就有可能不同大家知道这么回事即可比如在我们使用的单片机的环境下存的是高字节存的是低字节这是编译底层实现上的细节问题并不影响上层的应用如下这两种情况在应用上丝毫不受这个细节的影响强制类型转换那么的值一定是的低字节取地址则得到的一定是这都是语言本身所决定的规则不因单片机编译器的不同而有所改变实际生活中我们要寻找一个人有两种方式一种方式是通过它的名字来找人还有第二种方式就是通过它的住宅地址来找人我们在派出所的户籍管理系统的信息输入方框内输入小明的家庭住址系统会自动指向小明的相关信息输入小刚的家庭住址系统会自动指向小刚的相关信息这个供我们输入地址的方框在户籍管理系统叫做地址输入框那么在语言中我们要访问一个变量同样有两种方式一种是通过变量名来访问另一种自然是通过变量的地址来访问在语言中地址就等同于指针变量的地址就是变量的指针我们要把地址送到上边那个所谓的地址输入框内这个地址输入框既可以输入的指针又可以输入的指针所以相当于一个特殊的变量保存指针的变量因此称之为指针变量简称为指针而通常我们说的指针就是指指针变量地址输入框输入谁的地址指向的就是这个人的信息而给指针变量输入哪个普通变量的地址它自然就指向了这个变量的内容通常的说法就是指针指向了该变量指针变量的声明在语言中变量的地址往往都是编译系统自动分配的对我们用户来说我们是不知道某个变量的具体地址的所以我们定义一个指针变量把普通变量的地址直接送给指针变量就是这样的写法对于指针变量的定义和初始化一般有两种方式定义时直接进行初始化赋值定义后再进行赋值大家仔细看会看出来这两种写法的区别它们都是正确的我们在定义的指针变量前边加了个这个就代表了这个是个指针变量不是个普通的变量它是专门用来存放变量地址的此外我们定义的时候用了来定义这里表示的是这个指针指向的变量类型是型的指针变量似乎比较好理解大家也能很容易就听明白但是为什么很多人弄不明白指针呢因为在语言中有一些运算和定义他们是有区别的很多同学就是没弄明白它们的区别指针就始终学不好这里我要重点强调两个区别只要把这两个区别弄明白了起码指针变量这部分就不是问题了这两个重点现在大家死记硬背直接记住即可靠理解有可能混淆概念指针变量和普通变量的区别我们定义一个变量同时也可以给变量赋值也可以赋值但是我们我们定义一个指针变量另外还定义了一个普通变量普通变量那么这个指针变量可以指向的地址也可以指向的地址可以写成也可以写成但就是不能写成或者或者这三种表达方式都是错的因此这个地方不要看到定义的时候前边有个型就错误的赋值这个只是说明指向的变量是这个类型的而本身是指针变量不可以给它赋值普通的值或者变量后边我们会直接把指针变量称之为指针大家要注意一下这个小细节定义指针变量和取值运算的区别这个符号在我们的语言有三个用法第一个用法很简单乘法操作就是用这个符号第二个用法是定义指针变量的时候用的比如这个地方使用代表的意思是是一个指针变量而非普通的变量还有第三种用法就是取值运算和定义指针变量是完全两码事比如这样两步运算完了之后的值就成了了在这段代码中表示取这个变量的地址把这个地址送给之后再用运算表示的是取指针变量指向的地址的变量的值又把这个值送给了最终的结果相当于同样是放在定义的位置就是定义指针变量放在执行代码中就是取值运算简单示例使用指针实现流水灯缓冲值取反发送到口缓冲值左移一位将指针变量指向的字节左移一位利用指针变量可以向函数外输出运算结果对比之前的函数调用大家是否看明白如果是普通变量传递只能单向的也就是说主函数传递给子函数的值子函数只能使用却不能改变而现在我们传递的是指针不仅仅子函数可以使用里边的值而且还可以对里边的值进行修改只要是前边带了变量类型如就是表示定义了一个指针变量而执行代码中的是指所指向的内容指向数组元素的指针指向数组元素的指针和运算法则所谓指向数组元素的指针其本质还是变量的指针因为数组中的每个元素其实都可以直接看成是一个变量所以指向数组元素的指针也就是变量的指针指向数组元素的指针不难但很常用如果我们写那么指针就指向了的第号元素也就是把的地址赋值给了同理如果写就指向了数组的第号元素其中的取值范围是就表示指向了数组的第号元素指针本身也可以进行几种简单的运算这几种运算对于数组元素的指针来说应用最多比较运算比较的前提是两个指针指向同种类型的对象比如两个指针变量和它们指向了具有同种数据类型的数组那它们可以进行等关系运算如果为真的话表示这两个指针指向的是同一个元素指针和整数可以直接进行加减运算比如还是上边我们那个指针和数组如果那么就指向了就指向了当然了如果也就指向了两个指针变量在一定条件下可以进行减法运算如那么的结果就是但是这个地方要特别注意这个代表的是元素的个数而不是真正的地址差值如果我们的的变量类型是型占个字节的结果依然是因为它代表的是数组元素的个数在数组元素指针这里还有一种情况就是数组名字其实就代表了数组元素的首地址即这两种表达方式是等价的因此以下几种表达形式和内容需要注意根据指针的运算规则代表的是的地址那么代表的也是的地址或者说它们指向的都是数组的第号元素和都表示指向数组元素的指针也可以表示成数组的形式也就是说允许指针变量带下标即和是等价的但是为了避免混淆与规范起见这里我们建议大家不要写成前者而一律采用后者的写法但如果看到别人那么写也知道是怎么回事即可二维数组元素的指针和一维数组类似需要介绍的内容不多假如现在一个指针变量和一个二维数组它的地址的表达方式也就是有一个地方要注意既然数组名代表了数组元素的首地址那么也就是说和都是指数组的首地址对二维数组来说都可以看成是一维数组的数组名字所以等价于等价于等价于加减运算和一维数组是类似的不再详述指向数组元素指针的实例在语言里可以用来获取括号内的对象所占用的内存字节数虽然它写作函数的形式但它并不是一个函数而是语言的一个关键字整体在程序代码中就相当于一个常量也就是说这个获取操作是在程序编译的时候进行的而不是在程序运行的时候进行这是一个实际编程中很有用的关键字灵活运用它可以为程序带来更好的可读性易维护性和可移植性在后续的例程学习中将会慢慢有所体会的括号中可以是变量名也可以是变量类型名其结果是等效的而其更大的用处是与数组名搭配使用这样可以获取整个数组占用的字节数就不用自己动手计算了可以避免错误而如果日后改变了数组的维数时也不需要再到执行代码中逐个修改便于程序的维护和移植下面是一个简单的例程命令到达标志即接收到上位机下发的命令命令索引即与上位机约定好的数组编号串口发送计数器串口发送指针开总中断配置波特率为数组的首地址赋值给发送指针数组的长度赋值给发送计数器手动方式启动发送中断处理数据发送串口配置函数通信波特率配置串口为模式清零的控制位配置为模式计算重载值初值等于重载值禁止中断使能串口中断启动中断服务函数接收到字节清零接收中断标志位接收到的数据保存到命令索引中设置命令到达标志字节发送完毕清零发送中断标志位有待发送数据时继续发送后续字节发出指针指向的数据发送计数器递减发送指针递增',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-13 22:14:00',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="google-site-verification" content="Tfw3UBpa3L-1YpdcSpYfgEpo2yPLlJBOVXR_aAsqjT0"><meta name="baidu-site-verification" content="codeva-lGhY19ZM6U"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css"><link rel="stylesheet" href="/css/home.css"><link rel="stylesheet" href="/css/imgloaded.css?1"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4177998_ufp3xnlc2xn.css"><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.1/tianli_gpt.css"><link rel="stylesheet" href="/css/todolist.css"><style>#left-mid-img1 {
  z-index: 999;
  position: fixed;
  left: 0;
  top: calc(50% - 50px);
  transform: translateY(-50%);
  width: 100px;
  height: auto;
}

#left-mid-img2 {
  z-index: 999;
  position: fixed;
  left: 0;
  top: calc(50% + 50px);
  transform: translateY(-50%);
  width: 100px;
  height: auto;
}
#right-mid-img1 {
  z-index: 999;
  position: fixed;
  right: 0;
  top: calc(50% - 50px);
  transform: translateY(-50%);
  width: 110px;
  height: auto;
}
#right-mid-img2 {
  z-index: 999;
  position: fixed;
  right: 0;
  top: calc(50% + 50px);
  transform: translateY(-50%);
  width: 110px;
  height: auto;
}</style><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="GanSer" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet"></head><body data-type="anzhiyu"><img id="left-mid-img1" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://essay.gan1ser.top/post/soyo.gif" alt="Image 1 Description"><img id="left-mid-img2" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://essay.gan1ser.top/post/anno.gif" alt="Image 2 Description"><img id="right-mid-img1" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://essay.gan1ser.top/post/daxiang.gif" alt="Image 1 Description"><img id="right-mid-img2" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://essay.gan1ser.top/post/mu.gif" alt="Image 2 Description"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://pic.imgdb.cn/item/63f16cddf144a010070697c8.jpg"><div class="loading-image-dot"></div><div id="loading-percentage">0%</div></div></div><script>const loadingPercentage = document.getElementById("loading-percentage");
let loadingPercentageTimer = setInterval(function() {
  var progressBar = document.querySelector(".pace-progress");
  if (!progressBar) return
  var currentValue = progressBar.getAttribute("data-progress-text");
  if (currentValue !== loadingPercentage.textContent) {
    loadingPercentage.textContent = currentValue;
    if (currentValue === "100%") {
      clearInterval(loadingPercentageTimer);
    }
  }
}, 100);
const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
    Pace.restart()
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/progress_bar/progress_bar.css"><script async="async" src="https://npm.elemecdn.com/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div id="web_box"><div id="web_container"><div id="menu-mask"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">博客线路</div><div class="back-menu-list"><a class="back-menu-item" href="https://www.gan1ser.top" title="主域名线路" target="_blank"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/63f16cddf144a010070697c8.jpg" alt="主域名线路"><span class="back-menu-item-text">主域名线路</span></a><a class="back-menu-item" href="https://chenchuang.top" title="个人主页" target="_blank"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.gan1ser.top/2024/06/a8ecc570be921702fe5349062e33ae0f.png" alt="个人主页"><span class="back-menu-item-text">个人主页</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">智能传送</div><div class="back-menu-list"><a class="back-menu-item" href="https://www.github.com/Gan1Ser" title="Github主页" target="_blank"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/64ae1f611ddac507cceb714c.jpg" alt="Github主页"><span class="back-menu-item-text">Github主页</span></a><a class="back-menu-item" href="https://drive.gan1ser.top/" title="OneDrive" target="_blank"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/64400d200d2dde577785f5e5.jpg" alt="OneDrive"><span class="back-menu-item-text">OneDrive</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">GanSer</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/memos/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 即刻短文</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=7750616521&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/collect/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 影漫佳选</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/todolist/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 待办清单</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://pic.gan1ser.top/eassy/imageonline-co-convertedwebpimage%20(1).webp" target="_blank"><img class="post-qr-code-img" alt="wechat" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.gan1ser.top/eassy/imageonline-co-convertedwebpimage%20(1).webp"></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://pic.gan1ser.top/eassy/imageonline-co-convertedwebpimage.webp" target="_blank"><img class="post-qr-code-img" alt="alipay" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.gan1ser.top/eassy/imageonline-co-convertedwebpimage.webp"></a><div class="post-qr-code-desc">alipay</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments" onclick="anzhiyu.hideConsole()"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> <span>最新评论</span></span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags" onclick="anzhiyu.hideConsole()"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Butterfly/" style="font-size: 1.05rem;">Butterfly<sup>2</sup></a><a href="/tags/Github/" style="font-size: 1.05rem;">Github<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>1</sup></a><a href="/tags/MSP432/" style="font-size: 1.05rem;">MSP432<sup>4</sup></a><a href="/tags/PCB/" style="font-size: 1.05rem;">PCB<sup>1</sup></a><a href="/tags/Python/" style="font-size: 1.05rem;">Python<sup>2</sup></a><a href="/tags/python/" style="font-size: 1.05rem;">python<sup>3</sup></a><a href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" style="font-size: 1.05rem;">单片机<sup>6</sup></a><a href="/tags/%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">大学学习<sup>33</sup></a><a href="/tags/%E5%A5%BD%E8%BD%AF%E5%88%86%E4%BA%AB/" style="font-size: 1.05rem;">好软分享<sup>1</sup></a><a href="/tags/%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95/" style="font-size: 1.05rem;">实习记录<sup>1</sup></a><a href="/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/" style="font-size: 1.05rem;">年度总结<sup>1</sup></a><a href="/tags/%E5%BD%B1%E8%AF%84/" style="font-size: 1.05rem;">影评<sup>2</sup></a><a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 1.05rem;">教程<sup>14</sup></a><a href="/tags/%E6%99%BA%E8%83%BD%E8%BD%A6/" style="font-size: 1.05rem;">智能车<sup>20</sup></a><a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 1.05rem;">服务器<sup>1</sup></a><a href="/tags/%E6%B8%B8%E6%88%8F/" style="font-size: 1.05rem;">游戏<sup>3</sup></a><a href="/tags/%E7%9F%A5%E8%AF%86/" style="font-size: 1.05rem;">知识<sup>53</sup></a><a href="/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">神经网络<sup>1</sup></a><a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 1.05rem;">笔记<sup>34</sup></a><a href="/tags/%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6/" style="font-size: 1.05rem;">考研数学<sup>1</sup></a><a href="/tags/%E9%9A%8F%E6%89%8B%E5%B0%8F%E8%AE%B0/" style="font-size: 1.05rem;">随手小记<sup>85</sup></a><a href="/tags/%E9%9D%9E%E9%85%8B%E6%8A%BD%E5%8D%A1/" style="font-size: 1.05rem;">非酋抽卡<sup>1</sup></a><a href="/tags/%F0%9F%90%89%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF/" style="font-size: 1.05rem;">🐉青龙面板<sup>1</sup></a><a href="/tags/%F0%9F%92%BB%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 1.05rem;">💻服务器<sup>3</sup></a><a href="/tags/%F0%9F%92%BB%E9%9A%8F%E8%BA%ABWIFI/" style="font-size: 1.05rem;">💻随身WIFI<sup>1</sup></a><a href="/tags/%F0%9F%93%95%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/" style="font-size: 1.05rem;">📕年度总结<sup>1</sup></a><a href="/tags/%F0%9F%93%B1%E6%90%9E%E6%9C%BA/" style="font-size: 1.05rem;">📱搞机<sup>3</sup></a></div></div><hr></div></div><div class="console-card history" onclick="anzhiyu.hideConsole()"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">八月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">14</span><span>篇</span></div></a></li></ul></div><hr></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" onclick="anzhiyu.switchDarkMode()" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div><div class="console-btn-item" id="consoleKeyboard" onclick="anzhiyu.keyboardToggle()" title="快捷键开关"><a class="keyboard-switch"><i class="anzhiyufont anzhiyu-icon-keyboard"></i></a></div><div id="console-naoDark"><div class="container"><div class="components"><div class="main-button"><div class="moon"></div><div class="moon"></div><div class="moon"></div></div><div class="daytime-backgrond"></div><div class="daytime-backgrond"></div><div class="daytime-backgrond"></div><div class="cloud"><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div></div><div class="cloud-light"><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div><div class="cloud-son"></div></div><div class="stars"><div class="star big"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div><div class="star big"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div><div class="star medium"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div><div class="star medium"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div><div class="star small"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div><div class="star small"><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div><div class="star-son"></div></div></div></div></div></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E5%AD%A6%E5%AD%A6%E4%B9%A0/">大学学习</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E7%9F%A5%E8%AF%86/" tabindex="-1"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>知识</span></a><a class="article-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/" tabindex="-1"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>笔记</span></a></span></div></div><h1 class="post-title">《单片机原理及运用》学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-13T22:14:00.000Z" title="发表于 2023-03-13 22:14:00">2023-03-13</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-13T22:14:00.000Z" title="更新于 2023-03-13 22:14:00">2023-03-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">50.9k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>193分钟</span></span><span class="post-meta-separator"></span><span id="" data-flag-title="《单片机原理及运用》学习笔记"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="twikoo_visitors" title="评论数"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为郑州"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>郑州</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://pic.gan1ser.top/posts/1.webp/cover"></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><div class="note success modern"><p>《单片机原理及运用》开课了(<em>^_^</em>)！！要好好学习，搞钱啊！！！</p>
</div>
<div class="note success modern"><p>感谢B站UP猪知弦的教学指导</p>
</div>
<div class="note success modern"><p>文章中安装的Keil软件和Proteus软件在我的个人<a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cubGl2ZXIubHRkL2FsaXN0LyVFOSU5OCVCRiVFOSU4NyU4QyVFNCVCQSU5MSVFNyU5QiU5OC8lRTUlOEQlOTUlRTclODklODclRTYlOUMlQkElRTglQkQlQUYlRTQlQkIlQjYuemlw">网盘</a>，这里要感谢吕老师上传的教学文件以及孜孜不倦的教导</p>
</div>
<div class="note success modern"><p>文章中涉及的源码，均以我自己的单片机为准，例如我的LED灯有总开关，如果你没有请自行修改代码，祝你学有所成(<em>^_^</em>)，我会注明实际和理论的代码</p>
</div>
<h2 id="一-单片机开发与仿真环境搭建">一、单片机开发与仿真环境搭建</h2>
<div class="note success modern"><p>简单的部分我就直接照搬吕老师的课件了，部分需要注意的地方我会做GIF演示，侵删</p>
</div>
<h3 id="1-1-keil-软件">1.1 Keil 软件</h3>
<h4 id="1-1-1-keil软件的简介">1.1.1 Keil软件的简介</h4>
<p>大家安装完Keil软件肯定是要学习使用的，这里不建议将软件汉化，软件本来原生态的样子就很看，要学会适应英化的软件。</p>
<p><font color="#deb887">Keil C51</font> 是德国 Keil Software 公司（现已被 ARM 收购）推出的 8051 系列的 IDE(Integrated Development,集成开发环境)。它不仅支持汇编语言开发，更支持 C/C++等高级语言开发单片机。其可以完成从工程建立和管理、编译、链接、目标代码生成、软件仿真调试等完整的开发流程。</p>
<h4 id="1-1-2-keil-c51的工作界面">1.1.2 Keil C51的工作界面</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://essay.gan1ser.top/post/image-20240517085113297.png" alt="1"></p>
<h4 id="1-1-3-keil-c51建立工程">1.1.3 Keil C51建立工程</h4>
<p>首先你需要在电脑文件资源管理器中新建一个文件夹用来存放你的工程，下面是新建工程的GIF演示。注意的<code>AT89C52</code>是吕老师要求的，如果不一样请换成你们的，如果直接找<code>AT89C52</code>是找不到的，要先找对应的厂商然后点击<code>+</code>就可以看到相对应的芯片型号了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d8bdef144a0100715f193.gif" alt=""></p>
<h4 id="1-1-4-建立-编辑c语言源程序文件">1.1.4 建立/编辑C语言源程序文件</h4>
<p>下面是GIF演示，比较简单，一定要记得后缀是<code>.c</code>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d8ecef144a010071b27be.gif" alt=""></p>
<p>以上，我们就完成了最基本的软件使用，下面是一些进阶使用。</p>
<h4 id="1-1-5-工程的设置">1.1.5 工程的设置</h4>
<p>在工程建立后，还需要对工程进行设置。在 μVision5 的上方工具栏中，右击工程名 Target 1 框旁的魔术棒   ，即打开工程设置对话框。啊，好多我也不懂，看老师PPT吧，这些你说重要吧它也不是那么重要，看一遍过去吧。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d8f81f144a010071c461b.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d9022f144a010071d52f4.png" alt=""><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d9023f144a010071d5363.png" alt=""><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d9023f144a010071d53f9.png" alt=""><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d9023f144a010071d544f.png" alt=""><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d9025f144a010071d56d1.png" alt=""></p>
<h4 id="1-1-6-keil-c51-的debug">1.1.6 Keil C51 的Debug</h4>
<p>大家都知道Debug在调试程序中重要地位，所以我将Keil C51的Debug单独拿出来学习。</p>
<p>源程序编写完毕后还需要编译和链接才能够进行软件和硬件仿真。① 编译；②排错；在程序的编译/链接中，如果用户程序出现错误，还需要修正错误后重新编译/链接，重新烧录程序查看错误现象，十分消耗时间。因此需要单步调试，一步一步的查看代码运行效果来加快对错误的排查速度。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d91baf144a010072027dd.png" alt=""></p>
<p>进入DEBUG模式后，黄色箭头为汇编程序运行位置光标，<code>蓝黄三角形</code>为当前 C 语言运行位置，指向当前等待运行程序行。其界面如下,其中<code>单个黄色箭头</code>为汇编程序运行位置光标(汇编一生之痛)。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d92ebf144a01007222fa7.png" alt=""></p>
<p>在 μVision5 中，有 4 种DEBUG运行方式 ：单步跟踪(Step Into)，单步运行(Step Over)，运行到光标处(Run to Cursor line)，全速运行(Go)。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d9352f144a0100722f193.png" alt=""></p>
<p>下面是使用Debug进行调试的GIF录像，测试用例如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 理论</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit led0 = P0^<span class="number">0</span>;</span><br><span class="line">sbit led1 = P0^<span class="number">1</span>;</span><br><span class="line">sbit led2 = P0^<span class="number">2</span>;</span><br><span class="line">sbit led3 = P0^<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sbit led4 = P0^<span class="number">4</span>;</span><br><span class="line">sbit led5 = P0^<span class="number">5</span>;</span><br><span class="line">sbit led6 = P0^<span class="number">6</span>;</span><br><span class="line">sbit led7 = P0^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    led0 = <span class="number">0</span>;</span><br><span class="line">    led1 = <span class="number">0</span>;</span><br><span class="line">    led2 = <span class="number">0</span>;</span><br><span class="line">    led3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    led4 = <span class="number">0</span>;</span><br><span class="line">    led5 = <span class="number">0</span>;</span><br><span class="line">    led6 = <span class="number">0</span>;</span><br><span class="line">    led7 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d952cf144a010072631a1.gif" alt=""></p>
<h4 id="1-1-7-存储空间资源的查看和修改">1.1.7 存储空间资源的查看和修改</h4>
<p>这一部分对我来说还是太早了，先看PPT吧</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d95b1f144a01007270b88.png" alt=""><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d95b1f144a01007270bdb.png" alt=""><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d95b1f144a01007270c3f.png" alt=""></p>
<h3 id="1-2-proteus软件">1.2 Proteus软件</h3>
<h4 id="1-2-1-proteus软件的简介">1.2.1 Proteus软件的简介</h4>
<p>① Proteus 是英国 Lab Center Electronics 公司推出的用于仿真单片机及其外围设备的EDA工具软件。</p>
<p>② Proteus 与 Keil C51 配合使用，可以在不需要硬件投入的情况下，完成单片机 C 语言应用系统的仿真开发。</p>
<p>③ Proteus 具有高级原理布图(proteus)、混合模式仿真(PROSPICE)、PCB 设计以及自动布线(ARES)等功能。</p>
<h4 id="1-2-2-proteus简单使用">1.2.2 Proteus简单使用</h4>
<p>继续看PPT吧，一定要看啊，我是太懒了就不想打字😀</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d9807f144a010072b0e45.png" alt=""><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d9807f144a010072b0eb6.png" alt=""><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d9807f144a010072b0f42.png" alt=""><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d9807f144a010072b0fdc.png" alt=""><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d9808f144a010072b1099.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d9837f144a010072b5b0e.png" alt=""><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d9838f144a010072b5b72.png" alt=""><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d9838f144a010072b5bd1.png" alt=""><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d9838f144a010072b5c1c.png" alt=""><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d9838f144a010072b5c79.png" alt=""></p>
<h4 id="1-2-3-proteus-8-与-keil-c51-的联合使用">1.2.3 Proteus 8 与 Keil C51 的联合使用</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d988bf144a010072bd8a1.png" alt=""></p>
<p>下面进行基本演示：① 将源程序编译、链接生成<code>HEX</code>文件，这里需要将工程设置中的Output设置中的<code>Create HEX File</code>勾选上。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d9c4ef144a010073361a7.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640d9e4af144a01007384827.gif" alt=""></p>
<h4 id="1-2-4-proteus-画出单片机的最小系统">1.2.4 Proteus 画出单片机的最小系统</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640db370f144a01007609b6b.png" alt=""></p>
<p>使用Proteus选择元器件的方法如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640db48ff144a010076277f0.png" alt=""></p>
<p>电气连接方法如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640db592f144a010076428a8.png" alt=""></p>
<h4 id="1-2-5-实战教学：流水灯的实现">1.2.5 实战教学：流水灯的实现</h4>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit LED=P0^<span class="number">0</span>;</span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;t;i++)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">120</span>;j++);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">led</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">	{</span><br><span class="line">		P0=~(<span class="number">0x01</span>&lt;&lt;i);</span><br><span class="line">		delay(<span class="number">50</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">	</span><br><span class="line">	ENLED = <span class="number">0</span>;</span><br><span class="line">	ADDR3 = <span class="number">1</span>;</span><br><span class="line">	ADDR2 = <span class="number">1</span>;</span><br><span class="line">	ADDR1 = <span class="number">1</span>;</span><br><span class="line">	ADDR0 = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">		led();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>搭建如图所示仿真电路，这里采用共阳极二极管接法</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640de18cf144a01007c42ed0.png" alt=""></p>
<p>然后对C源码进行编译生成<code>HEX</code>文件，之后导入芯片中</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640de219f144a01007c5cadd.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640de2f7f144a01007c7ca03.gif" alt=""></p>
<h3 id="1-3-stc-isp软件">1.3 STC-ISP软件</h3>
<h4 id="1-3-1-stc-isp软件的简介">1.3.1 STC-ISP软件的简介</h4>
<p>STC-ISP是一款又 STC 研发的单片机程序下载烧录软件，是针对 STC 系列单片机而设计的，可下载 STC89 系列、STC12 系列和 STC15 等系列的 STC 单片机，使用简便。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640de41ff144a01007ca1c8a.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640de44cf144a01007ca75c4.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640de44cf144a01007ca75c4.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640de44cf144a01007ca75c4.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640de44cf144a01007ca75c4.png" alt=""></p>
<h4 id="1-3-2-stc-isp软件的使用">1.3.2 STC-ISP软件的使用</h4>
<p>安装好STC-ISP和驱动后，当我们电脑插上板子之后，打开设备管理器，查看端口，我这里是<code>COM12</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640df64ff144a01007f07897.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640f2776f144a01007f2c334.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640f292ef144a01007f61feb.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640f2d80f144a01007feb12a.gif" alt=""></p>
<h4 id="1-3-3-实战教学：-点亮第一个led灯">1.3.3 实战教学： 点亮第一个LED灯</h4>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit LED = P2^<span class="number">0</span>;</span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    ENLED = <span class="number">0</span>;</span><br><span class="line">	ADDR3 = <span class="number">1</span>;</span><br><span class="line">	ADDR2 = <span class="number">1</span>;</span><br><span class="line">	ADDR1 = <span class="number">1</span>;</span><br><span class="line">	ADDR0 = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    LED = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6411727febf10e5d53f4ca25.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6411727eebf10e5d53f4c921.gif" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/64117634ebf10e5d53fce4d3.jpg" alt=""></p>
<h3 id="1-4-单片机最小系统">1.4 单片机最小系统</h3>
<p>单片机最小系统也叫做单片机最小应用系统，是指用最少的原件组成单片机可以工作的系统。单片机最小系统的三要素就是<code>电源、晶振、复位电路</code>。如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/64268bc2a682492fccb2fc91.png" alt=""></p>
<h4 id="1-4-1-电源">1.4.1 电源</h4>
<h4 id="1-4-2-晶振">1.4.2 晶振</h4>
<h4 id="1-4-3-复位电路">1.4.3 复位电路</h4>
<p>复位电路是一种用来使电路恢复到起始状态的电路设备，它的操作原理与<code>计算器</code>有着异曲同工之妙，只是启动原理和手段有所不同。复位电路，就是利用它把电路恢复到起始状态。就像计算器的清零按钮的作用一样，以便回到原始状态，重新进行计算。</p>
<p>和计算器清零按钮有所不同的是，复位电路启动的手段有所不同。一是在给电路通电时马上进行复位操作；二是在必要时可以由手动操作；三是根据程序或者电路运行的需要自动地进行。复位电路都是比较简单的大都是只有电阻和电容组合就可以办到了，再复杂点就有三极管等配合程序来进行了。（上电复位和手动复位和程序自动复位）</p>
<p><code>上电复位</code>：假如我们的单片机程序有 100 行，当某一次运行到第 50 行的时候，突然停电了，这个时候单片机内部有的区域数据会丢失掉，有的区域数据可能还没丢失。那么下次打开设备的时候，我们希望单片机能正常运行，所以上电后，单片机要进行一个内部的初始化过程，这个过程就可以理解为上电复位，上电复位保证单片机每次都从一个固定的相同的状态开始工作。这个过程跟我们打开电脑电源开电脑的过程是一致的。</p>
<p><code>手动复位</code>：当我们的程序运行时，如果遭受到意外干扰而导致程序死机，或者程序跑飞的时候，我们就可以按下一个复位按键，让程序重新初始化重新运行，这个过程就叫做手动复位，最典型的就是我们电脑的重启按钮。</p>
<p><code>程序自动复位</code>：当程序死机或者跑飞的时候，我们的单片机往往有一套自动复位机制，比如看门狗，具体应用以后再了解。在这种情况下，如果程序长时间失去响应，单片机看门狗模块会自动复位重启单片机。还有一些情况是我们程序故意重启复位单片机</p>
<p><strong>程序跑飞是指系统受到某种干扰后,程序计数器PC的值偏离了给定的唯一变化历程,导致程序运行偏离正常的运行路径.程序跑飞因素及后果往往是不可预计的.在很多情况下,程序跑飞后系统会进入死循环而导致死机。</strong></p>
<h4 id="1-4-4-单片机看门狗">1.4.4 单片机看门狗</h4>
<p>看门狗(WDT)是一个<code>定时器</code>。看门狗是用来防止万一单片机程序出错造成重大损失的。防错的原理很简单，它在硬件上就是一个定时器，当它溢出的时候就会让单片机强制复位使程序重新开始执行。</p>
<p>正常的情况下是不能让它溢出的，所以在程序上每隔一段时间要给他置一次值（俗称喂狗），只要程序中正常给它喂他就不会溢出。</p>
<p>一旦程序跑飞了，有干扰或者进入死循环之类的情况时，不能正常执行程序了，那么就永远执行不到喂狗的指令了，但此时定时器是硬件控制的，仍然会走，所以溢出了，单片机就复位了。</p>
<p>一般安全性要求比较高的，系统跑飞了会造成重大事故的都会加一个“狗”保安全。</p>
<p>通常，看门狗的溢出时间越短越灵敏，跑飞之后复位的时间越短，也就越安全，但是，喂狗的操作也要更频繁。</p>
<h3 id="1-5-led小灯原理">1.5 LED小灯原理</h3>
<p>LED(light-emitting diode)，即发光二极管，俗称 LED 小灯，它的种类很多，参数也不尽相同，我们板子上用的是普通的贴片发光二极管。这种二极管通常的正向导通电压是 1.8V到 2.2V 之间，工作电流一般在 1mA～20mA 之间。其中，当电流在 <code>1mA～5mA</code>之间变化时，随着通过 LED 的电流越来越大，我们的肉眼会明显感觉到这个小灯越来越亮，而当电流从5mA～20mA 之间变化时，我们看到的发光二极管的亮度变化就不是太明显了。当电流超过20mA 时，LED 就会有烧坏的危险了，电流越大，烧坏的也就越快。所以我们在使用过程中应该特别注意它在电流参数上的设计要求。</p>
<h4 id="1-5-1-usb接口电路">1.5.1 USB接口电路</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://essay.gan1ser.top/post/12image-20230331162131030.png" alt="12image-20230331162131030"></p>
<p>通过 USB 线，电脑给我们的开发板供电和下载程序以及实现电脑和开发板之间的通信。从图上可以看出，USB 座共有 <code>6</code> 个接口，其中 2<br>
脚和 3 脚是<code>数据通信引脚</code>，1 脚和 4 脚是<code>电源引脚</code>，1 脚是<code> VCC 正电源</code>，4 脚是 <code>GND 即地线</code>。5 脚和 6 脚是<code>外壳</code>，我们直接接到了 GND 上，大家可以观察一下开发板上的这个 USB座的 6 个引脚。</p>
<p>我们现在主要来看 1 脚 VCC 和 4 脚 GND。1 脚通过 F1（自恢复保险丝）接到右侧，在正常工作的情况下，保险丝可以直接看成导线，因此左右两边都是 USB 电源+5V，自恢复保险丝的作用是，<code>当你后级电路哪个地方有发生短路的时候，保险丝会自动切断电路，保护开发板以及电脑的 USB 口</code>，当电路正常后，保险丝会恢复畅通，正常工作。右侧有 2 条支路，第一条是在+5V 和 GND 接了一个 470uF 的电容，电容是隔离直流的，所以这条支路是没有电流的，电容的作用，我们下节课再介绍，这节课我们主要看第二条支路。我们把第二条支路摘取出来就是如图 2-4 这个样子。</p>
<h4 id="1-5-2-led小灯电路">1.5.2 LED小灯电路</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://essay.gan1ser.top/post/12image-20230331163030645.png" alt="12image-20230331163030645"></p>
<p>发光二极管是二极管中的一种，因此和普通二极管一样，这个二极管也有阴极和阳极，习惯上也称之为负极和正极。我们接入的 VCC 电压是 5V，发光二极管自身<code>压降</code>大概是 2V，那么在右边 R34 这个电阻上承受的电压就是 3V。现在我们要求电流范围是 1~20mA 的话，就可以根据欧姆定律 R=U/I，把这个电阻的上限和下限值求出来：U=3V，当电流是 1mA 的时候，电阻值是 3K；当电流是 20mA 的时候，电阻值是 150欧，也就是 R34 的取值范围是 150~3K 欧姆。这个电阻值大小的变化，直接可以限制整条通路的电流的大小，因此这个电阻我们通常称之<code>限流电阻</code>。同理，我们在板子后级开关控制的地方，又添加了一个 LED10 发光二极管，作用就是当我们打开开关时，这个二极管才会亮起。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://essay.gan1ser.top/post/12image-20230331163621172.png" alt="12image-20230331163621172"></p>
<p>这里的开关虽然只有一个，但是是 <code>2 路</code>的，<code>2 路开关并联</code>能更好的确保给后级提供更大的电流。电容 C19 和 C10，都是隔离断开直流的。把右侧的 GND 去掉，改成一个单片机的<code>IO</code>口，如图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://essay.gan1ser.top/post/12image-20230331163940682.png" alt="12image-20230331163940682"></p>
<p>我们把右侧的原 GND 处接到单片机 P0.0 引脚上，那么如果我们单片机输出一个<code>低电平</code>，也就是跟 GND 一样的 0V 电压，就可以让 LED<br>
小灯发光了。我们可以让 P0.0 这个引脚输出一个高电平，就是跟 VCC 一样的 5V 电压，那么这个时候，左侧 VCC 电压和右侧的 P0.0 的电压是一致的，那就没有电压差，没有电压差就不会产生电流，没有电流 LED 小灯就不会亮，也就是会处于熄灭状态。</p>
<h4 id="1-5-3-单片机端口">1.5.3 单片机端口</h4>
<p><code>STC89C52RC</code>芯片有<code>4*8=32</code>个IO端口可以供我们用程序输出高低电平。拿<code>P0</code>表示它可以一次性控制8个引脚端口输出每个引脚想输出的电平状态。<code>P0</code>是一个寄存器，它的功能是控制所对应的8个IO口(<code>P0.0-P0.7</code>)。如果我们控制<code>P0.0</code>单个端口输出低电平，<code>P0.1~P0.7</code>这7个IO端口输出高电平，程序中使用这条语句<code>P0=0xFE</code>;为什么是<code>0xFE</code>呢？</p>
<p>C语言中的十六进制<code>0xFE</code>用二进制表示<code>11111110</code>，我们就知道了单片机的<code>P0.0</code>排在这八个位的最低端。我们控制P0.2单个IO端口输出低电平，其他IO端口输出高电平，则是<code>P0=0xFB</code>; 二进制表示<code>11111011</code>。</p>
<p>显然我们使用<code>P0=0xFE</code>就是强制把其他7个IO端口都输出了固定高电平状态。要想实现单独控制一个IO端口，这时我们用这条语句来声明<code>sbit LED=P0^0;</code>也就是只控制一个位，此时想让单独的P0.0输出低电平只需<code>LED=0;</code>即可，LED不过是表示P0.0所用的名字而已,你可以根据喜好改写这个名字。值得注意的是，程序书写中如果没有<code>sbit LED=P0^0;</code>这个提前定义，直接<code>P0.0=0;</code>这样书写是不符合语法的，必须先给IO端口一个命名，而且<code>sbit LED=P0.0;</code>这样的写法同样也不符合语法，规定是<code>P0^0</code>。还有我们也不能命名已经在 <code>#include&lt;reg52.h&gt;</code>头文件中已有的名字，查看头文件内容可知，有些名字已经被使用，像<code>sbit PSW=P0^0;</code>，<code>sbit CY=P0^0;</code>这样定义会编译报错的，因为命名冲突了。<code>#include&lt;reg52.h&gt;</code>头文件中已有的名字我们后期会使用到的。</p>
<h4 id="1-5-4-实际led硬件连接">1.5.4 实际LED硬件连接</h4>
<h5 id="1-5-4-1-三极管认识">1.5.4.1 三极管认识</h5>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/642bb2916ea21b9a9e06a6d0.png" alt=""></p>
<p>先看左边的图，想要点亮LED灯，只需要<code>+5v</code>和<code>R1</code>处于短接状态即可，那么PNP型三极管就是起到被单片机IO端口控制是否允许此处短接的作用，也叫三极管是否导通。如果单片机IO端口输出的是<code>低电平</code>（0V）,此时我们可以直观的认为<code>+5</code>那端与单片机IO端口形成压差有电流通过，而电流流向正如箭头所示，则表明此时<code>+5</code>与<code>R1</code>是<code>短接状态</code>，三极管导通，灯就被点亮了。如果单片机IO端口输出的是<code>高电平</code>（5V）时，则没有形成压差也就产生不了电流，那么箭头不能代表此时有电流流向这个方向，所以<code>+5</code>与<code>R1</code>是断开状态，灯没有被点亮。箭头起到的就是辅助我们理解的优势，这样我们可以根据箭头很形象的判断出单片机IO端口输出什么电平状态时就可以点亮LED。R1,R2电阻起到的是限流保护，右图使用的是NPN型三极管，那么单片机IO端口输出高电平时点亮LED,输出低电平时点不亮LED。</p>
<div class="tip warning faa-horizontal animated"><p>详细的可以看宋老师的《手把说教你51单片机》的第3.3节</p>
</div>
<h5 id="1-5-4-2-三八译码器">1.5.4.2 三八译码器</h5>
<p>该元器件只需要用到我们单片机三个IO端口就可以控制它的八个引脚其中的一个输出低电平，开发板就用到这种叫74HC138三八译码器。我们省略它的电源供电引脚，画出需要讲解的引脚。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/642bb66e6ea21b9a9e0fbd97.png" alt=""></p>
<p>首先有三个引脚<code>E0,E0,E1</code>需要固定给它默认的电平它才能正常工作，俗称<code>使能器件</code>。</p>
<p>此时3个单片机IO端口输出不一样的电平时，IO0~IO7的其中一个引脚就会输出低电平，而其他7个IO都是输出高电平。</p>
<p>当我们的三个IO端口这样输出时，则有以下情况</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/642bb70b6ea21b9a9e1173c2.png" alt=""></p>
<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">三个IO端口输出的三个值从 IO端口3→IO端口2→IO端口1排成二进制数的得数就是哪个IOx输出低电平。比如三个IO端口这样输出：1 1 0。此时二进制值为十进制的6，那么IO6就输出低电平，其他输出高电平</span><br></pre></td></tr></tbody></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/642bb80a6ea21b9a9e16b8d5.png" alt=""></p>
<h3 id="1-6-蜂鸣器原理">1.6 蜂鸣器原理</h3>
<h4 id="1-6-1-单片机io端口电流">1.6.1 单片机IO端口电流</h4>
<p>不知道大家有没有发现，绝大部分单片机上的LED小灯电路基本都是确定<code>+5v</code>正压，而让单片机IO口输出低电平使小灯发光。为什么呢？</p>
<p>我们来看看宋老师的讲解吧。下面是两个LED小灯电路</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/642beb826ea21b9a9e3c9f30.png" alt=""></p>
<p><code>左边电路</code>即使单片机IO端口输出高电平5V，灯的亮度是很低的，因为单片机IO端口流出来的<code>电流</code>太小，无法驱动LED正常发光。这个是关联到单片机内部的<code>集成电路</code>原因的，大家可以上网上查查。</p>
<p><code>右边电路</code>这时单片机IO端口输出低电平时灯却很亮，原因这是电源供给的5V，<code>电流比较大</code>，所以可以使LED发光较亮。举个例子：充电宝的接口输出电压5V，但是它流出的电流大，所以给手机充电就快，虽然电脑USB口接口电压也是5V但充电却非常慢，原因是USB口电流太小。</p>
<p>STC89C52RC这款芯片的P1，P2，P3这一共24个IO端口由于内部硬件的原因上电的时候都是输出高电平的，而P0一开始是一种不确定的状态（有时是高有时是低），但我们用的开发板已经把P0端口接了上拉电阻，所以开发板的P0.0~P0.7初始时也是输出高电平的。</p>
<h4 id="1-6-2-有源蜂鸣器">1.6.2 有源蜂鸣器</h4>
<p><code>蜂鸣器</code>分<code>有源蜂鸣器</code>和<code>无源蜂鸣器</code>，两者表面长相相同，有源蜂鸣器有正负极之分，正极接5V，负极接地就可以响。和LED小灯一样，我们可以从简到繁的理解有源蜂鸣器。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/642bed2d6ea21b9a9e494b28.png" alt=""></p>
<h4 id="1-6-3-无源蜂鸣器">1.6.3 无源蜂鸣器</h4>
<p>开发板中无源蜂鸣器硬件连接除了一个续流二极管外就如有源蜂鸣器一样了，无源蜂鸣器实物可以不分正负极接，但它也标有“+”符号，也许是为了在我们不知道这是有源蜂鸣器还是无源蜂鸣器的情况上统一规定接法吧。</p>
<p>要让无源蜂鸣器发声，需要我们在单片机IO端口上输出<code>500Hz~4.5kHz</code>的脉冲频率信号。</p>
<p>用时间表示就是要输出周期为<code>0.22ms~2ms（（1/4500s）~（1/500s））</code>范围的方波,这个周期内高电平时间和低电平时间各占一半。</p>
<h4 id="1-6-4-无源蜂鸣器鸣叫">1.6.4 无源蜂鸣器鸣叫</h4>
<ol>
<li>输出方波图解</li>
</ol>
<p>现在要给单片机IO端口输出4KHz的方波，其方波周期为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>4000</mn></mfrac><mo>=</mo><mn>0.25</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\frac{1}{4000}=0.25ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">2</span><span class="mord">5</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>，高电平时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>0.25</mn><mn>2</mn></mfrac><mo>=</mo><mn>0.125</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\frac{0.25}{2}=0.125ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mtight">.</span><span class="mord mtight">2</span><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mord">2</span><span class="mord">5</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>，低电平时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>0.25</mn><mn>2</mn></mfrac><mo>=</mo><mn>0.25</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\frac{0.25}{2}=0.25ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mtight">.</span><span class="mord mtight">2</span><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">2</span><span class="mord">5</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/642c4b9ca682492fccd05a3a.png" alt=""></p>
<h3 id="1-7-独立按键">1.7 独立按键</h3>
<p>独立按键是单片机最常用的硬件部分</p>
<h4 id="1-7-1-独立按键与矩阵按键">1.7.1 独立按键与矩阵按键</h4>
<p>4个独立按键已经可以满足大部分的程序测试。学会了独立按键，矩阵按键是十分好学的。</p>
<p>首先看一下我们按键的分布</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/642f6fa3a682492fccdabc8c.png" alt=""></p>
<p>看一下是K4按键的电路图，我们让单片机的P2.3输出<code>低电平</code>，按键被按下，则被圈出部分的电压均为0V，因为都接地了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/642f7074a682492fccdb5ba0.png" alt=""></p>
<h4 id="1-7-2-按键的原理">1.7.2 按键的原理</h4>
<p>单片机上的按键使用的是没有自锁的按钮，当我们按下按键后两个断点就被短接起来，松手后，按键自动弹起两个断点恢复原来的状态不再短接。</p>
<p>使用P2.7进行理解，我们按下K4按键，则断点之间导通，P2.7与GND连接被接地，此时P2.7的IO端口为0V，也就是低电平，俗称<code>被拉低</code>。这时候即使是程序令P2.7输出5V高电平都于事无补，因为这是<code>外部电路直接导致</code>，IO端口就是0V。内部硬件也能感觉到这个信号属于被强制拉低。因此<code>程序中寄存器位的值是可以受外部电路影响而改变的</code>。</p>
<p>基于以上我们对按键的认识我们理想中的按键过程图如下。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://essay.gan1ser.top/post/12image-20230408175442749.png" alt="12image-20230408175442749"></p>
<h4 id="1-7-3-按键用法">1.7.3 按键用法</h4>
<p>联系生活按键的常用做法就像生活中的电磁炉或者门铃那样，按下电磁炉上的加热功能键后马上松开，发现电磁炉上的数就增加了。现在我们打算用开发板像按电磁炉上的按键一样，<code>按一下灯被点亮，再按一次灯被熄灭</code>这样的来回切换灯的状态的功能。</p>
<p>我们之前所讲的按键过程解析图只是理想中的效果，真正的按键过程图是这样的<code>(按键的抖动)</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/643144600d2dde57778b4215.png" alt=""></p>
<p>按键按下的前期，IO端口并不是马上就接通地而处在稳定状态的，按键按下时，IO端口有短暂的时间接通地之后又松开了这么的一个来回的过程，这是自弹式按键本身的结构属性，此处称作按键抖动。如果我们一直<code>按着不放</code>，这时IO端口就会处在一种很稳定的接触状态，当我们<code>松开按键</code>时也会产生弹起抖动，这种抖动持续时间一般少于10ms。在之前的实验中，按键动作常速下“稳定接触状态”也会持续在50ms，这个时候程序去读取稳定的状态时是0，这样就可以判断是否按键已经按下，按下了就执行相应的程序功能。</p>
<p>那么我们如何处理这种<code>抖动状态</code>呢？</p>
<p>我们在软件上可以这样处理，当程序检测到上图的A段时“if(KEY4==0)”满足了条件，但是KEY4因为按键的抖动会在短时间里时而变为1时而变为0，所以我们在满足第一个“if(KEY4==0)”条件的时候马上做延时50ms，等待抖动过去，然后再次判断此时的KEY4还是等于0吗，是的话就执行切换灯的状态程序。（双层if嵌套，使用第一个if判断是否为低电平，延迟后判断是否是稳定态）,图解如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/64314c280d2dde57779cf4f7.png" alt=""></p>
<p>但是在代码实现后，如果我们按下按键一直不松手，则灯会一直闪烁。这是因为“稳定接触状态”一直保持着长时间的低电平，所以程序的二次“if(KEY4==0)”判断一直满足条件就会在“LED2=0;”和“LED2=1;”之间来回切换，再加上50ms延时才会保持亮一段时间灭一段时间所体现的LED闪烁。</p>
<h4 id="1-7-4-按键模式">1.7.4 按键模式</h4>
<p>按键模式主要分为两种<code>支持连按</code>和<code>不支持连按</code>。其中支持连按即我们使用遥控器放大电视的音量时只需按住“+”键不放，屏幕上的音量值在一直累加，松手后就停止累加了，这种就叫做按键支持连按功能。不支持连按”，例如我们用的电磁炉上的“+”键，按下不松手时数值只加一次就不加了，只有松手后再按才会进行数值的第二次累加。两种按键模式在单片机开发中都会经常使用。</p>
<h4 id="1-7-5-不支持连按模式">1.7.5 不支持连按模式</h4>
<p>我们要实现<code>稳定接触状态</code>的时间再怎么长，只能执行一次功能代码的目的。我们可以利用<code>IO端口</code>检测到按键按下然后执行完功能程序之后，下一个语句就写：如果IO端口还是保持着低电平（不松手状态），那程序就不往下执行了，让程序在这里“停止”，只有IO端口变成高电平（已松手）才允许“放行”程序去运行。我们知道按键抖动的时间少于10ms，所以在满足第一次“if(KEY4==0)”判断的时候只做“delay_ms(10);”的延时左右，过了这段时间就是“稳定接触状态”了，于是再去二次判断“if(KEY4==0)”即可。</p>
<p>以上虽然我们仅用<code>while(KEY4==0)</code>就把按键模式给切换了，不过这条语句严格来说是有缺陷的。如果我们编写更加复杂的程序时，<code>while(KEY4==0)</code>就成了Bug了。如果我们对按键按下不松手，那程序就一直在循环等待，不遇到高电平就不往下执行代码，如果这时有重要的程序要执行，那岂不是因按键而耽误。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">    <span class="keyword">if</span>(KEY4==<span class="number">0</span>) {</span><br><span class="line">        delay(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">if</span>(KEY4 == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">//要执行某些功能的语句</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>即使我们不使用<code>while(KEY4==0);</code>，只要我们按键不松手，每次都要执行<code>delay_ms(10);</code>，这样的代码称不上高效率，我们只能再次完善代码了。</p>
<p>所以我们需要改善我们的程序，这里为了让程序做到通用性，我们定义一个<code>key_up</code>为<code>unsigned char</code>类型的变量。我们新定义的key_up变量是用来记录此时按键IO端口的扫描值，进一步分析，当按键按下不松手时，此时的key_up等于KEY4（也就是0），当按键松手后，key_up就等于1了。然后想进入执行功能语句时，先过了“if(key_up==0)”这一关，因为我们一直让key_up在死循环里存取KEY4的值，所以只要没有按键动作，key_up一直等于1，这样连进入功能语句的第一关都没有资格。</p>
<p>当有按键按下时，key_up等于0了，进入了第一关，然后我们再设最后一关，如果通过了最后一关就可以执行功能语句了，最后一关是判断“if(KEY4==1)”，也就是说如果按键没松手，就无法执行功能语句了。没错，我们这次的不支持连按模式是只有按键松手之后才去执行的，上一讲则是按下之后过了10ms就执行代码了。大家可以根据这一思路写代码了。</p>
<h4 id="1-7-6-回归按键">1.7.6 回归按键</h4>
<p>按键的执行任务也可以封装为函数，需要静态变量<code>static</code>去定义key_up，因为它需要跟着KEY4变化，而不是每次都被初始化为同一个值。</p>
<h4 id="1-7-7-支持连按-全局变量">1.7.7 支持连按（全局变量）</h4>
<p><code>支持连按</code>的代码就是在<code>不支持连按</code>代码的思路上把<code>if(KEY4==1/0)</code>改为<code>if(KEY4==0/1)</code>，这样的话按键不松手程序就能一直进入<code>if(KEY4==0/1)</code>的大括号里面。然后我们定义一个变量times，如果一直按着不放，times就一直累加，累加到1000，意味着低电平已经持续了一定的时间，我们就可以执行功能代码了，如图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/64351aac0d2dde57776ffb23.png" alt=""></p>
<p>全局变量就是先在所有函数前定义，这种变量可以在所有函数中使用，例如这个变量的值发生改变成为另一个值时，假设是12，其他函数此时运用这个变量的值就是12。<code>全局变量有利有弊，可以自己学习一下</code>。</p>
<h4 id="1-7-8-双模式函数封装">1.7.8 双模式函数封装</h4>
<p>以上我们学会了两种按键模式<code>(不能连按模式和连按模式)</code>的代码，我们现在决定将这两种模式封装成<code>一个函数</code>，然后通过参数选择是支持连按还是不支持连按。</p>
<p>考虑到，两种模式的选择，现在利用<code>两个</code>按键来实现按键模式的切换，K3负责用来给K4做<code>支持连按</code>还是<code>不支持连按</code>的选择。这里可<code>不是</code>说K3,K4各自负责一个模式。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/643526be0d2dde577782f4e3.png" alt=""></p>
<p>在我的开发板的原理图，在P2.3输出低电平的情况下，K1,K2,K3,K4就可以当独立按键。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/643527c40d2dde577784500c.png" alt=""></p>
<p>大家可以自己想一下如何实现这一功能，写写代码，然后参考第二章的按键部分。</p>
<h3 id="1-8-外部中断">1.8 外部中断</h3>
<h4 id="1-8-1-寄存器">1.8.1 寄存器</h4>
<h5 id="1-8-1-1-单片机的内部资源">1.8.1.1 单片机的内部资源</h5>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.imgdb.cn/item/64422b2d0d2dde57772a3884.png" alt=""></p>
<p>我们熟知的<code>P0,P1,P2,P3</code>，包括上图中的TCON以及<code>#inlcude &lt;reg52.h&gt;</code>头文件中的<code>IE、SCON</code>等等都叫做寄存器。这些寄存器都可以粗浅的认为就是一个8位的变量，其中像P0^0这个最低位就是控制单片机的外部IO端口输出高低电平。而像<code>TOCN^1</code>(IEO)这些有什么作用呢？这就涉及到单片机的内部资源了。</p>
<h5 id="1-8-1-2-ie0的作用">1.8.1.2 IE0的作用</h5>
<p>我们先看一下原理图中的P3端口</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.imgdb.cn/item/644230620d2dde5777369732.png" alt=""></p>
<p><code>P3</code>寄存器中的每一位都在<code>#include &lt;reg52.h&gt;</code>头文件中声明好了。我们拿P3^2来说，如果这个IO端口被外部电路拉低，那么TCON的第一位(也就是<code>TCON^1</code>)就会被置1，在程序中<code>IE0</code>变为1。</p>
<p>我们来验证一下，我们用一根杜邦线的一头插入<code>P3.2</code>的引脚，然后另一头插入<code>GND</code>(拉低)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.imgdb.cn/item/644232560d2dde577739cbe6.png" alt=""></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"function.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//请提前将P3.2和GND相连</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	LED_Init(); <span class="comment">//初始化LED硬件模块</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">		<span class="keyword">if</span>(IE0 == <span class="number">0</span>) {</span><br><span class="line">			LED2 = !LED2;</span><br><span class="line">			delay_ms(<span class="number">50</span>);</span><br><span class="line">			LED2 = <span class="number">1</span>; <span class="comment">//如果IE0不等于0了，要保证熄灭LED2;</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(IE0 == <span class="number">1</span>) {</span><br><span class="line">			LED9 = !LED9;</span><br><span class="line">			delay_ms(<span class="number">50</span>);</span><br><span class="line">			LED9 = <span class="number">1</span>; <span class="comment">//如果LED0不等于1了，要保证熄灭LED9</span></span><br><span class="line">		}</span><br><span class="line">		delay_ms(<span class="number">50</span>); <span class="comment">//总要执行`if(IE0 == 0)`或者`if(IE0 == 1)`，这个延时要保证其中一盏灯灭的时间，保证总有灯闪烁的现象</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们看到<code>LED9</code>在不停的闪烁，此时拔了连接GND那头的杜邦线看到LED9熄灭，LED2不停的闪烁，连着插拔几次观察得到<code>当P3.2遇到低电平的时候IE0会一直等于1，只有当P3.2为高电平时IE0才会等于0</code>。</p>
<h5 id="1-8-1-3-it0的作用">1.8.1.3 IT0的作用</h5>
<p>再看看<code>TCON^0</code>(也就是IT0)，我们把上面的代码中的<code>IE0</code>改为<code>IT0</code>的初始值是多少。经测试，<code>IT0</code>初始值为0。若是我们再主函数开头赋值给IT0为1，那么IE0只有当P3^2从高电平变成低电平(俗称下降沿)就会被1，即使P2^3后面变成高电平<code>IE0</code>也不会变成0，一直是1。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.imgdb.cn/item/6448c40a0d2dde57778a945f.png" alt=""></p>
<p>这时需要我们在程序里让IE0清零（俗称软件清零）才行。</p>
<p>我们把下面的代码下载进去</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;function.h&gt;</span> <span class="comment">//详见第六章第8讲</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{  </span><br><span class="line">    IT0 = <span class="number">1</span>;</span><br><span class="line">    LED_Init();   <span class="comment">//初始化LED硬件模块 </span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    { </span><br><span class="line">        <span class="keyword">if</span>(IE0==<span class="number">1</span>)<span class="comment">//只有当P3.2从高电平变成低电平这个瞬间（下降沿）IE0才会被置1，后面P3.2不管是一直保持高电平还是低电平，IE0被清0之后都不会再次被置1，只有P3.2再次产生下降沿才会被置1</span></span><br><span class="line">        {  </span><br><span class="line">            IE0=<span class="number">0</span>;</span><br><span class="line">            LED2=!LED2;  </span><br><span class="line">        }     </span><br><span class="line">        delay_ms(<span class="number">50</span>);</span><br><span class="line">    }   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>即使杜邦线一直都插着GND端口，也就是P3.2都保持着低电平，LED2也不会闪烁，只有不断拔插杜邦线，LED2才会有亮灭的跳变。</p>
<p>所以当IT0等于1时，P3.2遇到下降沿IE0就会被置1，我们软件把这个位清0之后，如果P3.2没有再次遇到下降沿，IE0都不会被置1。</p>
<h4 id="1-8-2-中断函数">1.8.2 中断函数</h4>
<p>根据上述，当赋值IT0为1时，P3.2遇到下降沿，IE0被置1，要想使IE0自动清零，需要引用中断函数。<code>中断函数</code>就是当它满足一定的条件时就会暂停主函数的执行内容，转而去执行中断函数。</p>
<h5 id="1-8-2-1-中断函数的书写">1.8.2.1 中断函数的书写</h5>
<p>中断函数与其他我们封装过的子函数的写法不同，有个区分标志<code>interrupt</code>。至于后面为什么会有个数字0，我们后面会了解到。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">()</span> interrupt 0 {</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>以上函数名是可以随意取的，只要不跟以前封装定义好的函数名冲突就行。这里我们取<code>EXTI0_IRQHandler</code>作为函数名是模仿STN32单片机的写法。</p>
<h5 id="1-8-2-2-ex0和ea">1.8.2.2 EX0和EA</h5>
<p>想要进入中断函数，必须满足它的一些前提条件。这里<code>EX0(IE^0)</code>和<code>EA(IE^7)</code>要初始化赋值给<code>1</code>才能进入中断程序取执行任务。</p>
<p><code>EA</code>叫做中断总开关，<code>EX0</code>是针对<code>P3.2</code>的外部中断的开关，也就是说想要进入中断子程序必须满足两个开关都要闭合。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.imgdb.cn/item/64491dcc0d2dde57772691e2.png" alt=""></p>
<h4 id="1-8-3-进一步理解中断函数">1.8.3 进一步理解中断函数</h4>
<h5 id="1-8-3-1-外部中断1">1.8.3.1 外部中断1</h5>
<p>以上我们注意到我们使用标志<code>interrupt 0</code>，这表明我们使用的是外部中断0（P3.2的功能）。还有一个外部中断1（P3.3的功能），想要使用外部中断1，代码中需要把<code>EX0</code>改为<code>EX1</code>，<code>IT0</code>改为<code>IT1</code>。interrupt后面的0要改为2，函数名我们改为<code>EXTI1_IRQHandler()</code></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"function.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	IT1 = <span class="number">1</span>; <span class="comment">//下降沿触发模式</span></span><br><span class="line">	EA = <span class="number">1</span>;</span><br><span class="line">	EX1 = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	LED_Init(); <span class="comment">//初始化LED硬件电路</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXIT1_IRQHandler</span><span class="params">()</span> interrupt 2 {</span><br><span class="line">	LED2 = !LED2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>为什么是<code>interrupt 2</code>呢？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.imgdb.cn/item/644928060d2dde577739c4d4.png" alt=""></p>
<h5 id="1-8-3-2-按键触发中断">1.8.3.2 按键触发中断</h5>
<p>每次要把P3.2和P3.3外部拉低或释放，都需要拔插杜邦线，这样太麻烦，我们可以用按键来取代这些拔插动作，按键按下不放就相当于一直拉低，跟杜邦线一直插着GND一个效果，松开按键就跟杜邦线没插GND一样。<code>把杜邦线这样接，让P3.3和P2.3一起相连，K4的按键动作可以使P2.3和P3.3同步电平。</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.imgdb.cn/item/64492a2f0d2dde57773fdc6b.png" alt=""></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;function.h&gt;</span><span class="comment">//详见第六章第8讲</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{  </span><br><span class="line">    IT1 = <span class="number">1</span>;   <span class="comment">//下降沿触发模式</span></span><br><span class="line">    EX1 = <span class="number">1</span>;</span><br><span class="line">    EA  = <span class="number">1</span>;</span><br><span class="line">   </span><br><span class="line">    LED_Init();<span class="comment">//初始化LED硬件模块 </span></span><br><span class="line">    KEY_Init();<span class="comment">//初始化按键功能模块</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI1_IRQHandler</span><span class="params">()</span> interrupt 2</span><br><span class="line">{</span><br><span class="line">    LED2=!LED2; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="1-8-3-3-按键触发中断消抖">1.8.3.3 按键触发中断消抖</h5>
<p>以上按键似乎没能很灵敏的按一下松手LED2就跳变一次亮或灭的效果，那是因为我们没有延时消抖，一个按键动作就存在好几个下降沿了，导致中断函数被执行了几遍。</p>
<p>在中断函数中加延时就可以消除这种失灵现象了，不过在以后编程里不能在中断函数里使用延时，这样会使程序的执行效率大打折扣，我们本次只是作为测试代码才在中断函数里用延时。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;function.h&gt;</span><span class="comment">//详见第六章第8讲</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{  </span><br><span class="line">    IT1 = <span class="number">1</span>;   <span class="comment">//下降沿触发模式</span></span><br><span class="line">    EX1 = <span class="number">1</span>;</span><br><span class="line">    EA  = <span class="number">1</span>;</span><br><span class="line">   </span><br><span class="line">    LED_Init();<span class="comment">//初始化LED硬件模块 </span></span><br><span class="line">    KEY_Init();<span class="comment">//初始化按键功能模块</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="comment">//请把P3.3和P2.3用杜邦线连接起来</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI1_IRQHandler</span><span class="params">()</span> interrupt 2</span><br><span class="line">{</span><br><span class="line">    delay_ms(<span class="number">50</span>);<span class="comment">//去抖动</span></span><br><span class="line">    <span class="keyword">if</span>(INT1==<span class="number">0</span>)  <span class="comment">//P3.3是否还处于低电平的稳定接触状态，INT1已在“#include &lt;reg52.h&gt;”中定义好了</span></span><br><span class="line">    {</span><br><span class="line">        LED2=!LED2; </span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1-9-定时器">1.9 定时器</h3>
<p>以上对<code>中断</code>知识的了解，外部中断这种需要<code>物理动作</code>才能触发中断函数执行，但很多情况下我们需要的是中断函数在适当时刻可以自动的去执行，所以就需要<code>定时器</code>来辅助了。</p>
<p>定时器是单片机内部的一个硬件资源。</p>
<p>用生活常见现象举例：定时器相当于一个闹钟，我们调5分钟后闹钟就响，在这5分钟里我们想做什么就做什么，相当于我们自己是主函数里的任务，想运行什么任务就运行什么，也不用去理会闹钟还剩多少时间就响，我们只是一直做我们想做的事就行。</p>
<p>之后闹钟响了，这时我们不能再任性去做主函数的事了，得赶紧把中断函数里的事办完先，也就是要去执行中断函数了，主函数的事要暂停不做先，执行完中断函数之后继续回到主函数做我们的事。可是又过了5分钟闹钟又响了，没办法，我们又要放停自己的事去执行中断函数了，当然闹钟是可以关闭的，这就相当于是把中断函数的触发开关给断开了。</p>
<h4 id="1-9-1-溢出">1.9.1 溢出</h4>
<p>我们知道秒表计时到59秒的时候，再过1秒就变成了00。同理，当我们的unsigned char类型的变量的数值为<code>255</code>时，再加1就变为0了, unsigned int的变量如果此时的值为<code>65535</code>，后面再加1也同样成为0，这些都叫<code>溢出</code>。</p>
<p>再举一个例子来理解定时器溢出概念，中学时我们做过一些化学实验，其中有一种容器叫做试管，如果试管是空的，我们用一个导管往试管里加水，导管的水流流速是均匀不变的，试管里的水要想溢出，需要的是x个单位的时间，如果我们想把距离溢出的时间缩短为一半，那我们提前把试管里的水装满到一半，这样就可以改变了溢出时间。</p>
<p>通过这个例子我们就可以明白，<code>要想确定好定时器溢出产生中断的间隔时间</code>，我们就要往这个“试管”提前装好合适的水量。</p>
<h4 id="1-9-2-两种定时模式">1.9.2 两种定时模式</h4>
<p><code>试管</code>有65535个刻度的型号，也有255个刻度的型号，不过我们的导管水流流速是永远不变的。</p>
<p>如果我们用的是大试管（65535个刻度），那么溢出时间我们可以控制的长一些，也就是定时时间可以多一点。我们要是想定时36个单位刻度的时间，那就先往试管装好65500个刻度的水量先，这样等到水位到达65535那个刻度时，再加一个刻度就溢出了，这时溢出的就是36个单位刻度的时间。<code>试管</code>每次水溢出，试管里的水就会消失不见（归0），如果我们还想定时36个单位刻度的时间，还需要重新把65500个刻度的水量再次装好给<code>试管</code>。</p>
<p>如果我们用的是小试管（255个刻度），虽然它的定时时间远远没有大试管的定时时间长，但是只要我们第一次装好水量，每次它溢出之后，不会马上归0，而是试管里的水<code>重新归为</code>我们第一次那个时候装好的水量，所以<code>只要在第一次确定了水量，也就确定了以后的所有定时时长</code>。</p>
<p>这种叫做<code>试管</code>的东西就是我们单片机内部的另一个寄存器，51单片机有两个定时器，分别叫做定时器0和定时器1，跟外部中断有 0和1的两个硬件资源一样。这里我们先拿定时器0来讲解，定时器1大体原理都一样。</p>
<h4 id="1-9-3-定时器模式的选择">1.9.3 定时器模式的选择</h4>
<p>我们想选用哪个<code>试管</code>作为定时时长，首先需要初始化寄存器TMOD相对应的位的值。先看到下面这张图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.imgdb.cn/item/6453a8320d2dde5777f75280.png" alt=""></p>
<p>可以看到圈出来的左右两个紫色框，4-7位是控制定时器1的，0-3位是控制定时器0的。我们要确定选择的定时器模式们主要看<code>M1</code>和<code>M0</code>两个参数。</p>
<ol>
<li>如果<code>M1=0，M0=1</code>，选用的是<code>大试管定时模式</code>。</li>
<li>如果<code>M1=1，M1=0</code>，选用的是<code>小试管定时模式</code>。</li>
</ol>
<p>因为我们暂时没有使用到定时器1，所以4-7位(俗称高四位)可以全置为<code>0</code>.2-3位用不到，也是置为0，我们先选择大使馆作为定时模式，所以TMOD这个寄存器初始化为<code>TOMD=0x01;</code>。这里注意，因为<code>M1和M0</code>在<code>#include&lt;reg52.h&gt;</code>头文件中并没有<code>sbit M0=TMOD^0;</code>的内容，所以我们初始化只能是<code>TMOD=0x01</code>，一次性操作8个位，而在程序里书写<code>M1=0</code>或<code>M0=1</code>是错位的。</p>
<p>之后我们把使用“大试管”称为定时器的工作模式1，使用“小试管”称为定时器的工作模式2。</p>
<h4 id="1-9-4-定时时长的做法">1.9.4 定时时长的做法</h4>
<p>定时器0有两个寄存器分别是<code>TH0</code>和<code>TL0</code>，大家再次粗浅的把TH0和TL0认为是两个8位的变量吧。因为我们用的是定时器的工作模式1，这两个8位的变量相当于组合成了16位的变量，TH0是高8位（H:High），TL0是低8位（L:Low）。假如此时再过一个刻度的时间就溢出，那么此时会有<code>TH0等于255，TL0等于255</code>，因为二进制的1111111111111111等于十进制的65535。65535再加1就溢出嘛。因为我们用的是11.0592M的晶振，所以每增加1花费的时间是（12/11059200）秒。</p>
<p>如果我们用定时器的工作模式1定时20毫秒后触发中断该怎么实现呢？首先我们先往这两个寄存器填充数值</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.imgdb.cn/item/6453ac430d2dde5777ff2c9d.png" alt=""></p>
<p>可以看到，两个“8位的变量”从高到低合起来成为16位的变量，至于定时20ms为什么是这样填充，我们先用反推法给大家演示。</p>
<p>十六进制的0XB800换算成十进制的值为47104，于是定时的时长为（65536-47104）=18432个刻度的单位时间。18432*（12/11059200）=0.02秒=20毫秒。</p>
<p>我们再正推，要定时50毫秒怎么给TH0和TL0赋初值？设距离溢出还剩x个刻度，x*（12/11059200）=0.05，解得x=46080。所以需要提前装好65536-46080=19456个刻度的水量。也就是填充给TH0和TL0合成的<code>16位的变量</code>的值就是19456。19456换算成<code>十六进制</code>为0x4C00。所以要定时50毫秒，那么<code>TH0=0x4C;、“TL0=0x00;</code>。</p>
<h4 id="1-9-5-定时器简单运用">1.9.5 定时器简单运用</h4>
<p>·<code>注</code>：我们知道TH0和TL0合成的“16位的变量”的初值最小要为0，不能是负数，所以我们要满足：65536-( x/(12/11059200) )&gt;=0。解得x&lt;= 0.071111秒=71.111毫秒。也就是用定时器的工作模式1最长的定时时间为71毫秒左右而已。</p>
<p>下面我们来学习定时器的简单运用，这方便我们理解相关的理论知识。</p>
<ol>
<li>首先定时器也是有开关的，这个相当于我们的导管是否打开让水流进“试管”里。因为我们用的是定时器0，TCON^4这个位就是控制定时器0是否打开或关闭，所以<code>TR0=1;</code>就是打开了定时器开始计时，<code>TR0=0;</code>是关闭了定时器计时功能。只要打开了定时器，TH0和TL0合成的“16位的变量”就会每过(12/11059200)秒就自加1，直到定时器溢出。</li>
<li>我们的定时器0一旦溢出，TCON^5就会被置1<code>（TF0==1）</code>,如果我们不使用中断函数也是可以在主函数里等待判断“if(TF0==1)”。TF0跟外部中断0的IE0一样，被置1了需要软件清零。</li>
</ol>
<p>用定时器0来实现间隔50ms的流水灯实验</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"function.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    u8 i = <span class="number">0</span>;</span><br><span class="line">    LED_Init(); <span class="comment">//初始化LED硬件模块</span></span><br><span class="line">    TMOD = <span class="number">0x01</span>; <span class="comment">//设置定时器0位工作模式1</span></span><br><span class="line">    TH0 = <span class="number">0x4C</span>; <span class="comment">//色湖之定时时间位50ms</span></span><br><span class="line">    TL0 = <span class="number">0x00</span>;</span><br><span class="line">    TR0 = <span class="number">1</span>; <span class="comment">//启动定时器0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">if</span>(TF0 == <span class="number">1</span>) { <span class="comment">//判断定时器0是否溢出，每隔50ms就可以进入一次这个if语句内部</span></span><br><span class="line">            TF0 = <span class="number">0</span>; <span class="comment">//软件清零，定时器0溢出后，清0溢出标志</span></span><br><span class="line">            TH0 = <span class="number">0x4C</span>; <span class="comment">//重新赋值，保证下次溢出时间间隔还是50ms</span></span><br><span class="line">            TL0 = <span class="number">0x00</span>;</span><br><span class="line">            P0 = ~(<span class="number">0x01</span> &lt;&lt; i); <span class="comment">//每盏灯的点亮时间都保持者50ms</span></span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">8</span>) i = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>用定时器1来实现间隔50ms的流水灯实验</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;function.h&gt;</span><span class="comment">//详见第六章第8讲</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{   </span><br><span class="line">    u8 i=<span class="number">0</span>;</span><br><span class="line">    LED_Init();   <span class="comment">//初始化LED硬件模块 </span></span><br><span class="line">    TMOD = <span class="number">0x10</span>;  <span class="comment">//设置定时器1为工作模式1</span></span><br><span class="line">    TH1  = <span class="number">0x4C</span>;  <span class="comment">//设置定时时间为50ms</span></span><br><span class="line">    TL1  = <span class="number">0x00</span>;</span><br><span class="line">    TR1  = <span class="number">1</span>;     <span class="comment">//启动定时器1</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (TF1 == <span class="number">1</span>)     <span class="comment">//判断定时器1是否溢出，每隔50ms就可以进入一次这个if语句</span></span><br><span class="line">        {</span><br><span class="line">            TF1 = <span class="number">0</span>;      <span class="comment">//定时器1溢出后，清0溢出标志</span></span><br><span class="line">            TH1 = <span class="number">0x4C</span>;   <span class="comment">//重新赋初值，保证下次溢出间隔时间还是50ms</span></span><br><span class="line">            TL1 = <span class="number">0x00</span>;</span><br><span class="line">            P0=~(<span class="number">0x01</span>&lt;&lt;i);<span class="comment">//每盏灯的点亮时间都保持着50ms</span></span><br><span class="line">            i++;</span><br><span class="line">        }   </span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">8</span>)i=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-9-6-定时器工作模式2">1.9.6 定时器工作模式2</h4>
<p>这里我们讲解一下<code>定时器0</code>的工作模式2，也就是使用<code>小试管</code>的方式，TMOD的初始化就为<code>TMOD=0x02;</code>。我们知道工作模式2的最长溢出时间仅为256*(12/11059200)=0.000277秒=277微秒。</p>
<p>我们想实现间隔51ms的流水灯实验该怎么做？我们需要利用循环，首先我们定义一个变量cnt用来记录每次的溢出次数，然后我们的定时时间为51微秒（因为最大定时只有278微秒），cnt记录的值等于1000的时候，证明时间已经过去了51ms，于是再去执行流水灯的任务。</p>
<p>我们已经知道工作模式2是不需要在溢出之后再填充初始值的，比如我们定时的时间为51微秒，那么计算出“距离溢出的刻度”就为47（实际计算出的是47.0016，所以定时为51微秒误差就不大）。所以给TL0赋初值为256-47=209=0xD1。那么TH0也是给初值为0xD1，这是保证每次TL0溢出之后新的初始值是等于TH0的值的，所以定时器工作模式2又叫做8位<code>自动重装载模式</code>。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"function.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    u8 i = <span class="number">0</span>;</span><br><span class="line">    u16 cnt = <span class="number">0</span>;</span><br><span class="line">    LED_Init(); <span class="comment">//初始化LED硬件模块</span></span><br><span class="line">    TMOD = <span class="number">0x02</span>; <span class="comment">//设置定时器0为工作模式2</span></span><br><span class="line">    TH0 = <span class="number">0xD1</span>; <span class="comment">// 定时51us</span></span><br><span class="line">    TL0 = <span class="number">0xD1</span>;</span><br><span class="line">    TR0 = <span class="number">1</span>; <span class="comment">// 启动定时器0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">if</span>(TF0 == <span class="number">1</span>) { <span class="comment">//每隔51us,cnt加1</span></span><br><span class="line">            TF0 = <span class="number">0</span>; <span class="comment">//定时器溢出TF0软件清零</span></span><br><span class="line">            cnt ++; <span class="comment">//记录溢出次数</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= <span class="number">1000</span>) { <span class="comment">// 溢出次数为1000时表明过去了51ms</span></span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            P0 = ~(<span class="number">0X01</span> &lt;&lt; i); <span class="comment">// 执行流水灯，保证每个流水灯亮51ms</span></span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= <span class="number">8</span>) i = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-9-7-定时器中断函数的使用">1.9.7 定时器中断函数的使用</h4>
<p>定时器和掩饰其的概念不同，延时函数需要占用CPU的使用权，正在延时的时候其他任务没有CPU使用权就会拖慢执行效率。而定时器是不需要占用CPU的使用权，它是独立运行的，所以上面的代码的实现原理就是每隔51微妙，有个变量会自动加1，过了1000个51微妙的时候LED的状态才会发生改变，可以说CPU在51ms的时间里基本什么都没有做，只是在51微妙到了的时候做了<code>cnt++;</code>的工作。</p>
<p>与外部中断一样，定时器中断也有中断函数，同理，程序去执行中断函数就会把TF0的中断标志位自动清0，所以只要我们用了定时器中断函数，那么TF0就可以不用再出现在程序书写中了。</p>
<p>外部中断</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.imgdb.cn/item/6454b5a90d2dde57771cdff2.png" alt=""></p>
<p>定时器0的中断函数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.imgdb.cn/item/6454b6dd0d2dde57771e27c4.png" alt=""></p>
<p>interrupt”后面的数字为什么是1?</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.imgdb.cn/item/6454b7420d2dde57771e8daf.png" alt=""></p>
<ol>
<li>这些编号是为了区分哪些硬件资源的相关中断函数，如果我们同时使用两个定时器，那么只能用“interrupt 1”和“interrupt 3”来区分谁是谁的中断函数了。</li>
<li>使用“TIM0_IRQHandler”作为函数名也是模仿STM32定时器中断函数名的写法。</li>
<li>如果我们使用的是工作模式1，每次触发中断函数的执行内容首先就是再次给TH0和TL0赋初值保证下次的定时时间还是一样。这里我们使用中断函数的执行方式来实现30ms的间隔流水灯，算出TH0和TL0合成的“16位的变量”要填充的值为37888=0x9400。</li>
<li>在中断函数里也是可以定义局部变量的，当然如果这个变量是用来辅助流水灯的，那么肯定是要定义成静态变量的。</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"function.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    LED_Init(); <span class="comment">//初始化LED硬件模块</span></span><br><span class="line">    EA = <span class="number">1</span>; <span class="comment">//打开总中断开关</span></span><br><span class="line">    TMOD = <span class="number">0x01</span>; <span class="comment">//设置定时器0为工作模式1</span></span><br><span class="line">    TH0 = <span class="number">0x94</span>; <span class="comment">// 设置定时时间为30ms</span></span><br><span class="line">    ET0 = <span class="number">1</span>; <span class="comment">//打开定时器0中断的开关</span></span><br><span class="line">    TR0 = <span class="number">1</span>; <span class="comment">//启动定时器0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM0_IRQHandler</span><span class="params">()</span> interrupt 1 {</span><br><span class="line">    <span class="type">static</span> u8 i;</span><br><span class="line">    TH0 = <span class="number">0x94</span>; <span class="comment">//重新设定时间为30ms</span></span><br><span class="line">    TL0 = <span class="number">0x00</span>;</span><br><span class="line">    </span><br><span class="line">    P0 = ~(<span class="number">0x80</span> &gt;&gt; i); <span class="comment">//流水灯向左移动</span></span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= <span class="number">8</span>) i = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>觉得30ms的流速太快，想改为300ms的话，修改一下中断函数即可</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"function.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	LED_Init();</span><br><span class="line">	EA = <span class="number">1</span>;</span><br><span class="line">	TMOD = <span class="number">0x01</span>;</span><br><span class="line">	TH0 = <span class="number">0x94</span>;</span><br><span class="line">	TL1 = <span class="number">0x00</span>;</span><br><span class="line">	ET0 = <span class="number">1</span>;</span><br><span class="line">	TR0 = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//通过重复10次30ms实现定时300ms</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM0_IRQHandler</span><span class="params">()</span> interrupt 1 {</span><br><span class="line">	<span class="type">static</span> u8 i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">static</span> u8 cnt = <span class="number">0</span>;</span><br><span class="line">	TH0 = <span class="number">0x94</span>;</span><br><span class="line">	TL0 = <span class="number">0x00</span>;</span><br><span class="line">	cnt++;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (cnt &gt;= <span class="number">10</span>) {</span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		P0 = ~(<span class="number">0x80</span> &gt;&gt; i);</span><br><span class="line">		i++;</span><br><span class="line">		<span class="keyword">if</span>(i &gt;= <span class="number">8</span>) i = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-9-8-定时器初始化优化">1.9.8 定时器初始化优化</h4>
<p>之前我们对定时器进行初始化（即填充初始值）我们写<code>TH0=0x94;TL0=0x00;</code>。我们这样写是因为我们提前计算了需要装填的数字，显然如果没有注释我们很难指导这是要定时多长时间，所以为了增强<code>程序的可读性</code>，我们需要优化定时器初始化的写法。</p>
<p>要优化初始化的写法，首先要明白在程序书写过程中，赋值给寄存器的值可以书写成16进制的数也可以是十进制的数。<code>TH0</code>填充的是高八位，<code>TL0</code>填充的是低8位，那么如果这个16位的变量的十进制值是258，二进制的值就是<code>0000000100000010</code>。所以高八位的值位1<code>(258/256=1)</code>，低八位的值是2<code>(258%256=2)</code>。我们也可以认为<code>258/256=1</code>是0x0102(258)右移了8位等于0x0001,简化书写就是0x01。而<code>58%256=2</code>是0x0102(258)舍去了高8位等于0x0002，简化书写就是0x02。</p>
<p>下面是图解，以一个16位的变量的十进制值是<code>47104</code>，二进制的值是<code>1011100000000000</code>，所以高八位的值是184<code>(47104/256=184)</code>，第八位的值是0<code>(47104%256=0)</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.imgdb.cn/item/6454ff120d2dde5777861523.png" alt=""></p>
<p>综上所述我们要定时20ms的话，给TH0和TL0赋值方式可以为<code>TH0=184;TL0=0;</code>。</p>
<p>我们通过对<code>TH0和TL0</code>传递十进制数字对初始化过程进行了优化，但这仍需要我们自己进行计算。假定定时的时间为<code>1ms</code>。算出要填的16位的变量为<code>64614=0xFC66</code>按照之前的写法就是<code>TH0=0xFC/252;TL0=0x66/102</code>。而我们也可以像下面这样写以打掉相同的效果。</p>
<ol>
<li>TH0=( 65536-( 0.001/(12/11059200) ) )/256</li>
<li>TL0=( 65536-( 0.001/(12/11059200) ) )%256</li>
</ol>
<p>因为( 65536-( 0.001/(12/11059200) ) )/256 = 252；( 65536-( 0.001/(12/11059200) ) )%256 = 102。有了这个思路，我们就可以将初始化赋值过程的写法改写为一串数字公式即可。</p>
<p>比如我们定时的最小单位时间为1微秒，那么定时50000微秒（50毫秒）就可以这样写来给TH0和TL0赋初值</p>
<ol>
<li>
<p>TH0=( 65536-( (50000/1000000)/(12/11059200) )/256;</p>
</li>
<li>
<p>TL0=( 65536-( (50000/1000000)/(12/11059200) )%256;</p>
</li>
</ol>
<p>这里的(50000/1000000)代表定时的是0.05秒，也就是50毫秒。</p>
<p>如果要定时其他毫秒数, 数字公式中的其他数字我们不需要修改，只需要把50000改为想定时的时间就可以了，计算过程交给单片机算出来，我们也就不需要自己用计算器把最终值算出来再赋给TH0和TL0这么麻烦了。</p>
<p>我们再化简上式就是</p>
<ol>
<li>
<p>TH0=( 65536-( (50000*110592)/120000) )/256;</p>
</li>
<li>
<p>TH0=( 65536-( (50000*110592)/120000) )%256;</p>
</li>
</ol>
<h4 id="1-9-9-初始化需要注意的点">1.9.9 初始化需要注意的点</h4>
<p>按上一讲说的书写方式，实现定时50ms间隔的流水灯。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"function.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    LED_Init(); <span class="comment">//初始化LED硬件电路</span></span><br><span class="line">    EA = <span class="number">1</span>; <span class="comment">//打开中断总开关</span></span><br><span class="line">    TMOD = <span class="number">0x01</span>; <span class="comment">//设置定时器0为工作模式1</span></span><br><span class="line">    TH0 = (<span class="number">65536</span> - ( (<span class="number">50000</span> * <span class="number">110592</span>) / <span class="number">120000</span> )) / <span class="number">256</span>; <span class="comment">//设置定时时间为50ms</span></span><br><span class="line">    TL0 = (<span class="number">65536</span> - ( (<span class="number">50000</span> * <span class="number">110592</span>) / <span class="number">120000</span> )) % <span class="number">256</span>; </span><br><span class="line">    ET0 = <span class="number">1</span>; <span class="comment">//启动定时器0中断的开关</span></span><br><span class="line">    TR0 = <span class="number">1</span>; <span class="comment">//启动定时器0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM0_IRQHanler</span><span class="params">()</span> interrupt 1 {</span><br><span class="line">    <span class="type">static</span> u8 i;</span><br><span class="line">    TH0 = (<span class="number">65536</span> - ( (<span class="number">50000</span> * <span class="number">110592</span>) / <span class="number">120000</span> )) / <span class="number">256</span>; <span class="comment">//重新初始化填充</span></span><br><span class="line">    TL0 = (<span class="number">65536</span> - ( (<span class="number">50000</span> * <span class="number">110592</span>) / <span class="number">120000</span> )) % <span class="number">256</span>;</span><br><span class="line">    P0 = ~(<span class="number">0x01</span> &lt;&lt; i);</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= <span class="number">8</span>) i = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>下载进开发板发现根本不是间隔50ms！靠！！！！！！！！这是为什么呢？</p>
<p>首先我们要知道，51单片机能存储最大的一个整型数的大小只有4个字节，也就是最多能记忆这个数到4294967296（2的32次方），而在</p>
<p>( 65536-( (50000*110592)/120000 )中明显不能把(50000*110592)给临时存储，因为这个等式的得数已经大过2的32次方。所以我们的定时器才会无法实现准确的50ms定时。如果我们对编程没有一定的积累是很难察觉出这个隐形漏洞的。</p>
<p>解决办法就是，我们的定时最小单位只能是<code>10微秒</code>，也就是定时的时间必须是10微秒的整数倍。书写如下TH0=( 65536-(5000*110592)/12000 ) )/256;把之前的<code>50000</code>和<code>120000</code>都去掉一个零，这样就可以准确的定时50ms了，因为“(5000)*110592)”没有超过2的32次方，读者自行修改本讲提供的代码中的4处之后下载进开发板观察现象是不是又实现50ms的间隔流水了。</p>
<p>但是这样好像不是很通用，我们需要在此优化初始化的写法</p>
<p>上述程序中的<code>500</code>0意为定时的是<code>50ms</code>，也就是<code>5000*10</code>微秒，但我们希望潜意识里假如要定时200微秒，如果写成20我们的思维还要绕个弯再把20默默乘以10才领悟出这是定时200微秒。倒不如这样，我们看到关键的数字是多少那就是要定时多少微秒。</p>
<p>比如看到关键数字为50000时就知道定时的是50000微秒。所以我们这样改写：TH0=( 65536-( (50000/10)*110592)/12000 )/256;这样既保证了“(50000/10)*110592”没有超过2的32次方，也使“50000”更直观的让我们知道要定时的是50000微秒。但是大家要记住，<code>关键数字必须是10的整数倍，如果想定时个208微秒，“(208/10)”还是等于20，所以定时时间还是200微秒</code>。</p>
<h4 id="1-9-10-代码参考">1.9.10 代码参考</h4>
<p>我们分析如下的代码</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ConfigTimer0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tmp;              <span class="comment">//临时变量</span></span><br><span class="line">     </span><br><span class="line">    tmp = <span class="number">11059200</span> / <span class="number">12</span>;            <span class="comment">//定时器计数频率</span></span><br><span class="line">    tmp = (tmp * ms) / <span class="number">1000</span>;        <span class="comment">//计算所需的计数值</span></span><br><span class="line">    tmp = <span class="number">65536</span> - tmp;              <span class="comment">//计算定时器重载值</span></span><br><span class="line">    tmp = tmp + <span class="number">13</span>;                 <span class="comment">//补偿中断响应延时造成的误差</span></span><br><span class="line">    T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(tmp&gt;&gt;<span class="number">8</span>); <span class="comment">//定时器重载值拆分为高低字节</span></span><br><span class="line">    T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)tmp;</span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>;                   <span class="comment">//清零T0的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>;                   <span class="comment">//配置T0为模式1</span></span><br><span class="line">    TH0 = T0RH;                     <span class="comment">//加载T0重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    ET0 = <span class="number">1</span>;                        <span class="comment">//使能T0中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;                        <span class="comment">//启动T0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第一句：<code>tmp = 11059200 / 12; </code>。定时器的寄存器计数，每加1计数就是经过（12/11059200）秒。那么计数了11059200次就是经过12秒了。经过1秒计数就是（11059200/12）= 921600。这样我们就明白了第一条语句的意思。</p>
<p>第二句：<code>tmp = (tmp * ms) / 1000; </code>我们想定时1ms，需要的计数就是（921600/1000）=921.6，需要定时<code>xms</code>就是需要计数<code>921.6x</code>。例如：如果我们想定时5ms，那么需要的计数值就是921.6*5=4608。</p>
<p>定时器初始化：TH0=(65536-4608)/256，TL0=(65536-4608)%256。当然也可以这样表达，两种书写方式的功能作用都一样：TH0= (unsigned char)(65536-4608)&gt;&gt;8；TL0= (unsigned char)(65536-4608)。这里先不考虑<code>中断响应延时造成的误差</code>。T0RH，T0RL是两个全局变量，为的是在中断函数中可以重新赋初值给寄存器TH0和TL0。</p>
<p>解释<code>tmp + 13</code>：由于中断函数的执行有时需要消耗不同的时间，所以定时时间会有误差导致进入中断函数时会产生与设想时的时间不同，所以需要调整计数值，也就是上面代码中的tmp需要微调节成一个合适的数，上面是固定加了13这个数，但是有时需要灵活改变这个微调值，所以我们改为传入不同的参数来改变这个微调值。</p>
<p>基于微调我们改进以上代码，上述代码定时的最小单位为1ms，下一章由于我们要学舵机，需要定时的最小单位是<code>0.1ms</code>，所以我们的代码定时的最小单位必须是0.1ms，也就是100us。看到我们的代码</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM0_Init</span><span class="params">(u32 us,<span class="type">int</span> trim)</span><span class="comment">//trim:微调</span></span><br><span class="line">{</span><br><span class="line">    u32 tmp;                        <span class="comment">//临时变量</span></span><br><span class="line">      </span><br><span class="line">    tmp = <span class="number">11059200</span> / <span class="number">12</span>;            <span class="comment">//定时器计数频率</span></span><br><span class="line">    tmp = ( tmp * (us/<span class="number">100</span>) )/<span class="number">10000</span>; <span class="comment">//计算所需的计数值</span></span><br><span class="line">    tmp = <span class="number">65536</span> - tmp;              <span class="comment">//计算定时器重载值</span></span><br><span class="line">    tmp = tmp+trim;                 <span class="comment">//微调计数值使其定时更精确到我们想要的定时时间</span></span><br><span class="line">    T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(tmp&gt;&gt;<span class="number">8</span>); <span class="comment">//定时器重载值拆分为高低字节  </span></span><br><span class="line">    T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)tmp;</span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>; <span class="comment">//清0低四位 </span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>; <span class="comment">//设置定时器0为工作模式1   </span></span><br><span class="line">    TH0 = T0RH;   <span class="comment">//加载T0重载值   </span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    ET0 = <span class="number">1</span>;      <span class="comment">//闭合定时器0中断的开关        </span></span><br><span class="line">    TR0 = <span class="number">1</span>;      <span class="comment">//启动定时器0         </span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>要想定时2ms，传入的参数就是2000，我们的参数是us数，如果传入的是2000，第二条语句就是“(tmp*2)/1000”，与宋老师的代码原理一样。不过需要记住的是改代码<code>不能定时小于100us的时间，最低单位只能是100us</code>。</p>
<h4 id="1-9-11-微调定时精确时间">1.9.11 微调定时精确时间</h4>
<p>一般定时器中断函数里的内容最好是能够快速地去执行完，比如只执行几条简单的语句，这样与主函数配合才会使程序更加高效。前面，只使用定时器中断负责某个IO引脚间隔跳变或者使一个变量间隔自加1的简单语句。</p>
<p>现在要实现间隔50ms左右的时间让流水灯左右循环移动的同时，还需要无源蜂鸣器一直响，这样的功能，思路该怎么去实现？</p>
<p>首先我们知道无源蜂鸣器要想鸣叫的比较尖锐，那P1.6需要一个合适的脉冲信号，这个信号打算使P1.6高低电平保持的时间为<code>300微秒</code>不断循环。所以我们用定时器中断实现P1.6的电平间隔跳变，主函数里负责完成流水灯的任务即可。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.imgdb.cn/item/6455f8750d2dde5777a48cbc.png" alt=""></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;function.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">u8 T0RH, T0RL;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM0_Init</span><span class="params">(u32 us,<span class="type">int</span> trim)</span><span class="comment">//trim:微调</span></span><br><span class="line">{</span><br><span class="line">    u32 tmp;                       <span class="comment">//临时变量</span></span><br><span class="line">     </span><br><span class="line">    tmp = <span class="number">11059200</span> / <span class="number">12</span>;           <span class="comment">//定时器计数频率</span></span><br><span class="line">    tmp = ( tmp * (us/<span class="number">100</span>) )/<span class="number">10000</span>;<span class="comment">//计算所需的计数值</span></span><br><span class="line">    tmp = <span class="number">65536</span> - tmp;             <span class="comment">//计算定时器重载值</span></span><br><span class="line">    tmp = tmp+trim;                <span class="comment">//补偿中断响应延时造成的误差</span></span><br><span class="line">    T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(tmp&gt;&gt;<span class="number">8</span>);<span class="comment">//定时器重载值拆分为高低字节  </span></span><br><span class="line">    T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)tmp;</span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>; <span class="comment">//清0低四位 </span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>; <span class="comment">//设置定时器0为工作模式1   </span></span><br><span class="line">    TH0 = T0RH;   <span class="comment">//加载T0重载值   </span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    ET0 = <span class="number">1</span>;      <span class="comment">//闭合定时器0中断的开关        </span></span><br><span class="line">    TR0 = <span class="number">1</span>;      <span class="comment">//启动定时器0         </span></span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{  </span><br><span class="line">    u8 i,dir;</span><br><span class="line">    LED_Init();       <span class="comment">//初始化LED硬件模块</span></span><br><span class="line">    EA = <span class="number">1</span>;           <span class="comment">//闭合总中断开关</span></span><br><span class="line">    TIM0_Init(<span class="number">300</span>,<span class="number">0</span>); <span class="comment">//用定时器0定时300us,不微调</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">8</span>)dir=<span class="number">0</span>;<span class="comment">//向左移</span></span><br><span class="line">        <span class="keyword">if</span>(dir==<span class="number">0</span>)P0=~(<span class="number">0x01</span>&lt;&lt;i);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">8</span>)dir=<span class="number">1</span>;<span class="comment">//向右移 </span></span><br><span class="line">        <span class="keyword">if</span>(dir==<span class="number">1</span>)P0=~( <span class="number">0x80</span>&gt;&gt;(i<span class="number">-7</span>) );<span class="comment">//当i大于等于8之后，(i-7)其实也还是在1~7之间变化</span></span><br><span class="line"> </span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">15</span>)i=<span class="number">1</span>;<span class="comment">//让i一直在1~14之间变化</span></span><br><span class="line">        delay_ms(<span class="number">50</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM0_IRQHandler</span><span class="params">()</span> interrupt 1</span><br><span class="line">{</span><br><span class="line">    TH0 = T0RH;   <span class="comment">//重新加载重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    BEEP=!BEEP;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-9-12-封装函数">1.9.12 封装函数</h4>
<p>封装<code>timer.h</code>和<code>time.c</code></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//time.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"function.h"</span> <span class="comment">//详见第六章第8讲</span></span></span><br><span class="line">   </span><br><span class="line">u8 T0RH,T0RL,T1RH,T1RL;</span><br><span class="line">   </span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM0_Init</span><span class="params">(u32 us,<span class="type">int</span> trim)</span><span class="comment">//trim:微调</span></span><br><span class="line">{</span><br><span class="line">    u32 tmp;  <span class="comment">//临时变量</span></span><br><span class="line">     </span><br><span class="line">    tmp = <span class="number">11059200</span> / <span class="number">12</span>;            <span class="comment">//定时器计数频率</span></span><br><span class="line">    tmp = ( tmp * (us/<span class="number">100</span>) )/<span class="number">10000</span>; <span class="comment">//计算所需的计数值</span></span><br><span class="line">    tmp = <span class="number">65536</span> - tmp;              <span class="comment">//计算定时器重载值</span></span><br><span class="line">    tmp = tmp+trim;                 <span class="comment">//微调计数值使其定时更精确到我们想要的定时时间</span></span><br><span class="line">    T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(tmp&gt;&gt;<span class="number">8</span>); <span class="comment">//定时器重载值拆分为高低字节  </span></span><br><span class="line">    T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)tmp;</span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>; <span class="comment">//清0低四位 </span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>; <span class="comment">//设置定时器0为工作模式1   </span></span><br><span class="line">    TH0 = T0RH;   <span class="comment">//加载T0重载值   </span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    ET0 = <span class="number">1</span>;      <span class="comment">//闭合定时器0中断的开关        </span></span><br><span class="line">    TR0 = <span class="number">1</span>;      <span class="comment">//启动定时器0         </span></span><br><span class="line">}  </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM1_Init</span><span class="params">(u32 us,<span class="type">int</span> trim)</span><span class="comment">//trim:微调</span></span><br><span class="line">{</span><br><span class="line">    u32 tmp;  <span class="comment">//临时变量</span></span><br><span class="line">     </span><br><span class="line">    tmp = <span class="number">11059200</span> / <span class="number">12</span>;            <span class="comment">//定时器计数频率</span></span><br><span class="line">    tmp = ( tmp * (us/<span class="number">100</span>) )/<span class="number">10000</span>; <span class="comment">//计算所需的计数值</span></span><br><span class="line">    tmp = <span class="number">65536</span> - tmp;              <span class="comment">//计算定时器重载值</span></span><br><span class="line">    tmp = tmp+trim;                 <span class="comment">//微调计数值使其定时更精确到我们想要的定时时间</span></span><br><span class="line">    T1RH = (<span class="type">unsigned</span> <span class="type">char</span>)(tmp&gt;&gt;<span class="number">8</span>); <span class="comment">//定时器重载值拆分为高低字节    </span></span><br><span class="line">    T1RL = (<span class="type">unsigned</span> <span class="type">char</span>)tmp;</span><br><span class="line">    TMOD&amp;=<span class="number">0x0F</span>;<span class="comment">//清0高四位</span></span><br><span class="line">    TMOD|=<span class="number">0x10</span>;<span class="comment">//设置定时器1为工作模式1 </span></span><br><span class="line">    TH1 = T1RH;<span class="comment">//加载T1重载值     </span></span><br><span class="line">    TL1 = T1RL;</span><br><span class="line">    ET1 = <span class="number">1</span>;   <span class="comment">//闭合定时器1中断的开关        </span></span><br><span class="line">    TR1 = <span class="number">1</span>;   <span class="comment">//启动定时器1         </span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//timer.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TIMER_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TIMER_H__</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">extern</span> u8 T0RH,T0RL,T1RH,T1RL;</span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM0_Init</span><span class="params">(u32 us,<span class="type">int</span> trim)</span>;<span class="comment">//trim:微调 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM1_Init</span><span class="params">(u32 us,<span class="type">int</span> trim)</span>;<span class="comment">//trim:微调 </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-9-13-呼吸灯">1.9.13 呼吸灯</h4>
<p>呼吸灯的实现原理就是让小灯的IO端口在一段时间里PWM由大到小变化的占空比输出，接着又由小到大的占空比输出，小灯显示效果就是时亮时暗地交替闪烁。首先我们用定时器0定时0.1ms，全局变量pwm在其中断函数里执行简单的从0到99的循环自加，这样周期就是10ms。假如主函数里我们这样执行</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pwm&lt;<span class="number">90</span>)P0=<span class="number">0xFF</span>;</span><br><span class="line"><span class="keyword">else</span> P0=<span class="number">0x00</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>那么IO端口输出的一直是<code>周期为10ms</code>占空比为90%的波形，这样8盏小灯一直是处于较暗的显示状态不变，要想实现呼吸灯，就要不停改变PWM波形的占空比，所以我们使用定时器1来做间隔10ms地改变占空比，我们再定义一个全局变量highval，这个变量每隔10ms就会在定时器1中断函数中实现加1或者减1，加到99时又从99减回到0，减回到0又从0开始加到99的这样循环过程，大家回去研究左右往复循环流水灯的代码就会明白都是一样的思路。然后主函数这样执行</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pwm&lt;highval)P0=<span class="number">0xFF</span>;<span class="comment">//highval每隔10ms就会变化加1或者减1</span></span><br><span class="line"><span class="keyword">else</span> P0=<span class="number">0x00</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>效果图如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.imgdb.cn/item/645602160d2dde5777af389f.png" alt=""></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"function.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"timer.h"</span></span></span><br><span class="line"></span><br><span class="line">u8 pwm = <span class="number">0</span>; highval = <span class="number">99</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    LED_Init(); <span class="comment">//初始化LED硬件模块</span></span><br><span class="line">    EA = <span class="number">1</span>; <span class="comment">//闭合中断总开关</span></span><br><span class="line">    TIM0_Init(<span class="number">100</span>, <span class="number">9</span>); <span class="comment">//定时0.1ms, 9是微调是定时时间更精确</span></span><br><span class="line">    TIM1_Init(<span class="number">10000</span>, <span class="number">10</span>); <span class="comment">//定时10ms，10是微调使定时时间更精确</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">if</span>(pwm &lt; highval) P0 = <span class="number">0xFF</span>; <span class="comment">//highval每隔10ms就会变化加一或者减一</span></span><br><span class="line">        <span class="keyword">else</span> P0 = <span class="number">0x00</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM0_IRQHandler</span><span class="params">()</span> interrupt 1 {</span><br><span class="line">    TH0 = T0RH; <span class="comment">//重新初始化</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    pwm++;</span><br><span class="line">    <span class="keyword">if</span>(pwm &gt;= <span class="number">100</span>) pwm = <span class="number">0</span>; <span class="comment">//pwm在0-99之间间隔每隔0.1ms变化，周期就为10ms</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM1_IRQHandler</span><span class="params">()</span> interrupt 3 {</span><br><span class="line">    <span class="type">static</span> u8 dir;</span><br><span class="line">    TH1 = T1RH; <span class="comment">//重新初始化</span></span><br><span class="line">    TL1 = T1RL;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dir == <span class="number">1</span>) highval--; <span class="comment">//占空比逐渐减小，小灯逐渐变亮</span></span><br><span class="line">    <span class="keyword">if</span>(highval == <span class="number">0</span>) dir = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dir == <span class="number">0</span>) highval++; <span class="comment">//占空比逐渐增大，小灯逐渐变暗</span></span><br><span class="line">    <span class="keyword">if</span>(highval &gt;= <span class="number">99</span>) dir = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1-10-舵机">1.10 舵机</h3>
<h4 id="1-10-1-认识舵机">1.10.1 认识舵机</h4>
<p>舵机是单片机机械控制入门必学的模块，在一些机器人关节中也是采用舵机作为控制，学习并熟练掌握使用舵机是我们对单片机的进一步认识。所以我们不能一直局限地使用开发板进行学习，而是扩展一些电子模块来辅助我们更加深入了解单片机，请自信购买舵机。</p>
<p>小型的舵机与大型的舵机控制原理几乎大同小异，考虑到我没钱，我肯定选择小型舵机作为入门学习和简单实用。常见的小型舵机型号为<code>9g舵机</code>，外观如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.imgdb.cn/item/645612c60d2dde5777c5c075.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.imgdb.cn/item/645612eb0d2dde5777c60de0.png" alt=""></p>
<h4 id="1-10-2-舵机控制原理">1.10.2 舵机控制原理</h4>
<p>我们使用的舵机为9g尺寸，信号为<code>MG90S</code>。这种舵机的作用角度为<code>0°~180°</code>，也就是舵机桨可以任意在某个角度卡死不动，由于供电原因我们使用蛮力是很难掰动舵机桨的，只有舵机掉电之后舵机桨才会任意地为我们所扭动。</p>
<p>舵机有三根线，除了供电的两根电源线还有一根信号线，我们使用的是5v电压功率的舵机，所以其他电源线可以直接接到单片机的<code>+5v</code>和<code>GND</code>上，信号线的话就接到单片机的一个IO端口上，这个IO端口通过输出PWM控制舵机桨的角度在任意位置上固定停留。</p>
<p>这个PWM的周期为<code>20ms</code>，高电平的时间在<code>0.5ms~2.5ms</code>之间可以控制舵机桨角度的停留位置。</p>
<table>
<thead>
<tr>
<th style="text-align:center">0.5ms</th>
<th style="text-align:center">1.0ms</th>
<th style="text-align:center">1.5ms</th>
<th style="text-align:center">2.0ms</th>
<th style="text-align:center">2.5ms</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0度</td>
<td style="text-align:center">45度</td>
<td style="text-align:center">90度</td>
<td style="text-align:center">135度</td>
<td style="text-align:center">180度</td>
</tr>
</tbody>
</table>
<p>我们把舵机的电源线接好，然后信号线连接P1.7，把代码下载进去，舵机桨在上电后就会旋转到一个固定角度的位置上停留在那不动。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;function.h&gt;</span><span class="comment">//详见第六章第8讲</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;timer.h&gt;</span>   <span class="comment">//详见第八章第11讲</span></span></span><br><span class="line">sbit PWMOUT = P1^<span class="number">7</span>;  <span class="comment">//舵机信号线引脚</span></span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{   </span><br><span class="line">    LED_Init();<span class="comment">//初始化LED硬件模块</span></span><br><span class="line">    EA = <span class="number">1</span>;    <span class="comment">//闭合总中断开关</span></span><br><span class="line">    TIM0_Init(<span class="number">100</span>,<span class="number">9</span>);<span class="comment">//定时0.1ms,9是微调使定时精度更高</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>); </span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM0_IRQHandler</span><span class="params">()</span> interrupt 1</span><br><span class="line">{ </span><br><span class="line">    <span class="type">static</span> u8 pwm=<span class="number">0</span>;</span><br><span class="line">    TH0 = T0RH;  <span class="comment">//重新加载重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    </span><br><span class="line">    pwm++;</span><br><span class="line">    <span class="keyword">if</span>(pwm&gt;=<span class="number">200</span>)pwm=<span class="number">0</span>; <span class="comment">//pwm在0~199之间间隔0.1ms变化，周期为20ms</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(pwm&lt;<span class="number">10</span>)PWMOUT=<span class="number">1</span>;<span class="comment">//高电平在周期为20ms的PWM中持续的时间为1ms，低电平持续的时间就是19ms，舵机桨在45度处的位置停留不动</span></span><br><span class="line">    <span class="keyword">else</span> PWMOUT=<span class="number">0</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.imgdb.cn/item/645618c70d2dde5777ccc4a3.png" alt=""></p>
<h4 id="1-10-3-按键控制舵机">1.10.3 按键控制舵机</h4>
<p>使用按键控制舵机桨在我们想要的位置上停留。K8负责控制舵机桨往一个方向不停旋转，K16则控制相反方向旋转。按键模式为支持连按。然后数码管显示高电平持续的时间，如果数码管显示5，则高电平在20ms周期里持续的时间为0.5ms，如果显示的是20，那就是持续2ms的高电平时间。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"function.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"timer.h"</span></span></span><br><span class="line">sbit PWMOUT = P1^<span class="number">7</span>;  <span class="comment">//舵机信号线引脚</span></span><br><span class="line">  </span><br><span class="line">u16 highval=<span class="number">15</span>; </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{   </span><br><span class="line">    u8 key;</span><br><span class="line">    LED_Init();<span class="comment">//初始化LED硬件模块</span></span><br><span class="line">    KEY_Init();<span class="comment">//初始化按键模块</span></span><br><span class="line">    EA = <span class="number">1</span>;    <span class="comment">//闭合总中断开关</span></span><br><span class="line">    TIM0_Init(<span class="number">100</span>,<span class="number">9</span>); <span class="comment">//定时0.1ms,9是微调使定时精度更高</span></span><br><span class="line">    TIM1_Init(<span class="number">1000</span>,<span class="number">0</span>);<span class="comment">//定时1ms，用来刷新数码管显示,定时精度要求不高可不微调</span></span><br><span class="line">  </span><br><span class="line">    ShowNumber(highval);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {      </span><br><span class="line">        key=KEY_Scan(<span class="number">1</span>,<span class="number">500</span>);<span class="comment">//支持连按 </span></span><br><span class="line">        <span class="keyword">if</span>(key==<span class="number">8</span>)</span><br><span class="line">        {</span><br><span class="line">            highval++;</span><br><span class="line">            <span class="keyword">if</span>(highval&gt;<span class="number">25</span>)highval=<span class="number">25</span>;<span class="comment">//高电平持续时间不能超过2.5ms</span></span><br><span class="line">            ShowNumber(highval);</span><br><span class="line">        }</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span>(key==<span class="number">16</span>)</span><br><span class="line">        {</span><br><span class="line">            highval--;</span><br><span class="line">            <span class="keyword">if</span>(highval&lt;<span class="number">5</span>)highval=<span class="number">5</span>;<span class="comment">//高电平持续时间不能低于0.5ms</span></span><br><span class="line">            ShowNumber(highval);</span><br><span class="line">        }     </span><br><span class="line">    }   </span><br><span class="line">}</span><br><span class="line">   </span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM0_IRQHandler</span><span class="params">()</span> interrupt 1</span><br><span class="line">{ </span><br><span class="line">    <span class="type">static</span> u8 pwm=<span class="number">0</span>;</span><br><span class="line">    TH0 = T0RH;  <span class="comment">//重新加载重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">     </span><br><span class="line">    pwm++;</span><br><span class="line">    <span class="keyword">if</span>(pwm&gt;=<span class="number">200</span>)pwm=<span class="number">0</span>;<span class="comment">//pwm在0~199之间间隔0.1ms变化，周期为20ms</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(pwm&lt;highval)PWMOUT=<span class="number">1</span>;<span class="comment">//highval的值决定舵机桨的停留位置</span></span><br><span class="line">    <span class="keyword">else</span> PWMOUT=<span class="number">0</span>; </span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM1_IRQHandler</span><span class="params">()</span> interrupt 3</span><br><span class="line">{ </span><br><span class="line">    TH1 = T1RH;  <span class="comment">//重新加载重载值</span></span><br><span class="line">    TL1 = T1RL;</span><br><span class="line">    SEG_Scan();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-10-4-呼吸灯与舵机">1.10.4 呼吸灯与舵机</h4>
<p>呼吸灯的程序思想如果用在舵机控制上，那么舵机桨就是从0度的位置转到180度的位置又从180度处转回0度处如此循环往复，现在我们动手改写一下呼吸灯的程序使其能融入舵机的控制中。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"function.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"timer.h"</span></span></span><br><span class="line"></span><br><span class="line">sbit PWMOUT = P1^<span class="number">7</span>; <span class="comment">//舵机信号线引脚</span></span><br><span class="line"></span><br><span class="line">u16 highval = <span class="number">5</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	u8 key;</span><br><span class="line">	LED_Init(); <span class="comment">//初始化LED硬件模块</span></span><br><span class="line">	KEY_Init(); <span class="comment">//初始化按键模块</span></span><br><span class="line">	EA = <span class="number">1</span>; <span class="comment">//闭合总中断开关</span></span><br><span class="line">	TIM0_Init(<span class="number">100</span>, <span class="number">9</span>); <span class="comment">//定时0.1ms, 9是微调使定时精度更高</span></span><br><span class="line">	TIM1_Init(<span class="number">50000</span>, <span class="number">0</span>); <span class="comment">//定时50ms，定时精度要求不高可以不微调</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM0_IRQHandler</span><span class="params">()</span> interrupt 1 {</span><br><span class="line">	<span class="type">static</span> u8 pwm = <span class="number">0</span>;</span><br><span class="line">	TH0 = T0RH; <span class="comment">//重装初始值</span></span><br><span class="line">	TL0 = T0RL; </span><br><span class="line">	</span><br><span class="line">	pwm++;</span><br><span class="line">	<span class="keyword">if</span>(pwm &gt;= <span class="number">200</span>) pwm = <span class="number">0</span>; <span class="comment">//pwm在0-199之间间隔0.1ms变化，周期为20ms</span></span><br><span class="line">	<span class="keyword">if</span>(pwm &lt; highval) PWMOUT = <span class="number">1</span>; <span class="comment">//highval的值决定舵机桨的停留位置</span></span><br><span class="line">	<span class="keyword">else</span> PWMOUT = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM1_IRQHandler</span><span class="params">()</span> interrupt 3 {</span><br><span class="line">	<span class="type">static</span> u8 dir;</span><br><span class="line">	TH1 = T1RH; <span class="comment">//重装初始值</span></span><br><span class="line">	TL1 = T1RL;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//控制highval只能在5~24之间变化</span></span><br><span class="line">	<span class="keyword">if</span>(dir == <span class="number">1</span>) highval--; <span class="comment">//占空比逐渐减少，舵机桨往0度的位置走动</span></span><br><span class="line">	<span class="keyword">if</span>(highval &lt; <span class="number">5</span>) dir = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(dir == <span class="number">0</span>) highval++; <span class="comment">//占空比逐渐增加，舵机桨往180度的位置走动</span></span><br><span class="line">	<span class="keyword">if</span>(highval&gt;=<span class="number">24</span>)dir = <span class="number">1</span>; <span class="comment">//测试发现，24已经是舵机桨的尽头，无需写25</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1-11-串口通信">1.11 串口通信</h3>
<h4 id="1-11-1-串口通信入门">1.11.1 串口通信入门</h4>
<p>对于单片机来说，通信则与传感器、存储芯片、外围控制芯片等技术紧密结合，成为整个单片机系统的<code>神经中枢</code>。</p>
<p><code>UART</code>（Universal Asynchronous Receiver/Transmitter，即<code>通用异步收发器</code>）串行通信是单片机最常用的一种通信技术，通常用于单片机和电脑之间以及单片机和单片机之间的通信。</p>
<p>通信按照基本类型可以分为<code>并行通信</code>和<code>串行通信</code>。并行通信时数据的各个位同时传送，可以实现字节为单位通信，但是通信线多占用资源多，成本高。比如我们前边用到的P0 = 0xFE;一次给 P0 的 8 个 IO 口分别赋值，同时进行信号输出，类似于有 8 个车道同时可以过去 8 辆<br>
车一样，这种形式就是并行的，我们习惯上还称 P0、P1、P2 和 P3 为 51 单片机的 4 组并行总线。 而串行通信，就如同一条车道，一次只能一辆车过去，如果一个 0xFE 这样一个字节的数据要传输过去的话，假如低位在前高位在后的话，那发送方式就是 0-1-1-1-1-1-1-1-1，一位一位的发送出去的，要发送 8 次才能发送完一个字节。</p>
<p>STC89C52 有两个引脚是专门用来做 UART 串行通信的，一个是<code>P3.0</code>一个是<code>P3.1</code>，它们还分别有另外的名字叫做<code>RXD</code>和<code>TXD</code>，由它们组成的通信接口就叫做<code>串行接口</code>，简称<code>串口</code>。用两个单片机进行 UART 串口通信，基本的演示图如图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.imgdb.cn/item/645ce2300d2dde57772f7ab8.png" alt=""></p>
<p>图中，GND 表示单片机系统电源的参考地，TXD 是串行发送引脚，RXD 是串行接收引脚。两个单片机之间要通信，首先<code>电源基准</code>得一样，所以我们要把两个单片机的 GND 相互连接起来，然后单片机 1 的 TXD 引脚接到单片机 2 的 RXD 引脚上，即此路为单片机 1 发送<br>
而单片机 2 接收的通道，单片机 1 的 RXD 引脚接到单片机 2 的 TXD 引脚上，即此路为单片机 2 发送而单片机 1 接收的通道。</p>
<p>当单片机 1 想给单片机 2 发送数据时，比如发送一个 0xE4 这个数据，用二进制形式表示就是 0b11100100，在 UART 通信过程中，是低位先发，高位后发的原则，那么就让 TXD首先拉低电平，持续一段时间，发送一位 0，然后继续拉低，再持续一段时间，又发送了一位 0，然后拉高电平，持续一段时间，发了一位 1……一直到把 8 位二进制数字 0b11100100全部发送完毕。</p>
<p>这里我们提及持续一段时间，那么要持续多久呢？下面我们学相关概念。</p>
<ul>
<li>波特率：波特率就是发送二进制数据位的<code>速率</code>，习惯上用<code>baud</code>表示，即我们发送<code>一位二进制数据</code>的持续时间=<code>1/baud</code>。在通信之前，单片机 1 和单片机 2 首先都要明确的约定好它们之间的通信波特率，必须保持一致，收发双方才能正常实现通信。常用的波特率为<code>9600</code>，所谓9600指的是一秒钟单片机可以发送9600个数据位，也就是1秒钟的时间里单片机可以发送(9600/8)=1200字节，一个字节等于八个位，一字节等于八比特，因此<code>一个字节等于八个二进制位</code>。</li>
</ul>
<p>我们知道了接受（发送）持续的时间，那么如何确定起始或停止发送的呢？</p>
<ul>
<li>规定当<code>没有</code>通信信号发生时，<code>通信线路保持高电平</code>，当要发送数据之前，<code>先发一位 0 表示起始位</code>，然后发送 8 位数据位，数据位是<code>先低后高</code>的顺序，数据位发完后<code>再发一位 1 表示停止位</code>。这样本来要发送一个字节的 <code>8</code> 位数据，而实际上我们一共发送了 <code>10 </code>位，多出来的两位其中一位起始位，一位停止位。而接收方呢，原本一直保持的高电平，一旦检测到了一位低电平，那就知道了要开始准备接收数据了，接收到 8 位数据位后，然后检测到停止位，再准备下一个数据的接收。</li>
</ul>
<p>我们以一个具体的例子感受一下，单片机的<code>P3.1</code>（TXD）是发送引脚，也就是说要发送字符“A”，这个引脚的变化如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.imgdb.cn/item/645ce5bc0d2dde577733dfa2.png" alt=""></p>
<p>单片机要发送一个字节给电脑端，首先发送引脚需要先拉高，然后拉低持续(1/9600)秒，电脑端检测到这个低电平信号就会准备接收数据字节。然后我们要发送的二进制位是01000001，但是串口通信发送的字节是低位在前，高位在后，所以上图的发送顺序就是01000001反过来为10000010。一个字节发送完成之后还要发送一个停止位1，电脑端接收到这个停止位就认为一个字节发送完成了。</p>
<p>我们用定时器来实现引脚的持续时间，怎么定时(1/9600)秒怎么设置，计算一下就可以了。</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>9600</mn></mfrac><mo>=</mo><mi>X</mi><mo>∗</mo><mo stretchy="false">(</mo><mn>12</mn><mi mathvariant="normal">/</mi><mn>11059200</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{1}{9600} = X * (12 / 11059200)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">9</span><span class="mord">6</span><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">2</span><span class="mord">/</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">5</span><span class="mord">9</span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span></p>
<p>解得：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mn>96</mn></mrow><annotation encoding="application/x-tex">X = 96</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">6</span></span></span></span>，因为定时时间间隔比较短，所以我们使用定时器0的工作模式2就可以了。填充TH0的初始值就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>256</mn><mo>−</mo><mn>96</mn><mo>=</mo><mn>160</mn><mo>→</mo><mn>0</mn><mi>x</mi><mi>A</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">256-96=160 \rightarrow 0xA0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord mathdefault">A</span><span class="mord">0</span></span></span></span>。因为P3^1在<code>#include &lt;reg52.h&gt;</code>已有定义为TXD， 我们可以直接使用。通过按K4来启动发送字节数据。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"function,h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"timer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM0_Mode2_Init</span><span class="params">()</span> {</span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>; <span class="comment">//清零低四位</span></span><br><span class="line">    TMOD |= <span class="number">0x02</span>; <span class="comment">//设置定时器0为工作模式2</span></span><br><span class="line">    TH0 = <span class="number">0xA0</span>; <span class="comment">//计算出波特率9600</span></span><br><span class="line">    TL0 = <span class="number">0x00</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>; <span class="comment">//闭合定时器0中断的开关</span></span><br><span class="line">    TR0 = <span class="number">1</span>; <span class="comment">//启动定时器0</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    u8 key;</span><br><span class="line">    LED_Init(); <span class="comment">//初始化LED硬件模块</span></span><br><span class="line">    KEY_Init(); <span class="comment">//初始化按键模块</span></span><br><span class="line">    EA = <span class="number">1</span>; <span class="comment">//闭合总中断开关</span></span><br><span class="line">    TIM0_Mode2_Init(); <span class="comment">//定时（1 / 9600）秒</span></span><br><span class="line">    TR0 = <span class="number">0</span>; <span class="comment">//关闭定时器</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        key = KEY_Scan(<span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span>(key == <span class="number">4</span>) TR0 = <span class="number">1</span>; <span class="comment">//开启定时器，启动一个字节传输，按一次一次发送</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM0_IRQHandler</span><span class="params">()</span> interrupt 1 {</span><br><span class="line">    <span class="type">static</span> u8 cnt = <span class="number">0</span>, i, TXDBUF = <span class="number">65</span>; <span class="comment">//字符`A`的ASCII值为65</span></span><br><span class="line">    cnt++; <span class="comment">//cnt一直在1-10之间变化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(cnt == <span class="number">1</span>) TXD = <span class="number">0</span>; <span class="comment">//cnt变为1，发送起始位，这次的中断函数就执行完了，持续够(1/9600)秒之后，再次进入中断函数，然后就是发送数据字节的8位的任务</span></span><br><span class="line">    <span class="keyword">if</span>(cnt &gt;= <span class="number">2</span> &amp;&amp; cnt &lt;= <span class="number">9</span>) { <span class="comment">//发送8位数据位，从低位开始引脚的变化为 1 0 0 0 0 0 1 0</span></span><br><span class="line">        TXD = TXDBUF &amp; <span class="number">0x01</span>; <span class="comment">//要么等于1要么等于0，这样P3.1的引脚要么保持高电平，要么保持低电平</span></span><br><span class="line">        TXDBUF &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">10</span>) {</span><br><span class="line">        TXD = <span class="number">1</span>; <span class="comment">//发送停止位</span></span><br><span class="line">        TR0 = <span class="number">0</span>; <span class="comment">//关闭定时器，结束一次字节传输</span></span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        TXDBUF = <span class="number">65</span>+i; <span class="comment">//下次按下按键发送的是B C D E...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里简单说明一下，我们按下K4启动了定时器，然后第一次进入中断函数时，做的任务就是拉低P3.1，然后这次的中断函数的任务就结束了，等过了(1/9600)秒之后，再次进入中断函数，上一次拉低P3.1的时间已经持续够(1/9600)秒了，这第二次的中断函数任务就是拉高P3.1，因为发送字符A这个字节的最低位为1，持续够(1/9600)秒进入第三次执行中断函数，拉低P3.1，第四，第五，第六，第七都是拉低P3.1发送0，以此类推，到第10次中断函数执行就是拉高P3.1发送停止位，关闭定时器结束一次字节的传输，要想再次发送需要按K4启动定时器，<code>TXDBUF=65+i;</code>表示下次发送的是66这个数据，再下次就是发送67，68以此类推。</p>
<h4 id="1-11-2-软件设置">1.11.2 软件设置</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.imgdb.cn/item/645cf95e0d2dde57774de5bd.png" alt=""></p>
<p>下载以上代码，不断按下Key4可以看见按输出A B C D C等…</p>
<h4 id="1-11-3-串口配置函数">1.11.3 串口配置函数</h4>
<p>这里讲解一两处配置的知识，首先<code>SCON=0x50;</code>是让SCON寄存器的第4位和第6位的置1，其他位置0。<code>TH1=256-(11059200/12/32/buad);</code>是波特率设置的计算公式，由于串口的使用是要占用定时器1，那么定时器1的定时中断将不能使用，所以必须使<code>ET1=0;</code>禁止其产生定时中断，也就是使用了串口，那么<code>void TIM1_IRQHandler() interrupt 3</code>将不能再出现在程序书写中。不过，串口也有相应的中断函数，像<code>ET0,ET1</code>一样，这些都是子开关，串口中断的子开关为<code>ES</code>，<code>ES=1;</code>和<code>EA=1;</code>就开启了串口的中断函数。我们串口发送数据的时候会产生中断，接收到数据的时候也会产生中断，这两个瞬间我们在中断函数里需要执行相关任务。要知道串口有动作的时候，总会有<code>RI</code>或者<code>TI</code>被置1，前者意为<code>接收到完整的8位的数据</code>，也就使接收到一个字节然后<code>RI</code>就被置1.后者意为<code>单片机发送完一个完整的字节了</code>，<code>TI</code>就被置1.这些瞬间都需要我们在串口中断函数中让其清零（软件清零），以备下次它们能再次被置1。</p>
<p>下面实现的功能是电脑端通过串口发送一个数据给单片机，这个数据被单片机接收到之后，让这个数据再加1，然后单片机再通过串口把加1后的数据发送回去给电脑端让它在窗口上显示。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"function.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"timer.h"</span></span></span><br><span class="line"></span><br><span class="line">u8 RXDBUF; <span class="comment">//缓存接收到的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigUART</span><span class="params">(u16 baud)</span> {</span><br><span class="line">    SCON = <span class="number">0x50</span>; <span class="comment">//配置串口为模式1</span></span><br><span class="line">    TMOD &amp;= <span class="number">0x0F</span>; <span class="comment">//清零T1的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x20</span>; <span class="comment">//配置T1为模式2</span></span><br><span class="line">    </span><br><span class="line">    TH1 = <span class="number">256</span> - (<span class="number">11059200</span>/<span class="number">12</span>/<span class="number">32</span>)/baud; <span class="comment">//计算T1的重载值</span></span><br><span class="line">    TL1 = TH1; <span class="comment">//初值为重载值</span></span><br><span class="line">    </span><br><span class="line">    ET1 = <span class="number">0</span>; <span class="comment">//禁止T1中断</span></span><br><span class="line">    ES = <span class="number">1</span>; <span class="comment">//使能串口中断</span></span><br><span class="line">    TR1 = <span class="number">1</span>; <span class="comment">//开启定时器1</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    LED_Init(); <span class="comment">//初始化LED硬件模块</span></span><br><span class="line">    EA = <span class="number">1</span>; <span class="comment">//闭合总中断开关</span></span><br><span class="line">    ConfigUART(<span class="number">9600</span>); <span class="comment">//串口波特率设置为9600</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptUART</span><span class="params">()</span> interrupt 4 {</span><br><span class="line">    <span class="keyword">if</span> (RI) { <span class="comment">//RI等于1就满足if条件语句，意为接收到一个字节</span></span><br><span class="line">        RI = <span class="number">0</span>; <span class="comment">//软件清零接受中断标志位</span></span><br><span class="line">        RXDBUF = SBUF; <span class="comment">//接收到的数据保存到接收缓存变量中</span></span><br><span class="line">        SBUF = RXDBUF + <span class="number">1</span>; <span class="comment">//发送回去给电脑端的数据</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (TI) {</span><br><span class="line">        TI = <span class="number">0</span>; <span class="comment">//软件清零发送中断标志位</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.imgdb.cn/item/645e507f0d2dde577702a131.png" alt=""></p>
<p>这里的串口中断函数，像<code>if(RI)TR=0;</code>和<code>if(TI)TI=0;</code>这些都是在串口中断函数中必须要执行的任务，当然如果在其他函数里有清零这两个位，可以不用在串口中断函数中书写，但是一定要<code>保证每次都要清0</code>。</p>
<p><code>SBUF</code>是名字相同但作用不同的缓冲区，<code>SBUF=RXDBUF+1;</code>SBUF在等于号<code>前面</code>意为这个是单片机发送给电脑端数据的缓冲区，一旦出现<code>SBUF=xxxx;</code>这样的语句，那就是单片机开始通过串口发送数据出去。上图可以看见现象。</p>
<h4 id="1-11-4-ascii码与通信数据">1.11.4 ASCII码与通信数据</h4>
<p>通过实验操作来熟悉ASCII码与通信数据之间的关系。</p>
<p>现在实现这样的功能：<code>在电脑端上发送“十六进制”模式或“字符格式”模式的字节给单片机，数码管则显示出这些数据的十进制值，然后观察数码管上显示的数值与发送数据的关系</code>。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"function.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"timer.h"</span></span></span><br><span class="line"></span><br><span class="line">u8 RXDBUF; <span class="comment">//缓存接收到的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigUART</span><span class="params">(u16 baud)</span> {</span><br><span class="line">    SCON = <span class="number">0x50</span>; <span class="comment">//配置串口为模式1</span></span><br><span class="line">    TMOD &amp;= <span class="number">0X0F</span>; <span class="comment">//清零T1的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x20</span>; <span class="comment">//配置T1为模式2</span></span><br><span class="line">    </span><br><span class="line">    TH1 = <span class="number">256</span> - (<span class="number">11059200</span>/<span class="number">12</span>/<span class="number">32</span>)/baud; <span class="comment">//计算重载值</span></span><br><span class="line">    TL1 = TH1; <span class="comment">//初始值为重载值</span></span><br><span class="line">    </span><br><span class="line">    ET1 = <span class="number">0</span>; <span class="comment">//禁止T1中断</span></span><br><span class="line">    ES = <span class="number">1</span>; <span class="comment">//使能串口中断</span></span><br><span class="line">    TR1 = <span class="number">1</span>; <span class="comment">//启动定时器1</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    LED_Init(); <span class="comment">//初始化LED硬件模块</span></span><br><span class="line">    EA = <span class="number">1</span>; <span class="comment">//闭合中断总开关</span></span><br><span class="line">    ConfigUART(<span class="number">9600</span>); <span class="comment">//配置波特率为9600</span></span><br><span class="line">    TIM0_Init(<span class="number">1000</span>, <span class="number">0</span>); <span class="comment">//定时1ms，用来刷新数码管显示，定时精度要求不高可以不使用微调</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        ShowNumber(RXDBUF);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM0_IRQHandler</span><span class="params">()</span> interrupt 1 {</span><br><span class="line">    TH0 = T0RH; <span class="comment">//重新加载初始值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    SEG_Scan();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptUART</span><span class="params">()</span> interrupt 4 {</span><br><span class="line">    <span class="keyword">if</span>(RI) {</span><br><span class="line">        RI = <span class="number">0</span>; <span class="comment">//手动清零接收中断标志位</span></span><br><span class="line">        RXDBUF = SBUF; <span class="comment">//接收到的数据保存到接收缓存变量中</span></span><br><span class="line">        SBUF = RXDBUF; <span class="comment">//接收到的数据又直接发回，叫做-"echo",用以提示用户输入的信息是否以正确接收</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(TI) {</span><br><span class="line">        TI = <span class="number">0</span>; <span class="comment">//软件清零发送中断标志位</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在发送窗口和接收窗口都选“十六进制”模式，电脑端发送一个8的数据（也就是0x08）的字节给单片机，然后单片机会发送回来这个数据给电脑端显示在窗口中。此时开发板上的数码管显示的是8。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.imgdb.cn/item/645e5c2d0d2dde577715cea5.png" alt="image-20230512233102479"></p>
<p>接着我们在电脑端发送的是10，这是0x10,不要与十进制的10混淆。数码管显示的是16，所以发送的数据用十进制显示在数码管上是正确的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.imgdb.cn/item/645e5d4e0d2dde577717dec0.png" alt=""></p>
<p>我们切换到<code>字符格式</code>模式下发送字符<code>A</code>。数码管显示的是65，电脑端接收到单片机发送回来的数据是0x41，也就是十进制下的65。</p>
<p>找到ASCII表，字符“A”对应的数刚好是65。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.imgdb.cn/item/645e5de80d2dde577718d866.png" alt=""></p>
<p>如果把电脑端接收窗口改为“字符格式”显示，那么显示的内容就跟发送窗口的字符一样了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.imgdb.cn/item/645e5e580d2dde57771977bd.png" alt=""></p>
<p>如果我们在电脑端发送窗口输入一串字符比如“ABCD123”点击发送给单片机，如果我们看到的是下面这个现象</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.imgdb.cn/item/645e5edd0d2dde57771a9e19.png" alt=""></p>
<p>那么结合以下的程序代码分析<code>RXDBUF = SBUF;SBUF = RXDBUF;</code>也就是电脑端先发送字符<code>A</code>给单片机，单片机马上发送回字符<code>A</code>给电脑端，接着电脑端又发送字符<code>B</code>，如此执行下去，直到发送完最后一个字符<code>4</code>。</p>
<p>这些发送和接收过程是非常快的，因为单片机接收缓存区SBUF每次只能暂存一个字节，所以前面8个字节都会很快被替换，导致数码管在一瞬间里只显示字符<code>4</code>的ASCII码值52。</p>
<h4 id="1-11-5-printf系列的函数实现">1.11.5 printf系列的函数实现</h4>
<p>懂得了单片机通过串口传输数据给电脑端口窗口查看，那么，有时我们需要发送字符串，有时需要发送一个变量的数值是多少，以及还要发送回车换行这三种情况，所以我们把这三个功能函数封装起来，方便后续的串口使用。</p>
<ol>
<li><code>void printf_str(u8 *str)</code>函数就是专门用来发送字符串给电脑端的。</li>
<li><code>void printf_num(u32 num)</code>函数发送的变量数值只支持显示十进制数<code>0-4294967295</code>,也就是参数u32类型。</li>
<li><code>void printf_rn()</code>就是发送回车换行符。</li>
</ol>
<p>这里的代码，我们需要慢慢弄懂，现在不懂也没有关系，后面慢慢消化。我们希望串口这部分功能模块也能像定时器那样封装一个单独文件使用，所以创建号<code>uart.c</code>和<code>uart.h</code>文件，复制以下代码：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uart.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;function.h&gt;</span><span class="comment">//详见第六章第8讲</span></span></span><br><span class="line">   </span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigUART</span><span class="params">(u16 baud)</span></span><br><span class="line">{</span><br><span class="line">    SCON  = <span class="number">0x50</span>;  <span class="comment">//配置串口为模式1</span></span><br><span class="line">    TMOD &amp;= <span class="number">0x0F</span>;  <span class="comment">//清零T1的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x20</span>;  <span class="comment">//配置T1为模式2</span></span><br><span class="line">    TH1 = <span class="number">256</span> - (<span class="number">11059200</span>/<span class="number">12</span>/<span class="number">32</span>)/baud;<span class="comment">//计算T1重载值</span></span><br><span class="line">    TL1 = TH1;     <span class="comment">//初值等于重载值</span></span><br><span class="line">    ET1 = <span class="number">0</span>;       <span class="comment">//禁止T1中断</span></span><br><span class="line">    ES  = <span class="number">1</span>;       <span class="comment">//使能串口中断</span></span><br><span class="line">    TR1 = <span class="number">1</span>;       <span class="comment">//启动T1</span></span><br><span class="line">} </span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">printf_str</span><span class="params">(u8 *str)</span></span><br><span class="line">{ </span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="string">'\0'</span>)<span class="comment">//连续发送字符串数据，直到检测到结束符</span></span><br><span class="line">    {</span><br><span class="line">        SBUF=*str++;</span><br><span class="line">        <span class="keyword">while</span>(!TI);    <span class="comment">//等待字节发送完成TI被置1就退出这个while循环</span></span><br><span class="line">        TI = <span class="number">0</span>;        <span class="comment">//清0标志位</span></span><br><span class="line">    }  </span><br><span class="line">}</span><br><span class="line">   </span><br><span class="line"><span class="type">void</span> <span class="title function_">printf_num</span><span class="params">(u32 num)</span></span><br><span class="line">{</span><br><span class="line">    u8 buf[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> i;<span class="comment">//取值范围为-128~127</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)       <span class="comment">//把长整型数转换为10位十进制的数组</span></span><br><span class="line">    {</span><br><span class="line">        buf[i] = num % <span class="number">10</span>;</span><br><span class="line">        num = num / <span class="number">10</span>;        <span class="comment">//舍掉个位数，重新装载</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">9</span>; i&gt;=<span class="number">1</span>; i--)  </span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (buf[i] != <span class="number">0</span>)<span class="keyword">break</span>; <span class="comment">//从最高位起，遇到0不理会，遇到非0则退出循环</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)          <span class="comment">//剩余低位都如实发送出去</span></span><br><span class="line">    {   </span><br><span class="line">        SBUF=<span class="string">'0'</span>+buf[i]; <span class="comment">//如果此时的buf[i]的值是1，那么电脑端窗口在“字符格式”模式下要想显示字符“1”，只需'0'+1，因为‘0’就是ASCII码值48</span></span><br><span class="line">        <span class="keyword">while</span>(!TI);      <span class="comment">//等待字节发送完成TI被置1就退出这个while循环</span></span><br><span class="line">        TI = <span class="number">0</span>;          <span class="comment">//清0标志位</span></span><br><span class="line">        i--;   </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">   </span><br><span class="line"><span class="type">void</span> <span class="title function_">printf_rn</span><span class="params">()</span> <span class="comment">//发送回车换行符</span></span><br><span class="line">{</span><br><span class="line">    SBUF=<span class="string">'\r'</span>;</span><br><span class="line">    <span class="keyword">while</span>(!TI);  <span class="comment">//等待字节发送完成TI被置1就退出这个while循环</span></span><br><span class="line">    TI = <span class="number">0</span>;      <span class="comment">//清0标志位</span></span><br><span class="line">    </span><br><span class="line">    SBUF=<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">while</span>(!TI);  <span class="comment">//等待字节发送完成TI被置1就退出这个while循环</span></span><br><span class="line">    TI = <span class="number">0</span>;      <span class="comment">//清0标志位</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uart.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __UART_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __UART_H__</span></span><br><span class="line">   </span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigUART</span><span class="params">(u16 baud)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">printf_str</span><span class="params">(u8 *str)</span>;<span class="comment">//发送字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printf_num</span><span class="params">(u32 num)</span>;<span class="comment">//发送参数的数值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printf_rn</span><span class="params">()</span>;        <span class="comment">//发送回车换行符</span></span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;function.h&gt;</span><span class="comment">//详见第六章第8讲</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uart.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{  </span><br><span class="line">    u8 key;</span><br><span class="line">    u32 value=<span class="number">65535</span>;</span><br><span class="line">    LED_Init();<span class="comment">//初始化LED硬件模块</span></span><br><span class="line">    KEY_Init();<span class="comment">//初始化按键模块</span></span><br><span class="line">    EA = <span class="number">1</span>;    <span class="comment">//闭合总中断开关</span></span><br><span class="line">    ConfigUART(<span class="number">9600</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {  </span><br><span class="line">        key=KEY_Scan(<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span>(key==<span class="number">4</span>)</span><br><span class="line">        {</span><br><span class="line">            printf_str(<span class="string">"value="</span>);<span class="comment">//发送字符串</span></span><br><span class="line">            printf_num(value);   <span class="comment">//发送变量的数值</span></span><br><span class="line">            printf_rn();         <span class="comment">//发送回车换行符</span></span><br><span class="line">            value++;</span><br><span class="line">        }</span><br><span class="line">    } </span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptUART</span><span class="params">()</span> interrupt 4</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (RI)    <span class="comment">//接收到字节</span></span><br><span class="line">    {</span><br><span class="line">        RI = <span class="number">0</span>;<span class="comment">//手动清零接收中断标志位                     </span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在串口中断函数中我们没有再写“if(TI){ TI = 0; }”,那是因为我们在所有的发送函数中都做了TI的清0处理，所以可以在串口中断函数中不用再书写TI。</p>
<p>不断按下Key4按键，可以观察到串口助手出现字符串。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.imgdb.cn/item/646094a20d2dde5777b7bd58.png" alt=""></p>
<h3 id="1-12-1602液晶屏">1.12 1602液晶屏</h3>
<h2 id="二-实战教学以及作品展示">二、实战教学以及作品展示</h2>
<h3 id="2-1-led">2.1 LED</h3>
<h4 id="2-1-1-点亮第一个led灯">2.1.1 点亮第一个LED灯</h4>
<h5 id="2-1-1-1-源码">2.1.1.1 源码</h5>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 理论</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit LED= P2^<span class="number">0</span>; <span class="comment">// 直接使用sbit 控制P0^0一个位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	LED = <span class="number">0</span>; <span class="comment">// 低电平点灯</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>); <span class="comment">// 死循环</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="2-1-1-2-仿真">2.1.1.2 仿真</h5>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/642bb98b6ea21b9a9e23ed62.gif" alt=""></p>
<h5 id="2-1-1-3-实物">2.1.1.3 实物</h5>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit LED = P0^<span class="number">0</span>;</span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line">   </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	ENLED = <span class="number">0</span>; <span class="comment">//</span></span><br><span class="line">	ADDR3 = <span class="number">1</span>; <span class="comment">// 使能三八译码器</span></span><br><span class="line">	</span><br><span class="line">	ADDR2 = <span class="number">1</span>; <span class="comment">// **************************</span></span><br><span class="line">	ADDR1 = <span class="number">1</span>; <span class="comment">// 让三八译码器的IO6输出低电平</span></span><br><span class="line">	ADDR0 = <span class="number">0</span>; <span class="comment">// ***************************</span></span><br><span class="line">	</span><br><span class="line">	LED = <span class="number">0</span>; <span class="comment">//点亮最右边的灯</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/642bbc7c6ea21b9a9e3cf947.png" alt=""></p>
<h4 id="2-1-2-闪烁的led灯">2.1.2 闪烁的LED灯</h4>
<div class="tip warning faa-horizontal animated"><p>延时是单片机入门必学的应用！</p>
</div>
<h5 id="2-1-2-1-源码">2.1.2.1 源码</h5>
<p>有了前面的基础，点灯肯定不是问题，这里实现让LED从点亮一段时间到熄灭一段时间再点亮一段时间如此循环下去，实现<code>闪烁</code>LED的功能。为了实现这个目的我们需要实现延迟函数<code>for(i=0;i&lt;30000;i++);</code>是最简单的延时语句。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 理论</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit LED = P2^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">		LED = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">3000</span>; i++);</span><br><span class="line">		LED = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">3000</span>; i++);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="2-1-2-2-仿真">2.1.2.2 仿真</h5>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/642bc0326ea21b9a9e5ef73c.gif" alt=""></p>
<h5 id="2-1-2-3-实物">2.1.2.3 实物</h5>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit LED = P0^<span class="number">0</span>;</span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">		ENLED = <span class="number">0</span>; <span class="comment">//定义一个16位无符号整形变量</span></span><br><span class="line">		ADDR3 = <span class="number">1</span>; <span class="comment">// 三八译码器使能</span></span><br><span class="line">		</span><br><span class="line">		ADDR2 = <span class="number">1</span>; <span class="comment">//******************************</span></span><br><span class="line">		ADDR1 = <span class="number">1</span>; <span class="comment">//使三八译码器的IO6口输出低电平</span></span><br><span class="line">		ADDR0 = <span class="number">0</span>; <span class="comment">//******************************</span></span><br><span class="line">	</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">			LED = <span class="number">0</span>; <span class="comment">//点亮最右边的小灯</span></span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">3000</span>; i++); <span class="comment">//延迟一段时间</span></span><br><span class="line">			LED = <span class="number">1</span>; <span class="comment">//熄灭最右边的小灯</span></span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">3000</span>; i++); <span class="comment">//延迟一段时间</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<div class="tip warning faa-horizontal animated"><p>关于单片机设计精确的延迟，可以看这篇文章的第三章的Delay()函数</p>
</div>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际，延迟一秒</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> </span></span><br><span class="line">sbit LED2  = P0^<span class="number">0</span>;</span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i,j;<span class="comment">//定义两个16位的变量  </span></span><br><span class="line">    ADDR3 = <span class="number">1</span>;<span class="comment">//使能三八译码器</span></span><br><span class="line">    ENLED = <span class="number">0</span>;<span class="comment">// </span></span><br><span class="line"> </span><br><span class="line">    ADDR2 = <span class="number">1</span>;<span class="comment">//**************************</span></span><br><span class="line">    ADDR1 = <span class="number">1</span>;<span class="comment">//让三八译码器的IO6输出低电平</span></span><br><span class="line">    ADDR0 = <span class="number">0</span>;<span class="comment">//**************************</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        LED2=<span class="number">0</span>;<span class="comment">//点亮最右端的灯</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">19601</span>;i++)<span class="comment">//延时1s</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">5</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">        }</span><br><span class="line">        LED2=<span class="number">1</span>;<span class="comment">//熄灭最右端的灯</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">19601</span>;i++)<span class="comment">//延时1s</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">5</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-1-3-三个小灯同时闪烁">2.1.3 三个小灯同时闪烁</h4>
<h5 id="2-1-3-1-源码">2.1.3.1 源码</h5>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 理论</span></span><br><span class="line"><span class="comment">// 原理很简单控制P2^0,P2^1,P2^2口的高低电平即可</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"reg52.h"</span> <span class="comment">// 引入8051单片机头文件</span></span></span><br><span class="line"></span><br><span class="line">sbit LED1 = P2^<span class="number">0</span>; <span class="comment">// 定义LED1引脚为P1.0</span></span><br><span class="line">sbit LED2 = P2^<span class="number">1</span>; <span class="comment">// 定义LED2引脚为P1.1</span></span><br><span class="line">sbit LED3 = P2^<span class="number">2</span>; <span class="comment">// 定义LED3引脚为P1.2</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">		<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) <span class="comment">// 无限循环</span></span><br><span class="line">    {</span><br><span class="line">        LED1 = <span class="number">0</span>;</span><br><span class="line">        LED2 = <span class="number">0</span>;</span><br><span class="line">        LED3 = <span class="number">0</span>;</span><br><span class="line">			</span><br><span class="line">				<span class="comment">// 延时一段时间，使LED保持熄灭状态</span></span><br><span class="line">        <span class="comment">// 可根据需要调整延时时间</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">500</span>;i++);</span><br><span class="line">        </span><br><span class="line">        LED1 = <span class="number">1</span>;<span class="comment">// 将LED1引脚置为高电平，熄灭LED1</span></span><br><span class="line">        LED2 = <span class="number">1</span>;<span class="comment">// 将LED2引脚置为高电平，熄灭LED2</span></span><br><span class="line">        LED3 = <span class="number">1</span>;<span class="comment">// 将LED3引脚置为高电平，熄灭LED3</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 延时一段时间，使LED保持熄灭状态</span></span><br><span class="line">        <span class="comment">// 可根据需要调整延时时间</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">500</span>;i++);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="2-1-3-2-仿真">2.1.3.2 仿真</h5>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/64206b97a682492fcc53043f.gif" alt=""></p>
<h5 id="2-1-3-3-实物">2.1.3.3 实物</h5>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"reg52.h"</span> <span class="comment">// 引入8051单片机头文件</span></span></span><br><span class="line"></span><br><span class="line">sbit LED1 = P0^<span class="number">0</span>; <span class="comment">// 定义LED1引脚为P1.0</span></span><br><span class="line">sbit LED2 = P0^<span class="number">1</span>; <span class="comment">// 定义LED2引脚为P1.1</span></span><br><span class="line">sbit LED3 = P0^<span class="number">2</span>; <span class="comment">// 定义LED3引脚为P1.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启总开关</span></span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">		<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">		ENLED = <span class="number">0</span>;</span><br><span class="line">		ADDR3 = <span class="number">1</span>;</span><br><span class="line">		ADDR2 = <span class="number">1</span>;</span><br><span class="line">		ADDR1 = <span class="number">1</span>;</span><br><span class="line">		ADDR0 = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) <span class="comment">// 无限循环</span></span><br><span class="line">    {</span><br><span class="line">        LED1 = <span class="number">0</span>;</span><br><span class="line">        LED2 = <span class="number">0</span>;</span><br><span class="line">        LED3 = <span class="number">0</span>;</span><br><span class="line">			</span><br><span class="line">				<span class="comment">// 延时一段时间，使LED保持熄灭状态</span></span><br><span class="line">        <span class="comment">// 可根据需要调整延时时间</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">5000</span>;i++);</span><br><span class="line">        </span><br><span class="line">        LED1 = <span class="number">1</span>;<span class="comment">// 将LED1引脚置为高电平，熄灭LED1</span></span><br><span class="line">        LED2 = <span class="number">1</span>;<span class="comment">// 将LED2引脚置为高电平，熄灭LED2</span></span><br><span class="line">        LED3 = <span class="number">1</span>;<span class="comment">// 将LED3引脚置为高电平，熄灭LED3</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 延时一段时间，使LED保持熄灭状态</span></span><br><span class="line">        <span class="comment">// 可根据需要调整延时时间</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5000</span>;i++);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<div align="center" class="aspect-ratio">
    <iframe src="https://player.bilibili.com/player.html?aid=439229886&amp;bvid=BV1sL411X7Vy&amp;cid=1072639348&amp;page=1&amp;autoplay=0&amp;autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" high_quality="1" danmaku="1" allowfullscreen="true"> 
    </iframe>
</div>
<h5 id="2-1-3-4-优化">2.1.3.4 优化</h5>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 理论，通过控制P0</span></span><br><span class="line"><span class="comment">// 通过P0</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;x; i++){</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">120</span>;j++);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	P2 = <span class="number">0xF8</span>; <span class="comment">// 1111 1000 -&gt; 0xF8</span></span><br><span class="line">	delay(<span class="number">500</span>);</span><br><span class="line">	P2 = <span class="number">0xFF</span>;</span><br><span class="line">	delay(<span class="number">500</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;x; i++){</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">120</span>;j++);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	ENLED = <span class="number">0</span>;</span><br><span class="line">	ADDR3 = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	ADDR2 = <span class="number">1</span>;</span><br><span class="line">	ADDR1 = <span class="number">1</span>;</span><br><span class="line">	ADDR0 = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	P0 = <span class="number">0xF8</span>; <span class="comment">// 1111 1000 -&gt; 0xF8</span></span><br><span class="line">	delay(<span class="number">500</span>);</span><br><span class="line">	P0 = <span class="number">0xFF</span>;</span><br><span class="line">	delay(<span class="number">500</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-1-4-流水灯">2.1.4 流水灯</h4>
<p>实现流水灯的代码我们在第一章的教学中就已经给出了，这里给出使用<code>P0</code>口实现的方式，我们知道到<code>P0</code>控制的是8个IO端口，我们使用<code>0xFF</code>等控制语句能实现控制八个端口输出不同的高低电平，那么我们来使用<code>P0</code>来实现一下。</p>
<h5 id="2-1-4-1-源码">2.1.4.1 源码</h5>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 理论</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span> {</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;t;i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">120</span>;j++);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">		P2 = <span class="number">0xFE</span>; <span class="comment">// 0xFE -&gt; 1111 1110 -&gt; 只有最右边亮</span></span><br><span class="line">		delay(<span class="number">500</span>); <span class="comment">// 延迟</span></span><br><span class="line">		P2 = <span class="number">0xFD</span>; <span class="comment">// 0xFD -&gt; 1111 1101 *********************</span></span><br><span class="line">		delay(<span class="number">500</span>); <span class="comment">// 延迟</span></span><br><span class="line">		P2 = <span class="number">0xFB</span>; <span class="comment">// 0xFB -&gt; 1111 1011</span></span><br><span class="line">		delay(<span class="number">500</span>); <span class="comment">// 延迟</span></span><br><span class="line">		P2 = <span class="number">0xF7</span>; <span class="comment">// 0xF7 -&gt; 1111 0111</span></span><br><span class="line">		delay(<span class="number">500</span>); <span class="comment">// 延迟</span></span><br><span class="line">		P2 = <span class="number">0xEF</span>; <span class="comment">// 0xEF -&gt; 1110 1111 低电平依次向右移动，控制不同的灯亮</span></span><br><span class="line">		delay(<span class="number">500</span>); <span class="comment">// 延迟</span></span><br><span class="line">		P2 = <span class="number">0xDF</span>; <span class="comment">// 0xDF -&gt; 1101 1111</span></span><br><span class="line">		delay(<span class="number">500</span>); <span class="comment">// 延迟</span></span><br><span class="line">		P2 = <span class="number">0xBF</span>; <span class="comment">// 0xBF -&gt; 1011 1111</span></span><br><span class="line">		delay(<span class="number">500</span>); <span class="comment">// 延迟</span></span><br><span class="line">		P2 = <span class="number">0x7F</span>; <span class="comment">// 0x7F -&gt; 0111 1111 **********************</span></span><br><span class="line">		delay(<span class="number">500</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="2-1-4-2-仿真">2.1.4.2 仿真</h5>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/642bcb4a6ea21b9a9ec27827.gif" alt=""></p>
<h5 id="2-1-4-3-实物">2.1.4.3 实物</h5>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;x; i++){</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">120</span>; j++);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	ENLED = <span class="number">0</span>;</span><br><span class="line">	ADDR3 = <span class="number">1</span>; <span class="comment">// 使能三八译码器</span></span><br><span class="line">	</span><br><span class="line">	ADDR2 = <span class="number">1</span>; <span class="comment">// ***************************</span></span><br><span class="line">	ADDR1 = <span class="number">1</span>; <span class="comment">// 使三八译码器IO6口输出低电平</span></span><br><span class="line">	ADDR0 = <span class="number">0</span>; <span class="comment">// ***************************</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">		P0 = <span class="number">0xFE</span>; <span class="comment">// 0xFE -&gt; 1111 1110 -&gt; 只有最右边亮</span></span><br><span class="line">		delay(<span class="number">500</span>); <span class="comment">// 延迟</span></span><br><span class="line">		P0 = <span class="number">0xFD</span>; <span class="comment">// 0xFD -&gt; 1111 1101 *********************</span></span><br><span class="line">		delay(<span class="number">500</span>); <span class="comment">// 延迟</span></span><br><span class="line">		P0 = <span class="number">0xFB</span>; <span class="comment">// 0xFB -&gt; 1111 1011</span></span><br><span class="line">		delay(<span class="number">500</span>); <span class="comment">// 延迟</span></span><br><span class="line">		P0 = <span class="number">0xF7</span>; <span class="comment">// 0xF7 -&gt; 1111 0111</span></span><br><span class="line">		delay(<span class="number">500</span>); <span class="comment">// 延迟</span></span><br><span class="line">		P0 = <span class="number">0xEF</span>; <span class="comment">// 0xEF -&gt; 1110 1111 低电平依次向右移动，控制不同的灯亮</span></span><br><span class="line">		delay(<span class="number">500</span>); <span class="comment">// 延迟</span></span><br><span class="line">		P0 = <span class="number">0xDF</span>; <span class="comment">// 0xDF -&gt; 1101 1111</span></span><br><span class="line">		delay(<span class="number">500</span>); <span class="comment">// 延迟</span></span><br><span class="line">		P0 = <span class="number">0xBF</span>; <span class="comment">// 0xBF -&gt; 1011 1111</span></span><br><span class="line">		delay(<span class="number">500</span>); <span class="comment">// 延迟</span></span><br><span class="line">		P0 = <span class="number">0x7F</span>; <span class="comment">// 0x7F -&gt; 0111 1111 **********************</span></span><br><span class="line">		delay(<span class="number">500</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="2-1-4-4-优化">2.1.4.4 优化</h5>
<p>① <code>Switch case</code></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 理论，使用switch case语句使程序更加公正</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;x; i++){</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">120</span>; j++);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i=<span class="number">1</span>; <span class="comment">//定义新的变量用来轮流调用不同的case语句</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">		<span class="keyword">switch</span>(i) {</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>: P2 = <span class="number">0xFE</span>; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>: P2 = <span class="number">0xFD</span>; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>: P2 = <span class="number">0xFB</span>; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>: P2 = <span class="number">0xF7</span>; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>: P2 = <span class="number">0xEF</span>; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">6</span>: P2 = <span class="number">0xDF</span>; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">7</span>: P2 = <span class="number">0xBF</span>; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">8</span>: P2 = <span class="number">0x7F</span>; i=<span class="number">0</span>; <span class="keyword">break</span>; <span class="comment">//小细节</span></span><br><span class="line">		}</span><br><span class="line">		i++;</span><br><span class="line">		delay(<span class="number">500</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;x; i++) {</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">120</span>; j++);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i=<span class="number">0</span>;</span><br><span class="line">	ENLED = <span class="number">0</span>;</span><br><span class="line">	ADDR3 = <span class="number">1</span>; <span class="comment">// 使能三八译码器</span></span><br><span class="line">	</span><br><span class="line">	ADDR2 = <span class="number">1</span>; <span class="comment">//*****************************</span></span><br><span class="line">	ADDR1 = <span class="number">1</span>; <span class="comment">//使三八译码器的IO6口输出低电平</span></span><br><span class="line">	ADDR0 = <span class="number">0</span>; <span class="comment">//*****************************	</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">		<span class="keyword">switch</span>(i) {</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>: P0 = <span class="number">0xFE</span>; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>: P0 = <span class="number">0xFD</span>; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>: P0 = <span class="number">0xFB</span>; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>: P0 = <span class="number">0xF7</span>; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>: P0 = <span class="number">0xEF</span>; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">6</span>: P0 = <span class="number">0xDF</span>; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">7</span>: P0 = <span class="number">0xBF</span>; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">8</span>: P0 = <span class="number">0x7F</span>; <span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">		i++;</span><br><span class="line">		delay(<span class="number">500</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>② 数组</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 理论</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1000</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">19601</span>;i++)<span class="comment">//延时1s</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">5</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">while</span>(x--)<span class="keyword">for</span>(j=<span class="number">115</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> LEDSET[<span class="number">8</span>]={<span class="number">0xFE</span>,<span class="number">0xFD</span>,<span class="number">0xFB</span>,<span class="number">0xF7</span>,<span class="number">0xEF</span>,<span class="number">0xDF</span>,<span class="number">0xBF</span>,<span class="number">0x7F</span>};</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        P0=LEDSET[i];</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">8</span>)i=<span class="number">0</span>;<span class="comment">//i需归0使P0只能使用数组中的8个元素，防止使用到超出数组元素以外的值，其实就是让i在0~7之间变化</span></span><br><span class="line">        delay_ms(<span class="number">100</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> </span></span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1000</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">19601</span>;i++)<span class="comment">//延时1s</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">5</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">while</span>(x--)<span class="keyword">for</span>(j=<span class="number">115</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> LEDSET[<span class="number">8</span>]={<span class="number">0xFE</span>,<span class="number">0xFD</span>,<span class="number">0xFB</span>,<span class="number">0xF7</span>,<span class="number">0xEF</span>,<span class="number">0xDF</span>,<span class="number">0xBF</span>,<span class="number">0x7F</span>};</span><br><span class="line">    ADDR3 = <span class="number">1</span>;<span class="comment">//使能三八译码器</span></span><br><span class="line">    ENLED = <span class="number">0</span>;<span class="comment">// </span></span><br><span class="line">   </span><br><span class="line">    ADDR2 = <span class="number">1</span>;<span class="comment">//**************************</span></span><br><span class="line">    ADDR1 = <span class="number">1</span>;<span class="comment">//让三八译码器的IO6输出低电平</span></span><br><span class="line">    ADDR0 = <span class="number">0</span>;<span class="comment">//**************************</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        P0=LEDSET[i];</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">8</span>)i=<span class="number">0</span>;<span class="comment">//i需归0使P0只能使用数组中的8个元素，防止使用到超出数组元素以外的值，其实就是让i在0~7之间变化</span></span><br><span class="line">        delay_ms(<span class="number">100</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>③ 移位</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 理论</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1000</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">19601</span>;i++)<span class="comment">//延时1s</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">5</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">while</span>(x--)<span class="keyword">for</span>(j=<span class="number">115</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        P0=~(<span class="number">0x01</span>&lt;&lt;i);<span class="comment">//第一次运行这条语句i是等于0的，先算出括号中的值：0x01左移0位还是0x01，算出了括号中的值再去取反就得0xFE,                         </span></span><br><span class="line">                      <span class="comment">//所以第一次运行这条语句时就相当于“P0=0xFE;”，第二次循环运行时i已经等于1，0x01左移1位就为0x02，取反得0xFD,所以第二次执行这条语句是“P0=0xFD;”</span></span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">8</span>)i=<span class="number">0</span>;</span><br><span class="line">        delay_ms(<span class="number">100</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> </span></span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1000</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">19601</span>;i++)<span class="comment">//延时1s</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">5</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">while</span>(x--)<span class="keyword">for</span>(j=<span class="number">115</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;  </span><br><span class="line">    ADDR3 = <span class="number">1</span>;<span class="comment">//使能三八译码器</span></span><br><span class="line">    ENLED = <span class="number">0</span>;<span class="comment">// </span></span><br><span class="line"> </span><br><span class="line">    ADDR2 = <span class="number">1</span>;<span class="comment">//**************************</span></span><br><span class="line">    ADDR1 = <span class="number">1</span>;<span class="comment">//让三八译码器的IO6输出低电平</span></span><br><span class="line">    ADDR0 = <span class="number">0</span>;<span class="comment">//**************************</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        P0=~(<span class="number">0x01</span>&lt;&lt;i);<span class="comment">//第一次运行这条语句i是等于0的，先算出括号中的值：0x01左移0位还是0x01，算出了括号中的值再去取反就得0xFE,                         </span></span><br><span class="line">                      <span class="comment">//所以第一次运行这条语句时就相当于“P0=0xFE;”，第二次循环运行时i已经等于1，0x01左移1位就为0x02，取反得0xFD,所以第二次执行这条语句是“P0=0xFD;”</span></span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">8</span>)i=<span class="number">0</span>;</span><br><span class="line">        delay_ms(<span class="number">100</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-1-4-交通灯的实现">2.1.4 交通灯的实现</h4>
<h5 id="2-1-4-1-源码">2.1.4.1 源码</h5>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 理论</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit RED1 = P2^<span class="number">0</span>; <span class="comment">//第一组红灯</span></span><br><span class="line">sbit YELLOW1 = P2^<span class="number">1</span>; <span class="comment">//第一组黄灯</span></span><br><span class="line">sbit GREEN1 = P2^<span class="number">2</span>; <span class="comment">//第一组绿灯</span></span><br><span class="line">sbit RED2 = P2^<span class="number">3</span>; <span class="comment">//第二组红灯</span></span><br><span class="line">sbit YELLOW2 = P2^<span class="number">4</span>; <span class="comment">//第二组黄灯</span></span><br><span class="line">sbit GREEN2 = P2^<span class="number">5</span>; <span class="comment">//第二组绿灯</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span> <span class="comment">//简单的延时函数</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">120</span>; j++);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//第一组绿灯，第二组红灯</span></span><br><span class="line">        GREEN1 = <span class="number">0</span>;</span><br><span class="line">        YELLOW1 = <span class="number">1</span>;</span><br><span class="line">        RED1 = <span class="number">1</span>;</span><br><span class="line">        GREEN2 = <span class="number">1</span>;</span><br><span class="line">        YELLOW2 = <span class="number">1</span>;</span><br><span class="line">        RED2 = <span class="number">0</span>; </span><br><span class="line">        delay(<span class="number">5000</span>); <span class="comment">//绿灯持续5秒钟</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一组黄灯，第二组红灯</span></span><br><span class="line">        YELLOW1 = <span class="number">0</span>;</span><br><span class="line">        GREEN1 = <span class="number">1</span>;</span><br><span class="line">        delay(<span class="number">1000</span>); <span class="comment">//黄灯持续1秒钟</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一组红灯，第二组绿灯</span></span><br><span class="line">        RED1 = <span class="number">0</span>;</span><br><span class="line">        YELLOW1 = <span class="number">1</span>;</span><br><span class="line">        GREEN1 = <span class="number">1</span>;</span><br><span class="line">        RED2 = <span class="number">1</span>;</span><br><span class="line">        YELLOW2 = <span class="number">1</span>;</span><br><span class="line">        GREEN2 = <span class="number">0</span>; </span><br><span class="line">        delay(<span class="number">5000</span>); <span class="comment">//绿灯持续5秒钟</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一组红灯，第二组黄灯</span></span><br><span class="line">        YELLOW2 = <span class="number">0</span>;</span><br><span class="line">        GREEN2 = <span class="number">1</span>;</span><br><span class="line">        delay(<span class="number">1000</span>); <span class="comment">//黄灯持续1秒钟</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<div class="note primary simple"><p>陈同学版本，主打就是一个位移，大家可以体会一下他的逻辑，注意<code>|</code>是<code>按位取或</code></p>
</div>
<div class="note primary simple"><p>注意<code>|</code>是<code>按位取或</code>,就是说有<code>1</code>取<code>1</code>，全<code>0</code>取<code>0</code></p>
</div>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;x; i++){</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">120</span>; j++);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> a,b;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line">	a = <span class="number">0xfe</span>;</span><br><span class="line">	b = <span class="number">0xfe</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">		P0 = a;</span><br><span class="line">		P1 = b;</span><br><span class="line">		delay(<span class="number">5000</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(a == <span class="number">0xfe</span>){</span><br><span class="line">			a = <span class="number">1</span>|(a &lt;&lt; <span class="number">1</span>);</span><br><span class="line">			P0 = a;</span><br><span class="line">			delay(<span class="number">3000</span>);</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(a == <span class="number">0xfd</span>){</span><br><span class="line">			a = <span class="number">1</span>|(a &lt;&lt; <span class="number">1</span>); <span class="comment">// yellow  -&gt; red</span></span><br><span class="line">			b = <span class="number">1</span>|(b &lt;&lt; <span class="number">1</span>); <span class="comment">// red -&gt; green</span></span><br><span class="line">			P0 = a;</span><br><span class="line">			P1 = b;</span><br><span class="line">			delay(<span class="number">5000</span>);</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(b == <span class="number">0xfd</span>){</span><br><span class="line">			b = <span class="number">1</span>|(b &lt;&lt; <span class="number">1</span>); <span class="comment">// green -&gt; yellow</span></span><br><span class="line">			P1 = b;</span><br><span class="line">			delay(<span class="number">3000</span>);</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(b == <span class="number">0xfb</span>){</span><br><span class="line">			a = <span class="number">0xfe</span>;</span><br><span class="line">			b = <span class="number">0xfe</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="2-1-4-2-仿真">2.1.4.2 仿真</h5>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6424292ba682492fccad052b.gif" alt=""></p>
<h4 id="2-1-5-花式流水灯">2.1.5 花式流水灯</h4>
<p>当我们想实现花式流水灯时还是需要运用到数组的，毕竟数组可以修改LED的状态值。</p>
<h5 id="2-1-5-1-右移流水灯源码">2.1.5.1 右移流水灯源码</h5>
<div class="note primary simple"><p>我将各种实现方法写在了一起，大家根据自己的需要选取</p>
</div>
<div class="note primary simple"><p>感谢陈兴龙同学提供的代码(<em>^_^</em>)</p>
</div>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 理论</span></span><br><span class="line"><span class="comment">// P0口，switch case</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;x; i++){</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">120</span>; j++);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">		<span class="keyword">switch</span>(i) {</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>: P2 = <span class="number">0x7F</span>; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>: P2 = <span class="number">0xBF</span>; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>: P2 = <span class="number">0xDF</span>; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>: P2 = <span class="number">0xEF</span>; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>: P2 = <span class="number">0xF7</span>; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">6</span>: P2 = <span class="number">0xFB</span>; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">7</span>: P2 = <span class="number">0xFD</span>; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">8</span>: P2 = <span class="number">0xFE</span>; i=<span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">		i++;</span><br><span class="line">		delay(<span class="number">500</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;x; i++){</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">120</span>; j++);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> j[<span class="number">8</span>] = {<span class="number">0x7F</span>, <span class="number">0xBF</span>, <span class="number">0xDF</span>, <span class="number">0xEF</span>, <span class="number">0xF7</span>, <span class="number">0xFB</span>,<span class="number">0xFD</span>, <span class="number">0xFE</span>};</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">		P2 = j[i];</span><br><span class="line">		delay(<span class="number">500</span>);</span><br><span class="line">		i++;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">8</span>){</span><br><span class="line">			i=<span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移位</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;x; i++){</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">120</span>; j++);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> a, b=<span class="number">10000000</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">		a = <span class="number">0x7F</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++){</span><br><span class="line">			P2 = a;</span><br><span class="line">			a = b|(a&gt;&gt;<span class="number">1</span>);</span><br><span class="line">			delay(<span class="number">500</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="2-1-5-2-循环流水灯">2.1.5.2 循环流水灯</h5>
<h5 id="2-1-5-3-奇偶流水灯">2.1.5.3 奇偶流水灯</h5>
<div class="note primary simple"><p>感谢陈兴龙同学提供的数组代码(<em>^_^</em>)</p>
</div>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 理论</span></span><br><span class="line"><span class="comment">// 移位方法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(uint x)</span></span><br><span class="line">{</span><br><span class="line">    uint i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=x;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">120</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偶数灯逐个点亮</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">even_light</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i+=<span class="number">2</span>) <span class="comment">//循环控制点亮偶数灯</span></span><br><span class="line">    {</span><br><span class="line">        P2 = ~(<span class="number">1</span>&lt;&lt;i); <span class="comment">//点亮第i个LED灯, 偶数</span></span><br><span class="line">        delay(<span class="number">500</span>); <span class="comment">//延时</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 奇数灯逐个点亮</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">odd_light</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">8</span>;i+=<span class="number">2</span>) <span class="comment">//循环控制点亮奇数灯</span></span><br><span class="line">    {</span><br><span class="line">        P2 = ~(<span class="number">1</span>&lt;&lt;i); <span class="comment">//点亮第i个LED灯，奇数</span></span><br><span class="line">        delay(<span class="number">500</span>); <span class="comment">//延时</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全部点亮然后熄灭</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">all_light</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) { </span><br><span class="line">			P2 = <span class="number">0x00</span>;</span><br><span class="line">			delay(<span class="number">500</span>); <span class="comment">//延时1s</span></span><br><span class="line">			P2 = <span class="number">0xFF</span>; <span class="comment">//全灭</span></span><br><span class="line">			delay(<span class="number">500</span>); <span class="comment">//延时</span></span><br><span class="line">		}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 奇偶逐个点亮后全灭</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">even_odd_light_out</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++){</span><br><span class="line">			P2 = ~(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">			delay(<span class="number">500</span>);</span><br><span class="line">		}</span><br><span class="line">    P2 = <span class="number">0xFF</span>; <span class="comment">//全灭</span></span><br><span class="line">    delay(<span class="number">1000</span>); <span class="comment">//延时</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) <span class="comment">//循环</span></span><br><span class="line">    {</span><br><span class="line">        even_light(); <span class="comment">// 偶数灯逐渐点亮</span></span><br><span class="line">        odd_light(); <span class="comment">// 奇数灯逐渐点亮</span></span><br><span class="line">        all_light(); <span class="comment">// 所有灯全亮</span></span><br><span class="line">        even_odd_light_out(); <span class="comment">//慢慢来</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">()</span>{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">500</span>;i&gt;<span class="number">0</span>;i--){</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">120</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">char</span> code ledj[<span class="number">4</span>]={<span class="number">0xfe</span>,<span class="number">0xfb</span>,<span class="number">0xef</span>,<span class="number">0xbf</span>};<span class="comment">//奇数灯</span></span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">char</span> code ledo[<span class="number">4</span>]={<span class="number">0xfd</span>,<span class="number">0xf7</span>,<span class="number">0xdf</span>,<span class="number">0x7f</span>};<span class="comment">//偶数灯</span></span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	 <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">		 <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line">			 P0=ledo[i];</span><br><span class="line">			 delay();</span><br><span class="line">		 }</span><br><span class="line">		 <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line">			 P0=ledj[i];</span><br><span class="line">			 delay();</span><br><span class="line">		 }</span><br><span class="line">		 <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line">			 P0=<span class="number">0x00</span>;</span><br><span class="line">			 delay();</span><br><span class="line">		   P0=<span class="number">0xff</span>;</span><br><span class="line">			 delay();</span><br><span class="line">		 }</span><br><span class="line">		 <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line">			 P0=ledj[i];</span><br><span class="line">			 delay();</span><br><span class="line">			 P0=ledo[i];</span><br><span class="line">			 delay();</span><br><span class="line">		 }</span><br><span class="line">		 P0=<span class="number">0xff</span>;</span><br><span class="line">		 delay();</span><br><span class="line">	 }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/642fdca5a682492fcc726e5d.gif" alt=""></p>
<h5 id="2-1-5-4-按键控制流水灯">2.1.5.4 按键控制流水灯</h5>
<div class="note primary simple"><p>感谢李肖坤同学提供了该部分的代码，这里需要注意不能直接写语句P3^0==0的判断</p>
</div>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际 普中开发板</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line">sbit KEY2 = P3^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延时</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">()</span>		<span class="comment">//@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"></span><br><span class="line">	i = <span class="number">39</span>;</span><br><span class="line">	j = <span class="number">230</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">while</span> (--j);</span><br><span class="line">	} <span class="keyword">while</span> (--i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span>(KEY2 == <span class="number">0</span>)		  <span class="comment">// 按下给0， 松开给1</span></span><br><span class="line">	{</span><br><span class="line">	  delay();	 <span class="comment">// 防抖20ms</span></span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span>(KEY2 == <span class="number">0</span>) {</span><br><span class="line">	  	<span class="keyword">while</span>(KEY2 == <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span>(KEY2 == <span class="number">1</span>) {</span><br><span class="line">				P2 = ~(<span class="number">0x01</span>&lt;&lt;r); <span class="comment">//移位</span></span><br><span class="line">				r++;</span><br><span class="line">				<span class="keyword">if</span>(r==<span class="number">9</span>)r=<span class="number">0</span>;</span><br><span class="line">				}</span><br><span class="line">	  }</span><br><span class="line">	}</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际 普中开发板 按键控制左右循环流水灯</span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> n=<span class="number">6</span>;</span><br><span class="line">sbit KEY2 = P3^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延时</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">()</span>		<span class="comment">//@12.000MHz</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"></span><br><span class="line">	i = <span class="number">39</span>;</span><br><span class="line">	j = <span class="number">230</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">while</span> (--j);</span><br><span class="line">	} <span class="keyword">while</span> (--i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span>(KEY2 == <span class="number">0</span>)		  <span class="comment">// 按下给0， 松开给1</span></span><br><span class="line">	{</span><br><span class="line">	  delay();	 <span class="comment">// 防抖20ms</span></span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span>(KEY2 == <span class="number">0</span>) {</span><br><span class="line">	  	<span class="keyword">while</span>(KEY2 == <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span>(KEY2 == <span class="number">1</span>) {</span><br><span class="line">			   <span class="keyword">if</span>(r&lt;<span class="number">8</span>){</span><br><span class="line">				P2 = ~(<span class="number">0x01</span>&lt;&lt;r); <span class="comment">//移位</span></span><br><span class="line">				r++;</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				{</span><br><span class="line">				   P2 = ~(<span class="number">0x01</span>&lt;&lt;n);</span><br><span class="line">				   n--;</span><br><span class="line">				   <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">				      {r=<span class="number">0</span>;</span><br><span class="line">					   n=<span class="number">6</span>;}</span><br><span class="line">				}</span><br><span class="line">				}</span><br><span class="line">	  }</span><br><span class="line">	}</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-2-蜂鸣器">2.2 蜂鸣器</h3>
<h4 id="2-2-1-蜂鸣器驱动代码">2.2.1 蜂鸣器驱动代码</h4>
<p>无源蜂鸣器的硬件连接因为不像LED那样都接了很多其他器件来初始化，所以驱动代码比较简单</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> </span></span><br><span class="line">sbit BEEP = P1^<span class="number">6</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i; </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        BEEP=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">14</span>;i++);<span class="comment">//延时接近0.125ms,给P1.6保持了0.125ms高电平时间</span></span><br><span class="line">        BEEP=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">14</span>;i++);<span class="comment">//低电平时间保持了0.125ms， 我们可以尝试把两个for语句里的14改大一点就会发现鸣叫的音调变得低沉一些了</span></span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-2-2-蜂鸣器鸣叫">2.2.2 蜂鸣器鸣叫</h4>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际 简化</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> </span></span><br><span class="line">sbit BEEP = P1^<span class="number">6</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i; </span><br><span class="line">     <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">     {</span><br><span class="line">         BEEP=!BEEP; <span class="comment">// 蜂鸣器鸣叫，通过P1.6就要以一定的时间间隔（也可叫一定频率）不停的高低电平切换。这里小细节，取非符号</span></span><br><span class="line">         <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">14</span>;i++);<span class="comment">//只需改变一次for语句中的14就可以实现不同音调的鸣叫了</span></span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<div class="note info simple"><p>这里启发我们使用LED=!LED 可以实现LED灯闪烁</p>
</div>
<h4 id="2-2-3-控制蜂鸣器">2.2.3 控制蜂鸣器</h4>
<p>我们先演示一个<code>错误代码</code>，借助于控制LED小灯亮灭的启发，我们可能写出如下的主要程序控制蜂鸣器的高低电平</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">    BEEP = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">14</span>;i++); <span class="comment">//延迟0.125ms</span></span><br><span class="line">    BEEP = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">14</span>;i++); <span class="comment">//延迟0.125ms</span></span><br><span class="line">    </span><br><span class="line">    delay(<span class="number">5000</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们简单分析以上代码，下面的图解可以看出来以上代码和上面的驱动代码的区别</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Gan1Ser/img-url@main/2022/12image-20230405002829461.png" alt="image-20230405002829461"></p>
<p>很明显使用延迟函数Delay()函数延迟控制不满足蜂鸣器的驱动条件：用时间表示就是要输出周期为<code>0.22ms~2ms（（1/4500s）~（1/500s））</code>范围的方波,这个周期内高电平时间和低电平时间各占一半。</p>
<p>那么我们要控制蜂鸣器的响与不响该如何做？</p>
<p>驱动代码之所以能一直响，是因为在<code>死循环里这些方波持续的时间无限长</code>。那么我们要让它响一段时间，就让这个方波持续着这段时间；然后把IO端口电平固定住不发生改变，无源蜂鸣器没有脉冲信号所以就不响了。这时我们再延时1秒，在这一秒里无源蜂鸣器不会响，过了这一秒之后再让IO端口持续输出一段方波时间，这时就可以再次弄响无源蜂鸣器，就这样死循环下去也就达到自己想的目的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/642c515ca682492fccdfb9e7.png" alt=""></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> </span></span><br><span class="line">sbit BEEP = P1^<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1000</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">19601</span>;i++)<span class="comment">//延时1s</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">5</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">while</span>(x--)<span class="keyword">for</span>(j=<span class="number">115</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用循环嵌套，内层循环控制蜂鸣器一直鸣叫，内层循环完成后，电平不在发生变换，蜂鸣器不在鸣叫，延迟1s钟后继续进入内层循环进行鸣叫</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i,time;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(time=<span class="number">0</span>;time&lt;<span class="number">800</span>;time++)<span class="comment">//800决定鸣叫的时长</span></span><br><span class="line">        {  </span><br><span class="line">            BEEP=!BEEP;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++);<span class="comment">//这里改为30延时长一点把鸣叫音调调低一些</span></span><br><span class="line">        }</span><br><span class="line">        delay_ms(<span class="number">1000</span>);<span class="comment">//延时1s </span></span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-2-4-蜂鸣器-led实际案例">2.2.4 蜂鸣器+LED实际案例</h4>
<p>机器报警时，灯亮的时候蜂鸣器就响，灯灭的时候就不响。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> </span></span><br><span class="line">sbit BEEP  = P1^<span class="number">6</span>; <span class="comment">// 控制蜂鸣器的高低电平</span></span><br><span class="line">sbit LED2  = P0^<span class="number">0</span>;</span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//延迟函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1000</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">19601</span>;i++)<span class="comment">//延时1s</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">5</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">while</span>(x--)<span class="keyword">for</span>(j=<span class="number">115</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i,time;</span><br><span class="line">    ADDR3 = <span class="number">1</span>;<span class="comment">//使能三八译码器</span></span><br><span class="line">    ENLED = <span class="number">0</span>;<span class="comment">// </span></span><br><span class="line">   </span><br><span class="line">    ADDR2 = <span class="number">1</span>;<span class="comment">//**************************</span></span><br><span class="line">    ADDR1 = <span class="number">1</span>;<span class="comment">//让三八译码器的IO6输出低电平</span></span><br><span class="line">    ADDR0 = <span class="number">0</span>;<span class="comment">//**************************</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        LED2=<span class="number">0</span>; <span class="comment">//灯亮，同时蜂鸣器鸣叫</span></span><br><span class="line">        <span class="keyword">for</span>(time=<span class="number">0</span>;time&lt;<span class="number">3700</span>;time++)<span class="comment">//软件调试出此处for循环用了1秒</span></span><br><span class="line">        {  </span><br><span class="line">            BEEP=!BEEP;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++);</span><br><span class="line">        }</span><br><span class="line">        BEEP=<span class="number">0</span>;<span class="comment">//固定住蜂鸣器的电平使其不响，其实这条语句也可不写，因为上面的for语句执行完就没有方波产生了也就不响了，大家可以注释掉这个语句看看现象是不是一样的</span></span><br><span class="line">        LED2=<span class="number">1</span>; <span class="comment">//蜂鸣器不响，灯灭</span></span><br><span class="line">        delay_ms(<span class="number">1000</span>);<span class="comment">//延时1s </span></span><br><span class="line">      } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-3-数码管">2.3 数码管</h3>
<h4 id="2-3-1-数码管原理">2.3.1 数码管原理</h4>
<p>pass</p>
<h4 id="2-3-2-静态数码管显示">2.3.2 静态数码管显示</h4>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示单个数字 0</span></span><br><span class="line"><span class="comment">// 理论</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">seg</span><span class="params">()</span> {</span><br><span class="line">	P2 = <span class="number">0x3F</span>; <span class="comment">//0011 1111 -&gt; 0x3F</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">	seg();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6413f387a682492fccd1d02c.gif" alt=""></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示零到九的循环</span></span><br><span class="line"><span class="comment">// 理论</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> s[] = {<span class="number">0x3F</span>, <span class="number">0x06</span>, <span class="number">0x5B</span>, <span class="number">0x4F</span>, <span class="number">0x66</span>, <span class="number">0x6D</span>, <span class="number">0x7D</span>, <span class="number">0x07</span>, <span class="number">0x7F</span>, <span class="number">0x6F</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">120</span>; j++);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">seg</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		P2 = s[i];</span><br><span class="line">		delay(<span class="number">800</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">		seg();</span><br><span class="line">	}</span><br><span class="line">		</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6413f793a682492fccdaf4e2.gif" alt=""></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际</span></span><br><span class="line"><span class="comment">// 0~F显示</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code LedChar[] = {<span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xF8</span>, <span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x83</span>, <span class="number">0xC6</span>, <span class="number">0xA1</span>, <span class="number">0x86</span>, <span class="number">0x8E</span>}; <span class="comment">// 0~F的真值表，使用code关键字使char类型LedChar放入Flash而不放入RAM，之所以放入Flash是因为我们不需要改变该真值表的值</span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> cnt = <span class="number">0</span>; <span class="comment">// 记录T0中断次数</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> sec = <span class="number">0</span>; <span class="comment">// 记录经过的秒数</span></span><br><span class="line">	</span><br><span class="line">	ENLED = <span class="number">0</span>;	<span class="comment">//使能 U3，选择数码管 DS1</span></span><br><span class="line">	ADDR3 = <span class="number">1</span>;	<span class="comment">//为 T0 赋初值 0xB800 </span></span><br><span class="line">	ADDR2 = <span class="number">0</span>;</span><br><span class="line">	ADDR1 = <span class="number">0</span>;</span><br><span class="line">	ADDR0 = <span class="number">0</span>;	<span class="comment">//启动 T0</span></span><br><span class="line">	</span><br><span class="line">	TMOD = <span class="number">0x01</span>; <span class="comment">//设置 T0 为模式 1 </span></span><br><span class="line">	TH0 = <span class="number">0xB8</span>;</span><br><span class="line">	TL0 = <span class="number">0x00</span>;</span><br><span class="line">	TR0 = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">		<span class="keyword">if</span> (TF0 == <span class="number">1</span>) { <span class="comment">//判断 T0 是否溢出</span></span><br><span class="line">			TF0 = <span class="number">0</span>;	<span class="comment">//T0 溢出后，清零中断标志 </span></span><br><span class="line">			TH0 = <span class="number">0XB8</span>;	<span class="comment">//并重新赋初值</span></span><br><span class="line">			TL0 = <span class="number">0x00</span>;</span><br><span class="line">			cnt++;	<span class="comment">//计数值自加 1 </span></span><br><span class="line">			<span class="keyword">if</span> (cnt &gt;= <span class="number">50</span>){	<span class="comment">//判断 T0 溢出是否达到 50 次</span></span><br><span class="line">				cnt = <span class="number">0</span>;	<span class="comment">//达到 50 次后计数值清零</span></span><br><span class="line">				P0 = LedChar[sec];	<span class="comment">//当前秒数对应的真值表中的值送到 P0 口 </span></span><br><span class="line">				sec++;	<span class="comment">//秒数记录自加 1</span></span><br><span class="line">				<span class="keyword">if</span> (sec &gt;= <span class="number">16</span>){	<span class="comment">//当秒数超过 0x0F(15)后，重新从 0 开始</span></span><br><span class="line">					sec = <span class="number">0</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<div align="center" class="aspect-ratio">
    <iframe src="https://player.bilibili.com/player.html?aid=441060182&amp;&amp;page=1&amp;as_wide=1&amp;high_quality=1&amp;danmaku=0&amp;autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" high_quality="1" danmaku="1" allowfullscreen="true"> 
    </iframe>
</div>
<h4 id="2-3-3-动态数码管显示">2.3.3 动态数码管显示</h4>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> str[] = {<span class="number">0x76</span>, <span class="number">0x79</span>, <span class="number">0x38</span>, <span class="number">0x38</span>, <span class="number">0x3F</span>}; <span class="comment">//HELLO 的段选</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> wei[] = {<span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x04</span>, <span class="number">0x08</span>, <span class="number">0x10</span>, <span class="number">0x20</span>, <span class="number">0x40</span>, <span class="number">0x80</span>}; <span class="comment">//共阴极的线选</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">120</span>; j++);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">seg</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) <span class="comment">// 线选为5</span></span><br><span class="line">	{</span><br><span class="line">		P3 = ~wei[i];</span><br><span class="line">		P2 = str[i];</span><br><span class="line">		delay(<span class="number">5</span>); <span class="comment">// 调小点是为了视觉残留的效果</span></span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">		seg();</span><br><span class="line">	}</span><br><span class="line">		</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6413fc94a682492fcce7fc08.gif" alt=""></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code LedChar[] = {<span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xF8</span>, <span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x83</span>, <span class="number">0xC6</span>, <span class="number">0xA1</span>, <span class="number">0x86</span>, <span class="number">0x8E</span>}; <span class="comment">// 数码管显示字符转换表表</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LedBuff[<span class="number">6</span>] = {<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>}; <span class="comment">// 数码管显示缓冲区，初值0xFF确保启动时都不亮</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;	<span class="comment">//动态扫描索引</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> cnt = <span class="number">0</span>;	<span class="comment">// 记录T0中断次数</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> sec = <span class="number">0</span>; <span class="comment">//记录经过的秒数</span></span><br><span class="line">	</span><br><span class="line">	ENLED = <span class="number">0</span>;</span><br><span class="line">	ADDR3 = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	TMOD = <span class="number">0x01</span>; <span class="comment">// 设置T0模式为1 -&gt; 0x01</span></span><br><span class="line">	TH0 = <span class="number">0xFC</span>; <span class="comment">//为T0设置初值为0xFC67，定时为1ms，TH高</span></span><br><span class="line">	TL0 = <span class="number">0x67</span>; <span class="comment">// TL低</span></span><br><span class="line">	TR0 = <span class="number">1</span>; <span class="comment">// 启动T0</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">		<span class="keyword">if</span> (TF0 == <span class="number">1</span>) { <span class="comment">// 判断T0是否溢出</span></span><br><span class="line">			TF0 = <span class="number">0</span>;</span><br><span class="line">			TH0 = <span class="number">0xFC</span>; <span class="comment">//为T0重新赋值0xFC67</span></span><br><span class="line">			TL0 = <span class="number">0x67</span>;</span><br><span class="line">			cnt++; <span class="comment">//计数器自加1</span></span><br><span class="line">			<span class="keyword">if</span> (cnt &gt;= <span class="number">1000</span>) { <span class="comment">// 判断T0溢出是否达到1000次</span></span><br><span class="line">				cnt = <span class="number">0</span>; <span class="comment">// 达到1000次后计数值清零</span></span><br><span class="line">				sec++; <span class="comment">// 秒计数加1</span></span><br><span class="line">				<span class="comment">// 以下代码将sec按十进制位从低到高依次提取并转为数码管显示字符</span></span><br><span class="line">				LedBuff[<span class="number">0</span>] = LedChar[sec%<span class="number">10</span>];</span><br><span class="line">				LedBuff[<span class="number">1</span>] = LedChar[sec/<span class="number">10</span>%<span class="number">10</span>];</span><br><span class="line">				LedBuff[<span class="number">2</span>] = LedChar[sec/<span class="number">100</span>%<span class="number">10</span>];</span><br><span class="line">				LedBuff[<span class="number">3</span>] = LedChar[sec/<span class="number">1000</span>%<span class="number">10</span>];</span><br><span class="line">				LedBuff[<span class="number">4</span>] = LedChar[sec/<span class="number">10000</span>%<span class="number">10</span>];</span><br><span class="line">				LedBuff[<span class="number">5</span>] = LedChar[sec/<span class="number">100000</span>%<span class="number">10</span>];</span><br><span class="line">			}</span><br><span class="line">			<span class="comment">// 以下代码完成数码管动态扫描刷新</span></span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span>){</span><br><span class="line">				ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">0</span>; i++; P0 = LedBuff[<span class="number">0</span>];</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) {</span><br><span class="line">				ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">1</span>; i++; P0 = LedBuff[<span class="number">1</span>];</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) {</span><br><span class="line">				ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">1</span>; ADDR0 = <span class="number">0</span>; i++; P0 = LedBuff[<span class="number">2</span>];</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">3</span>) {</span><br><span class="line">				ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">1</span>; ADDR0 = <span class="number">1</span>; i++; P0 = LedBuff[<span class="number">3</span>];</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">4</span>) {</span><br><span class="line">				ADDR2 = <span class="number">1</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">0</span>; i++; P0 = LedBuff[<span class="number">4</span>];</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">5</span>) {</span><br><span class="line">				ADDR2 = <span class="number">1</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">1</span>; i = <span class="number">0</span>; P0 = LedBuff[<span class="number">5</span>];</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<div align="center" class="aspect-ratio">
    <iframe src="https://player.bilibili.com/player.html?aid=781144915&amp;&amp;page=1&amp;as_wide=1&amp;high_quality=1&amp;danmaku=0&amp;autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" high_quality="1" danmaku="1" allowfullscreen="true"> 
    </iframe>
</div>
<h4 id="2-3-4-4只数码管滚动显示0-3">2.3.4 4只数码管滚动显示0~3</h4>
<h5 id="2-3-4-1-源码">2.3.4.1 源码</h5>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 理论</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数码管段选信号数组</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code digit[<span class="number">4</span>] = {<span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x04</span>, <span class="number">0x08</span>};</span><br><span class="line"><span class="comment">// 显示数字数组</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code num[<span class="number">4</span>] = {<span class="number">0x3F</span>, <span class="number">0x06</span>, <span class="number">0x5B</span>, <span class="number">0x4F</span>};</span><br><span class="line"><span class="comment">// 定义计数器</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = xms; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">110</span>; j &gt; <span class="number">0</span>; j--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">		<span class="comment">// 定义计数器循环控制变量i</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环控制变量j</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 定义数码管位选信号P2口为输出</span></span><br><span class="line">    P3 = <span class="number">0xff</span>;</span><br><span class="line">    <span class="comment">// 定义数码管段选信号P0口为输出</span></span><br><span class="line">    P2 = <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 如果j等于4，则将j赋值为0，继续从0开始</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">4</span>)</span><br><span class="line">        {</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 将数码管位选信号设置为第j位</span></span><br><span class="line">        P3 = ~digit[j];</span><br><span class="line">        <span class="comment">// 将数码管段选信号设置为对应数字</span></span><br><span class="line">        P2 = num[count % <span class="number">4</span>];</span><br><span class="line">        <span class="comment">// 延时200ms</span></span><br><span class="line">        delay(<span class="number">200</span>);</span><br><span class="line">        <span class="comment">// 计数器加1</span></span><br><span class="line">        count++;</span><br><span class="line">				<span class="comment">// 循环控制变量j每次加1</span></span><br><span class="line">				j++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="2-3-4-2-仿真">2.3.4.2 仿真</h5>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6422f37ea682492fcc0f0189.gif" alt=""></p>
<h4 id="2-3-5-8只数码管滚动显示8-f">2.3.5 8只数码管滚动显示8~F</h4>
<h5 id="2-3-5-1-源码">2.3.5.1 源码</h5>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数码管段选信号数组</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code digit[<span class="number">8</span>] = {<span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x04</span>, <span class="number">0x08</span>, <span class="number">0x10</span>, <span class="number">0x20</span>, <span class="number">0x40</span>, <span class="number">0x80</span>};</span><br><span class="line"><span class="comment">// 显示数字数组</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code num[<span class="number">8</span>] = {<span class="number">0x7F</span>, <span class="number">0x6F</span>, <span class="number">0x77</span>, <span class="number">0x7C</span>, <span class="number">0x39</span>, <span class="number">0x5E</span>, <span class="number">0x79</span>, <span class="number">0x71</span>};</span><br><span class="line"><span class="comment">// 定义计数器</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = xms; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">110</span>; j &gt; <span class="number">0</span>; j--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">  <span class="comment">// 定义计数器循环控制变量i</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环控制变量j</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 定义数码管位选信号P2口为输出</span></span><br><span class="line">    P3 = <span class="number">0xff</span>;</span><br><span class="line">    <span class="comment">// 定义数码管段选信号P0口为输出</span></span><br><span class="line">    P2 = <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 如果j等于4，则将j赋值为0，继续从0开始,count也负值为0；</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">8</span>)</span><br><span class="line">        {</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">			count = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 将数码管位选信号设置为第j位</span></span><br><span class="line">        P3 = ~digit[j];</span><br><span class="line">        <span class="comment">// 将数码管段选信号设置为对应数字</span></span><br><span class="line">        P2 = num[count];</span><br><span class="line">        <span class="comment">// 延时200ms</span></span><br><span class="line">        delay(<span class="number">200</span>);</span><br><span class="line">        <span class="comment">// 计数器加1</span></span><br><span class="line">        count++;</span><br><span class="line">				<span class="comment">// 循环控制变量j每次加1</span></span><br><span class="line">				j++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="2-3-5-2-仿真">2.3.5.2 仿真</h5>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/64230880a682492fcc366767.gif" alt=""></p>
<h4 id="2-3-6-8只数码管显示不同字符">2.3.6 8只数码管显示不同字符</h4>
<h5 id="2-3-6-1-源码">2.3.6.1 源码</h5>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 理论</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数码管段选信号数组</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code digit[<span class="number">8</span>] = {<span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x04</span>, <span class="number">0x08</span>, <span class="number">0x10</span>, <span class="number">0x20</span>, <span class="number">0x40</span>, <span class="number">0x80</span>};</span><br><span class="line"><span class="comment">// 显示数字数组</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code num[<span class="number">8</span>] = {<span class="number">0x7F</span>, <span class="number">0x6F</span>, <span class="number">0x77</span>, <span class="number">0x7C</span>, <span class="number">0x39</span>, <span class="number">0x5E</span>, <span class="number">0x79</span>, <span class="number">0x71</span>};</span><br><span class="line"><span class="comment">// 定义计数器</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = xms; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">110</span>; j &gt; <span class="number">0</span>; j--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">  <span class="comment">// 定义计数器循环控制变量i</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 定义数码管位选信号P2口为输出</span></span><br><span class="line">    P3 = <span class="number">0xff</span>;</span><br><span class="line">    <span class="comment">// 定义数码管段选信号P0口为输出</span></span><br><span class="line">    P2 = <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">				<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++){</span><br><span class="line">					<span class="comment">// 将数码管位选信号设置为第j位</span></span><br><span class="line">					P3 = ~digit[i];</span><br><span class="line">					<span class="comment">// 将数码管段选信号设置为对应数字</span></span><br><span class="line">					P2 = num[i];</span><br><span class="line">					<span class="comment">// 延时5ms</span></span><br><span class="line">					delay(<span class="number">5</span>); <span class="comment">// 延时够短，人眼分辨不出来就行</span></span><br><span class="line">				}</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="2-3-6-2-仿真">2.3.6.2 仿真</h5>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6423c4dca682492fcc194167.gif" alt=""></p>
<h3 id="2-4-独立按键">2.4 独立按键</h3>
<h4 id="2-4-1-按下按键led小灯亮">2.4.1 按下按键LED小灯亮</h4>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">sbit KEY4 = P2^<span class="number">7</span>;</span><br><span class="line">sbit GND = P2^<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	ENLED = <span class="number">0</span>;</span><br><span class="line">	ADDR3 = <span class="number">1</span>; <span class="comment">// 使能三八译码器</span></span><br><span class="line">	</span><br><span class="line">	ADDR2 = <span class="number">1</span>;<span class="comment">//*****************************</span></span><br><span class="line">	ADDR1 = <span class="number">1</span>;<span class="comment">//使三八译码器的IO6口输出低电平</span></span><br><span class="line">	ADDR0 = <span class="number">0</span>;<span class="comment">//*****************************</span></span><br><span class="line">	</span><br><span class="line">	GND = <span class="number">0</span>; <span class="comment">//使P2.7能具备被拉低的条件</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">		P0 = KEY4*<span class="number">0xFF</span>; <span class="comment">//很有意思，这里独立按键就好像输出0(按下按键)和1(松开按键)一样</span></span><br><span class="line">		<span class="comment">// 0时8个小灯全亮(0x00)，1时全灭(0xff)</span></span><br><span class="line">		<span class="comment">//P0 = ~(KEY4*0xFF)</span></span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<div align="center" class="aspect-ratio">
    <iframe src="https://player.bilibili.com/player.html?bvid=BV1b84y1T7Ap&amp;page=1&amp;autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" high_quality="1" danmaku="1" allowfullscreen="true"> 
    </iframe>
</div>
<h4 id="2-4-2-按键按下蜂鸣器鸣响">2.4.2 按键按下蜂鸣器鸣响</h4>
<p>使用无源蜂鸣器，按键按下时，蜂鸣器就响，松开不按时就不响。我们知道<code>在P2^3输出低电平的情况下，K4按下的时候程序钟KEY4等于0，松开不按时KEY4等于1</code>。所以我们想要实现目的，可以在主函数中的死循环中用<code>if(KEY4==0)</code>来一直等待<code>K4</code>被按下，于是KEY4的值等于0才能进入if语句钟执行程序。不按下时<code>KEY4等于1</code>就不能进入执行程序，CPU之只能执行空循环。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit BEEP = P1^<span class="number">6</span>;</span><br><span class="line">sbit KEY4 = P2^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">	P2 = <span class="number">0xF7</span>; <span class="comment">//让K4具备有被拉低的条件 -&gt;1111 0111 -&gt; P2^3输出低电平</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">		<span class="keyword">if</span>(KEY4 == <span class="number">0</span>) {</span><br><span class="line">			BEEP = !BEEP;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">25</span>; i++); <span class="comment">//不同时间的延时鸣叫的音调不同</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<div align="center" class="aspect-ratio">
    <iframe src="https://player.bilibili.com/player.html?aid=867173357&amp;bvid=BV1BV4y1f76n&amp;cid=1087827885&amp;page=1&amp;autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" high_quality="1" danmaku="1" allowfullscreen="true"> 
    </iframe>
</div>
<h4 id="2-4-3-测试-按键按下时p2-7的状态-持续的时间到底是多长">2.4.3 测试“按键按下时P2.7的状态”持续的时间到底是多长</h4>
<p>“按键按下时P2.7的状态”持续的时间到底是多长，用流水灯的方式来查看按下之后迅速松开，小灯会跳到哪里显示。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">sbit KEY4 = P2^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;x; i++) {</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">120</span>; j++);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">1</span>;</span><br><span class="line">	ENLED = <span class="number">0</span>;</span><br><span class="line">	ADDR3 = <span class="number">1</span>; <span class="comment">//使能三八译码器</span></span><br><span class="line">	</span><br><span class="line">	ADDR2 = <span class="number">1</span>;<span class="comment">//*****************************</span></span><br><span class="line">	ADDR1 = <span class="number">1</span>;<span class="comment">//使三八译码器的IO6口输出低电平</span></span><br><span class="line">	ADDR0 = <span class="number">0</span>;<span class="comment">//*****************************</span></span><br><span class="line">	</span><br><span class="line">	P2 = <span class="number">0xF7</span>;<span class="comment">//使P2^7具备被拉低的条件</span></span><br><span class="line">	P0 = <span class="number">0xFE</span>;<span class="comment">//先点亮最右端的小灯</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">		<span class="keyword">if</span>(KEY4 == <span class="number">0</span>) {</span><br><span class="line">			delay(<span class="number">10</span>);</span><br><span class="line">			P0 = ~(<span class="number">0x01</span>&lt;&lt;i);</span><br><span class="line">			i++;</span><br><span class="line">			<span class="keyword">if</span>(i&gt;=<span class="number">8</span>)i=<span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>根据dotcpp网站的测试得出一下结论：<code>即使手速再怎么快地按下K4马上松开，可在这段时间里点亮的LED2跳到了LED5点亮，也就是说按键在物理上的导通时间超过了30ms</code>后面i绝对大于3，因为LED5亮，所以有“P0=0xF7;”推出“ ~(0x01&lt;&lt;3)”，然后再有“i++;”，i绝对大于3。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/643142c60d2dde577786f63d.png" alt=""></p>
<p><code>P2.7在按键动作中被拉低的持续时间就有60~90ms</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/643143610d2dde577788b149.png" alt=""></p>
<h4 id="2-4-4-按键控制灯亮灯灭">2.4.4 按键控制灯亮灯灭</h4>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际 大家会发现这种方法是存在缺陷的</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">sbit KEY4 = P2^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">sbit LED = P0^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;x; i++) {</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">120</span>; j++);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	ENLED = <span class="number">0</span>;</span><br><span class="line">	ADDR3 = <span class="number">1</span>; <span class="comment">//使能三八译码器</span></span><br><span class="line">	</span><br><span class="line">	ADDR2 = <span class="number">1</span>; <span class="comment">//*************************</span></span><br><span class="line">	ADDR1 = <span class="number">1</span>; <span class="comment">//使三八译码器IO6输出低电平</span></span><br><span class="line">	ADDR0 = <span class="number">0</span>; <span class="comment">//*************************</span></span><br><span class="line">	</span><br><span class="line">	P2 = <span class="number">0xF7</span>; <span class="comment">//使KEY4具备被拉低的条件</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">		<span class="keyword">if</span>(KEY4 == <span class="number">0</span>) {</span><br><span class="line">			delay(<span class="number">50</span>); <span class="comment">//延迟50ms</span></span><br><span class="line">			<span class="keyword">if</span>(KEY4 == <span class="number">0</span>) { <span class="comment">//在此判断，如果仍为0就说明是稳定态的按下0</span></span><br><span class="line">				<span class="comment">// 执行代码</span></span><br><span class="line">				LED = !LED; <span class="comment">// 每进入一次都将改变一次LED的状态，而进入需要判断KEY4的状态，实现按键控制LED。</span></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可是每个人的按键手速不同，我们发现如果按下的时间稍微长一点（没松手），那么LED2就会闪烁，也就是“LED2=!LED2;”被多次执行，要是刻意快速按下就松手，LED2没反应，所以这样的代码是做不到普遍通用的。还有我们用50ms做延时太影响CPU的运行效率了，所以我们要引入<code>支持连按</code>和<code>不支持连按</code>的按键概念。</p>
<h4 id="2-4-5-不支持连按模式">2.4.5 不支持连按模式</h4>
<p>基于1.7.5节的分析，我们可以使用以下代码实现不支持连按模式。可以发现无论我们的按下手速有多快或多慢，“ LED2=!LED2;”只能被执行一次而已。这样就像按电磁炉上的按键一样，一次只能切换一回灯的亮灭，即使不松手也不会出现灯的闪烁，这就是不支持连按的代码书写方式，不过这样的代码还是存在缺陷</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">sbit LED = P0^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">sbit KEY4 = P2^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1000</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">19601</span>;i++)<span class="comment">//延时1s</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">5</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">while</span>(x--)<span class="keyword">for</span>(j=<span class="number">115</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    ENLED = <span class="number">0</span>;</span><br><span class="line">    ADDR3 = <span class="number">1</span>; <span class="comment">// 使能三八译码器</span></span><br><span class="line">    </span><br><span class="line">    ADDR2 = <span class="number">1</span>; <span class="comment">//************************</span></span><br><span class="line">    ADDR1 = <span class="number">1</span>; <span class="comment">//使三八译码器的IO6口输出低电平</span></span><br><span class="line">    ADDR0 = <span class="number">0</span>; <span class="comment">//************************</span></span><br><span class="line">    </span><br><span class="line">    P2 = <span class="number">0xF7</span>; <span class="comment">//使P2^7具备能被拉低的条件</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">if</span>(KEY4 == <span class="number">0</span>) {</span><br><span class="line">            delay_ms(<span class="number">10</span>); <span class="comment">//等待抖动过去</span></span><br><span class="line">            <span class="keyword">if</span> (KEY4 == <span class="number">0</span>) { <span class="comment">//二次判断</span></span><br><span class="line">                LED = !LED;</span><br><span class="line">                <span class="keyword">while</span>(KEY4 == <span class="number">0</span>); <span class="comment">//如果IO端口还是保持低电平，此时也就是没有松手，那</span></span><br><span class="line">				<span class="comment">//括号里的条件满足，程序一直在循环这条语句，所以程序停止不往下执行了，</span></span><br><span class="line">				<span class="comment">//直到KEY4等于1，也就是按键松手了，while里面的条件不成立才退出循环，放行程序</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>改善我们的代码</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际 金沙滩工作室开发板 按下松开后小灯左移</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">sbit LED = P0^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">sbit KEY4 = P2^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1000</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">19601</span>;i++)<span class="comment">//延时1s</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">5</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">while</span>(x--)<span class="keyword">for</span>(j=<span class="number">115</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> key_up=<span class="number">1</span>; <span class="comment">//定义记录按键状态值的变量，初始值为1是为了</span></span><br><span class="line">	<span class="comment">// 避免程序一开始就进入if(key_up==0)</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	ENLED = <span class="number">0</span>;</span><br><span class="line">	ADDR3 = <span class="number">1</span>; <span class="comment">//使能三八译码器</span></span><br><span class="line">	</span><br><span class="line">	ADDR2 = <span class="number">1</span>; <span class="comment">//***************************</span></span><br><span class="line">	ADDR1 = <span class="number">1</span>; <span class="comment">//使三八译码器IO6口输出低电平 </span></span><br><span class="line">	ADDR0 = <span class="number">0</span>; <span class="comment">//***************************</span></span><br><span class="line">	</span><br><span class="line">	P2 = <span class="number">0xF7</span>; <span class="comment">//使P2^7具备能被拉低的条件</span></span><br><span class="line">	P0 = <span class="number">0xFE</span>; <span class="comment">//先点亮LED灯</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">		<span class="keyword">if</span>(key_up == <span class="number">0</span>) {</span><br><span class="line">			<span class="keyword">if</span>(KEY4 == <span class="number">1</span>) { <span class="comment">// 只要不松手，KEY4就会等于零, 只要在按键抬起之后才执行功能代码</span></span><br><span class="line">				P0 = ~(<span class="number">0x01</span>&lt;&lt;i);</span><br><span class="line">				i++;</span><br><span class="line">				<span class="keyword">if</span>(i&gt;=<span class="number">8</span>)i=<span class="number">0</span>;</span><br><span class="line">			}	</span><br><span class="line">		}</span><br><span class="line">		key_up = KEY4; <span class="comment">//如果不松手，key_up就会等于0 </span></span><br><span class="line">		delay_ms(<span class="number">2</span>); <span class="comment">//假设这部分是要执行的其他程序</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际 金沙滩工作室单片机 按下小灯左移 松开不变</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">sbit LED = P0^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">sbit KEY4 = P2^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1000</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">19601</span>;i++)<span class="comment">//延时1s</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">5</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">while</span>(x--)<span class="keyword">for</span>(j=<span class="number">115</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> key_up=<span class="number">0</span>; <span class="comment">//定义记录按键状态值的变量，初始值为0是为了</span></span><br><span class="line">	<span class="comment">// 避免程序一开始就进入if(key_up==0)</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	ENLED = <span class="number">0</span>;</span><br><span class="line">	ADDR3 = <span class="number">1</span>; <span class="comment">//使能三八译码器</span></span><br><span class="line">	</span><br><span class="line">	ADDR2 = <span class="number">1</span>; <span class="comment">//***************************</span></span><br><span class="line">	ADDR1 = <span class="number">1</span>; <span class="comment">//使三八译码器IO6口输出低电平 </span></span><br><span class="line">	ADDR0 = <span class="number">0</span>; <span class="comment">//***************************</span></span><br><span class="line">	</span><br><span class="line">	P2 = <span class="number">0xF7</span>; <span class="comment">//使P2^7具备能被拉低的条件</span></span><br><span class="line">	P0 = <span class="number">0xFE</span>; <span class="comment">//先点亮LED灯</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">		<span class="keyword">if</span>(key_up == <span class="number">1</span>) {</span><br><span class="line">			<span class="keyword">if</span>(KEY4 == <span class="number">0</span>) { <span class="comment">// 只要不松手，KEY4就会等于零, 只要在按键抬起之后才执行功能代码</span></span><br><span class="line">				P0 = ~(<span class="number">0x01</span>&lt;&lt;i);</span><br><span class="line">				i++;</span><br><span class="line">				<span class="keyword">if</span>(i&gt;=<span class="number">8</span>)i=<span class="number">0</span>;</span><br><span class="line">			}	</span><br><span class="line">		}</span><br><span class="line">		key_up = KEY4; <span class="comment">//如果不松手，key_up就会等于0 </span></span><br><span class="line">		delay_ms(<span class="number">2</span>); <span class="comment">//假设这部分是要执行的其他程序</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际 金沙滩工作室 按键控制左右移流水灯</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">sbit LED = P0^<span class="number">0</span>;</span><br><span class="line">sbit KEY4 = P2^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;x; i++) {</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">120</span>; j++);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> key_up = <span class="number">0</span>; <span class="comment">//key_up用于监控KEY4的状态，初值0是为了避免直接进入if(key_up==1)</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> mask = <span class="number">10000000</span>; <span class="comment">//掩码</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">0x7F</span>;</span><br><span class="line">	</span><br><span class="line">	ENLED = <span class="number">0</span>;</span><br><span class="line">	ADDR3 = <span class="number">1</span>; <span class="comment">//使能三八译码器</span></span><br><span class="line">	</span><br><span class="line">	ADDR2 = <span class="number">1</span>; <span class="comment">//*****************************</span></span><br><span class="line">	ADDR1 = <span class="number">1</span>; <span class="comment">//使是三八译码器IO6口输出低电平</span></span><br><span class="line">	ADDR0 = <span class="number">0</span>; <span class="comment">// ****************************</span></span><br><span class="line">	</span><br><span class="line">	LED = <span class="number">0</span>; <span class="comment">//事先点亮一个LED</span></span><br><span class="line">	P2 = <span class="number">0xF7</span>; <span class="comment">//使P2^7具有能被拉低的条件</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">		<span class="keyword">if</span>(key_up == <span class="number">1</span>) {</span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">15</span>){</span><br><span class="line">					i = <span class="number">1</span>;</span><br><span class="line">					a = <span class="number">0x7F</span>;</span><br><span class="line">				}</span><br><span class="line">			<span class="keyword">if</span>(KEY4 == <span class="number">0</span>) {</span><br><span class="line">				<span class="keyword">if</span>(i &lt; <span class="number">8</span>){</span><br><span class="line">					P0 = ~(<span class="number">0x01</span> &lt;&lt; i);</span><br><span class="line">					i++;</span><br><span class="line">				} <span class="comment">// 左移</span></span><br><span class="line">				<span class="keyword">else</span>{</span><br><span class="line">					a = mask|(a &gt;&gt; <span class="number">1</span>);</span><br><span class="line">					P0 = a;</span><br><span class="line">					i++;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		key_up = KEY4;</span><br><span class="line">		delay(<span class="number">50</span>);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-4-6-回归按键">2.4.6 回归按键</h4>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际 回归按键 使用static静态变量关键字</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">sbit KEY4 = P2^<span class="number">7</span>;</span><br><span class="line">sbit LED2 = P0^<span class="number">0</span>;</span><br><span class="line"><span class="comment">// 延迟函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;x; i++) {</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">120</span>; j++);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY_task</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> key_up=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(key_up==<span class="number">0</span>)</span><br><span class="line">    {      </span><br><span class="line">        <span class="keyword">if</span>(KEY4==<span class="number">1</span>)<span class="comment">//不支持连按</span></span><br><span class="line">        {</span><br><span class="line">            LED2 = !LED2;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    key_up=KEY4;   <span class="comment">//如果不松手，key_up就会等于0 </span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	ENLED = <span class="number">0</span>;</span><br><span class="line">	ADDR3 = <span class="number">1</span>; <span class="comment">//使能三八译码器</span></span><br><span class="line">	</span><br><span class="line">	ADDR2 = <span class="number">1</span>; <span class="comment">//*****************************</span></span><br><span class="line">	ADDR1 = <span class="number">1</span>; <span class="comment">//使三八译码器的IO6口输出低电平</span></span><br><span class="line">	ADDR0 = <span class="number">0</span>; <span class="comment">//*****************************</span></span><br><span class="line">	</span><br><span class="line">	P2 = <span class="number">0xF7</span>; <span class="comment">//使P2^7具备被拉低的条件</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">		KEY_task(); <span class="comment">// 按键功能任务</span></span><br><span class="line">		delay_ms(<span class="number">2</span>); <span class="comment">// 这里可以放其他程序</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-4-7-支持连按">2.4.7 支持连按</h4>
<p>这次我们把数码管显示的内容代码封装成函数，定义一个全局变量cnt，cnt在主函数中通过按键动作来改变这个值，然后数码管负责显示这个数；实验现象就是按着K4不放，数码管显示cnt的值一直累加。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">sbit KEY4 = P2^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code LedChar[<span class="number">16</span>] = {<span class="number">0xC0</span>,<span class="number">0xF9</span>,<span class="number">0xA4</span>,<span class="number">0xB0</span>,<span class="number">0x99</span>,<span class="number">0x92</span>,<span class="number">0x82</span>,<span class="number">0xF8</span>,<span class="number">0x80</span>,<span class="number">0x90</span>,<span class="number">0x88</span>,<span class="number">0x83</span>,<span class="number">0xC6</span>,<span class="number">0xA1</span>,<span class="number">0x86</span>,<span class="number">0x8E</span>}; <span class="comment">//数码管状态值初始化</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LedBuff[<span class="number">6</span>] = {<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>}; <span class="comment">//数码管显示缓存区</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> cnt = <span class="number">0</span>; <span class="comment">//可以在SEG_task()和main中使用的全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SEG_task</span><span class="params">()</span> <span class="comment">//数码管显示函数</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> i=<span class="number">0</span>;</span><br><span class="line">	LedBuff[<span class="number">0</span>] = LedChar[cnt%<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">if</span>(cnt&gt;=<span class="number">10</span>)LedBuff[<span class="number">1</span>] = LedChar[(cnt/<span class="number">10</span>)%<span class="number">10</span>]; <span class="comment">//cnt没有达到10之前不更新LedBuff[1]的初始值</span></span><br><span class="line">	<span class="keyword">if</span>(cnt&gt;=<span class="number">100</span>)LedBuff[<span class="number">2</span>] = LedChar[(cnt/<span class="number">100</span>)%<span class="number">10</span>]; <span class="comment">//cnt没有达到100之前不更新LedBuff[2]的初始值</span></span><br><span class="line">	<span class="keyword">if</span>(cnt==<span class="number">0</span>){ </span><br><span class="line">		LedBuff[<span class="number">1</span>] = <span class="number">0xFF</span>; </span><br><span class="line">		LedBuff[<span class="number">2</span>] = <span class="number">0xFF</span>;</span><br><span class="line">	} <span class="comment">//cnt到达255之后再加1就溢出变为0了，这时候要再次熄灭这两个数码管</span></span><br><span class="line">	</span><br><span class="line">	P0 = <span class="number">0xFF</span>; <span class="comment">// 端口状态全部熄灭数码管里的LED达到刷新作用</span></span><br><span class="line">	<span class="keyword">switch</span>(i) {</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>: ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">0</span>; P0 = LedBuff[<span class="number">0</span>]; i++; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>: ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">1</span>; P0= LedBuff[<span class="number">1</span>]; i++; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>: ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">1</span>; ADDR0 = <span class="number">0</span>; P0 = LedBuff[<span class="number">2</span>]; i=<span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> key_up=<span class="number">1</span>;<span class="comment">//定义记录按键状态值的变量,初始值为1避免程序一开始就进入了“if(key_up==0)”</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  times=<span class="number">0</span>; <span class="comment">//用来记录进入过按键判断语句的次数</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>;<span class="comment">//使能三八译码器</span></span><br><span class="line">    ENLED = <span class="number">0</span>;<span class="comment">// </span></span><br><span class="line">   </span><br><span class="line">    ADDR2 = <span class="number">1</span>;<span class="comment">//**************************</span></span><br><span class="line">    ADDR1 = <span class="number">1</span>;<span class="comment">//让三八译码器的IO6输出低电平</span></span><br><span class="line">    ADDR0 = <span class="number">0</span>;<span class="comment">//**************************</span></span><br><span class="line">    P2 = <span class="number">0xF7</span>;<span class="comment">//让K4能具备有被拉低的条件先</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    { </span><br><span class="line">        SEG_task();<span class="comment">//数码管显示任务</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//按键功能部分</span></span><br><span class="line">        <span class="keyword">if</span>(key_up==<span class="number">0</span>)</span><br><span class="line">        {      </span><br><span class="line">            <span class="keyword">if</span>(KEY4==<span class="number">0</span>)         <span class="comment">//之前“KEY4==1”是不支持连按，现在改为“KEY4==0”就成为支持连按了</span></span><br><span class="line">            {</span><br><span class="line">                times++;</span><br><span class="line">                <span class="keyword">if</span>(times&gt;=<span class="number">1000</span>) <span class="comment">//按键IO端口一直是低电平times就一直累加，累加到1000意味低电平持续了一段时间了，该执行功能代码了,修改1000这个数的话那么cnt自加的速度就会改变</span></span><br><span class="line">                {</span><br><span class="line">                    times=<span class="number">0</span>;</span><br><span class="line">                    cnt++;      <span class="comment">//执行功能代码</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        key_up=KEY4;            <span class="comment">//如果不松手，key_up就会等于0  </span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-4-8-优化不支持连按的代码">2.4.8 优化不支持连按的代码</h4>
<p>在<code>按键不支持连按</code>即<code>2.4.5</code>节的代码中，死循环都有<code>delay_ms(2);\delay(2)</code>,因为大多数时候主循环都要做很多事，所以我们认为这2ms的延时是很多复杂程序要执行所消耗的时间，而正是因为这个延时函数的存在把按键的物理抖动给滤掉了，误导了我们以为这样的不支持连按代码是合格的。如果我们还是用这种写法去实现不支持连按功能，那么请把下面的代码下载进开发板通过<code>快按</code>和<code>慢按</code>K4，观察数码管的显示。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> </span></span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line">  </span><br><span class="line">sbit LED2  = P0^<span class="number">0</span>;</span><br><span class="line">sbit KEY4  = P2^<span class="number">7</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code LedChar[<span class="number">16</span>]={<span class="number">0xC0</span>,<span class="number">0xF9</span>,<span class="number">0xA4</span>,<span class="number">0xB0</span>,<span class="number">0x99</span>,<span class="number">0x92</span>,<span class="number">0x82</span>,<span class="number">0xF8</span>,<span class="number">0x80</span>,<span class="number">0x90</span>,<span class="number">0x88</span>,<span class="number">0x83</span>,<span class="number">0xC6</span>,<span class="number">0xA1</span>,<span class="number">0x86</span>,<span class="number">0x8E</span>};<span class="comment">//数码管状态值初始化</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LedBuff[<span class="number">6</span>]={<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>}; <span class="comment">// 数码管缓冲</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> cnt=<span class="number">0</span>;<span class="comment">//可以在SEG_task()和main()中使用的全局变量</span></span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">SEG_task</span><span class="params">()</span><span class="comment">//数码管显示函数</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> i=<span class="number">0</span>;</span><br><span class="line">    LedBuff[<span class="number">0</span>]= LedChar[cnt%<span class="number">10</span>];   </span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;=<span class="number">10</span>) LedBuff[<span class="number">1</span>]= LedChar[(cnt/<span class="number">10</span>)%<span class="number">10</span>]; <span class="comment">//cnt没到达10之前不更新LedBuff[1]的初始值</span></span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;=<span class="number">100</span>)LedBuff[<span class="number">2</span>]= LedChar[(cnt/<span class="number">100</span>)%<span class="number">10</span>];<span class="comment">//cnt没到达100之前不更新LedBuff[2]的初始值</span></span><br><span class="line">    <span class="keyword">if</span>(cnt==<span class="number">0</span>){ LedBuff[<span class="number">1</span>]=<span class="number">0xFF</span>;LedBuff[<span class="number">2</span>]=<span class="number">0XFF</span>; }<span class="comment">//cnt到达255之后再加1就溢出变为0了，这时候要再次熄灭这两个数码管</span></span><br><span class="line">   </span><br><span class="line">    P0=<span class="number">0xFF</span>;</span><br><span class="line">    <span class="keyword">switch</span>(i)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;ADDR1 = <span class="number">0</span>;ADDR0 = <span class="number">0</span>;P0=LedBuff[<span class="number">0</span>];i++;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;ADDR1 = <span class="number">0</span>;ADDR0 = <span class="number">1</span>;P0=LedBuff[<span class="number">1</span>];i++;<span class="keyword">break</span>;     </span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;ADDR1 = <span class="number">1</span>;ADDR0 = <span class="number">0</span>;P0=LedBuff[<span class="number">2</span>];i=<span class="number">0</span>;<span class="keyword">break</span>;  </span><br><span class="line">    }  </span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> key_up=<span class="number">1</span>;<span class="comment">//定义记录按键状态值的变量,初始值为1避免程序一开始就进入了“if(key_up==0)”</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  times=<span class="number">0</span>; <span class="comment">//用来记录进入过按键判断语句的次数</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>;<span class="comment">//使能三八译码器</span></span><br><span class="line">    ENLED = <span class="number">0</span>;<span class="comment">// </span></span><br><span class="line">   </span><br><span class="line">    ADDR2 = <span class="number">1</span>;<span class="comment">//**************************</span></span><br><span class="line">    ADDR1 = <span class="number">1</span>;<span class="comment">//让三八译码器的IO6输出低电平</span></span><br><span class="line">    ADDR0 = <span class="number">0</span>;<span class="comment">//**************************</span></span><br><span class="line">    P2 = <span class="number">0xF7</span>;<span class="comment">//让K4能具备有被拉低的条件先</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    { </span><br><span class="line">        SEG_task();<span class="comment">//数码管显示任务</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//按键功能部分</span></span><br><span class="line">        <span class="keyword">if</span>(key_up==<span class="number">0</span>)</span><br><span class="line">        {      </span><br><span class="line">            <span class="keyword">if</span>(KEY4==<span class="number">1</span>)<span class="comment">//按键已弹起</span></span><br><span class="line">            {</span><br><span class="line">                cnt++; <span class="comment">//执行功能代码</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        key_up=KEY4;   <span class="comment">//如果不松手，key_up就会等于0    </span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们多按几次，会发现有时抬起之后cnt就被加2了或者更多，也就是在一次按键的动作里<code>cnt++;</code>被执行了两次，这是因为<code>SEG_task();</code>的执行时间太短<code>没有滤掉按键的抖动</code>，大家再次对照下图自己分析</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/643523e00d2dde57777f75e1.png" alt=""></p>
<p>有了<code>支持连按</code>的代码思路，实现消抖还是很容易的，我们同样用上times记录按键IO端口进入低电平的时间，<code>只要times大于500</code>证明抖动的时间已经过去，此时再判断按键是否抬起就可以决定该不该执行功能代码了。很有意思</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> </span></span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line">  </span><br><span class="line">sbit LED2  = P0^<span class="number">0</span>;</span><br><span class="line">sbit KEY4  = P2^<span class="number">7</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code LedChar[<span class="number">16</span>]={<span class="number">0xC0</span>,<span class="number">0xF9</span>,<span class="number">0xA4</span>,<span class="number">0xB0</span>,<span class="number">0x99</span>,<span class="number">0x92</span>,<span class="number">0x82</span>,<span class="number">0xF8</span>,<span class="number">0x80</span>,<span class="number">0x90</span>,<span class="number">0x88</span>,<span class="number">0x83</span>,<span class="number">0xC6</span>,<span class="number">0xA1</span>,<span class="number">0x86</span>,<span class="number">0x8E</span>};<span class="comment">//数码管状态值初始化</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LedBuff[<span class="number">6</span>]={<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>}; <span class="comment">// 数码管缓冲</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> cnt=<span class="number">0</span>;<span class="comment">//可以在SEG_task()和main()中使用的全局变量</span></span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">SEG_task</span><span class="params">()</span><span class="comment">//数码管显示函数</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> i=<span class="number">0</span>;</span><br><span class="line">    LedBuff[<span class="number">0</span>]= LedChar[cnt%<span class="number">10</span>];   </span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;=<span class="number">10</span>) LedBuff[<span class="number">1</span>]= LedChar[(cnt/<span class="number">10</span>)%<span class="number">10</span>]; <span class="comment">//cnt没到达10之前不更新LedBuff[1]的初始值</span></span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;=<span class="number">100</span>)LedBuff[<span class="number">2</span>]= LedChar[(cnt/<span class="number">100</span>)%<span class="number">10</span>];<span class="comment">//cnt没到达100之前不更新LedBuff[2]的初始值</span></span><br><span class="line">    <span class="keyword">if</span>(cnt==<span class="number">0</span>){ LedBuff[<span class="number">1</span>]=<span class="number">0xFF</span>;LedBuff[<span class="number">2</span>]=<span class="number">0XFF</span>; }<span class="comment">//cnt到达255之后再加1就溢出变为0了，这时候要再次熄灭这两个数码管</span></span><br><span class="line">   </span><br><span class="line">    P0=<span class="number">0xFF</span>;</span><br><span class="line">    <span class="keyword">switch</span>(i)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;ADDR1 = <span class="number">0</span>;ADDR0 = <span class="number">0</span>;P0=LedBuff[<span class="number">0</span>];i++;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;ADDR1 = <span class="number">0</span>;ADDR0 = <span class="number">1</span>;P0=LedBuff[<span class="number">1</span>];i++;<span class="keyword">break</span>;     </span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;ADDR1 = <span class="number">1</span>;ADDR0 = <span class="number">0</span>;P0=LedBuff[<span class="number">2</span>];i=<span class="number">0</span>;<span class="keyword">break</span>;  </span><br><span class="line">    }  </span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> key_up=<span class="number">1</span>;<span class="comment">//定义记录按键状态值的变量,初始值为1避免程序一开始就进入了“if(key_up==0)”</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  times=<span class="number">0</span>; <span class="comment">//用来记录进入过按键判断语句的次数</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>;<span class="comment">//使能三八译码器</span></span><br><span class="line">    ENLED = <span class="number">0</span>;<span class="comment">// </span></span><br><span class="line">   </span><br><span class="line">    ADDR2 = <span class="number">1</span>;<span class="comment">//**************************</span></span><br><span class="line">    ADDR1 = <span class="number">1</span>;<span class="comment">//让三八译码器的IO6输出低电平</span></span><br><span class="line">    ADDR0 = <span class="number">0</span>;<span class="comment">//**************************</span></span><br><span class="line">    P2 = <span class="number">0xF7</span>;<span class="comment">//让K4能具备有被拉低的条件先</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    { </span><br><span class="line">        SEG_task();<span class="comment">//数码管显示任务</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>  times=<span class="number">0</span>; <span class="comment">//用来记录进入过按键判断语句的次数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//按键功能部分</span></span><br><span class="line">        <span class="keyword">if</span>(key_up==<span class="number">0</span>)</span><br><span class="line">        {      </span><br><span class="line">            times++;     </span><br><span class="line">            <span class="keyword">if</span>(times&gt;=<span class="number">500</span>&amp;&amp;KEY4==<span class="number">1</span>)<span class="comment">//低电平持续够一定的时间了，证明抖动时间已经过去了，如果现在按键已经抬起就执行功能代码</span></span><br><span class="line">            {</span><br><span class="line">                times=<span class="number">0</span>;</span><br><span class="line">                cnt++;<span class="comment">//执行功能代码  </span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        key_up=KEY4; <span class="comment">//如果不松手，key_up就会等于0 </span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-4-9-双模式函数封装">2.4.9 双模式函数封装</h4>
<hr>
<ul>
<li>题目</li>
</ul>
<p>我们用最左端的数码管来提示此时的K4是<code>支持连按</code>还是<code>不支持连按</code>，这个数码管显示0的时候不支持连按，显示1的时候支持连按。</p>
<p>用K3来切换按键模式，K3的按键模式是不支持连按的，按下松开就是把K4切换为另一种按键模式。</p>
<p>然后我们通过按K4，同样<code>右边的3个数码管显示cnt</code>的值，支持连按时，按下不放就一直自动累加，不支持连按时，按下松开才累加1。</p>
<hr>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">sbit LED2 = P0^<span class="number">0</span>;</span><br><span class="line">sbit KEY4 = P2^<span class="number">7</span>;</span><br><span class="line">sbit KEY3 = P2^<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code LedChar[<span class="number">16</span>] = {<span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xF8</span>, <span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x83</span>, <span class="number">0xC6</span>, <span class="number">0xA1</span>, <span class="number">0x86</span>, <span class="number">0x8E</span>}; <span class="comment">//数码管状态值初始化</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LedBuff[<span class="number">6</span>] = {<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>}; <span class="comment">// 数码管显示缓存区,全局变量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> cnt; <span class="comment">//在KEY_task()和SEG_task()里用</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SEG_task</span><span class="params">()</span> { <span class="comment">// 数码管显示函数</span></span><br><span class="line">	<span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 调整数码管的数字</span></span><br><span class="line">	LedBuff[<span class="number">0</span>] = LedChar[cnt%<span class="number">10</span>]; <span class="comment">// 个位</span></span><br><span class="line">	<span class="keyword">if</span>(cnt&gt;=<span class="number">10</span>) LedBuff[<span class="number">1</span>] = LedChar[(cnt/<span class="number">10</span>)%<span class="number">10</span>]; <span class="comment">//cnt没到达10之前不更新LedBuff[1]的初始值 十位</span></span><br><span class="line">	<span class="keyword">if</span>(cnt&gt;=<span class="number">100</span>) LedBuff[<span class="number">2</span>] = LedChar[(cnt/<span class="number">100</span>)%<span class="number">10</span>]; <span class="comment">//cnt没到达100之前不更新LedBuff[2]的初始值 百位</span></span><br><span class="line">	<span class="keyword">if</span>(cnt==<span class="number">0</span>){ LedBuff[<span class="number">1</span>] = <span class="number">0xFF</span>; LedBuff[<span class="number">2</span>] = <span class="number">0xFF</span>;} <span class="comment">//cnt达到255之后在加1就溢出变为0了，这时候再次熄灭这两个数码管</span></span><br><span class="line">	</span><br><span class="line">	P0 = <span class="number">0xFF</span>; <span class="comment">//端口状态全部熄灭数码管里的LED达到刷新作用</span></span><br><span class="line">	<span class="keyword">switch</span>(i) {</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>: ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">0</span>; P0 = LedBuff[<span class="number">0</span>]; i++; <span class="keyword">break</span>; <span class="comment">//线选数码管0，并显示数字</span></span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>: ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">1</span>; P0 = LedBuff[<span class="number">1</span>]; i++; <span class="keyword">break</span>; <span class="comment">//线选数码管1，并显示数字</span></span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>: ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">1</span>; ADDR0 = <span class="number">0</span>; P0 = LedBuff[<span class="number">2</span>]; i++; <span class="keyword">break</span>; <span class="comment">//线选数码管2，并显示数字</span></span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>: ADDR2 = <span class="number">1</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">1</span>; P0 = LedBuff[<span class="number">5</span>]; i=<span class="number">0</span>; <span class="keyword">break</span>; <span class="comment">//线选数码管5，并显示按键模式对应的数字</span></span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY_task</span><span class="params">()</span> { <span class="comment">//按键按下所需要执行的任务</span></span><br><span class="line">	cnt++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY_mode</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> mode)</span> {</span><br><span class="line">	<span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> key_up = <span class="number">1</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> times = <span class="number">0</span>; <span class="comment">//用来记录进入过按键判断语句的次数，可以拿来防抖</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(key_up == <span class="number">0</span>) {</span><br><span class="line">		times++;</span><br><span class="line">		<span class="keyword">if</span>(mode == <span class="number">1</span> &amp;&amp; times &gt;= <span class="number">1000</span>) <span class="comment">//mode等于1，该部分代码是用来实现支持连按的，1000是为了让连按速度没那么快，如果改为500， 那么连按速度将加快</span></span><br><span class="line">		{</span><br><span class="line">			times = <span class="number">0</span>;</span><br><span class="line">			KEY_task();</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(mode == <span class="number">0</span> &amp;&amp; times &gt;=<span class="number">500</span>) <span class="comment">// mode等于0，该部分代码是用来实现不支持连按的，这里的times起到消抖的作用</span></span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span>(KEY4 == <span class="number">1</span>) { <span class="comment">// 按键已抬起</span></span><br><span class="line">				times = <span class="number">0</span>;</span><br><span class="line">				KEY_task();</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	key_up = KEY4; <span class="comment">//如果不松手，key_up就会等于0</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> mode = <span class="number">0</span>; <span class="comment">//初始时是不支持连按</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> key_up = <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> times = <span class="number">0</span>; <span class="comment">//用来记录进入过按键判断语句的次数</span></span><br><span class="line">			</span><br><span class="line">	ENLED = <span class="number">0</span>;</span><br><span class="line">	ADDR3 = <span class="number">1</span>; <span class="comment">//使能三八译码器</span></span><br><span class="line">	</span><br><span class="line">	P2 = <span class="number">0xF7</span>; <span class="comment">//使K3, K4具有能被拉低的条件</span></span><br><span class="line">	LedBuff[<span class="number">5</span>] = LedChar[mode]; <span class="comment">//填充好数码管5要显示的按键模式参数</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">		SEG_task(); <span class="comment">// 数码管显示函数</span></span><br><span class="line">		KEY_mode(mode); <span class="comment">// K4的执行函数，计数器cnt的加法</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 以下是K3按键的功能代码</span></span><br><span class="line">		<span class="keyword">if</span>(key_up == <span class="number">0</span>) {</span><br><span class="line">			times++;</span><br><span class="line">			<span class="keyword">if</span>(KEY3 == <span class="number">1</span> &amp;&amp; times &gt;= <span class="number">500</span>) {</span><br><span class="line">				times = <span class="number">0</span>;</span><br><span class="line">				mode = !mode; <span class="comment">//非0及1</span></span><br><span class="line">				LedBuff[<span class="number">5</span>] = LedChar[mode]; <span class="comment">// 用来显示此时的K4是否支持连按，显示0表示不支持，显示1表示支持</span></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		key_up = KEY3;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-4-10-综合案例">2.4.10 综合案例</h4>
<p>综合案例结合以上所学的知识，针对<code>数码管\LED</code>、<code>蜂鸣器</code>、<code>按键</code>的知识，模拟得分的过程。</p>
<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"><span class="code">	假设两个人完掷硬币游戏，游戏规则如下</span></span><br><span class="line"><span class="code">	A和B各持一枚硬币</span></span><br><span class="line"><span class="code">	两人都出正面时：A得3块钱</span></span><br><span class="line"><span class="code">	两人都出反面时：A得1块钱</span></span><br><span class="line"><span class="code">	两人出一正一反时：B得2块钱</span></span><br><span class="line"><span class="code">思路：</span></span><br><span class="line"><span class="code">	这样做模拟，程序的开始定义两个全局变量A和B初始化为30，意为每人各持30块钱用来显示在左右端的两个数码管上(3/3)，A的钱显示在左边的数码管，B的钱显示在右边的数码管。我们用K13作为给A加3块钱的同时也给B减3块的功能。用K14作为给A加1块钱的同时也给B减1块的功能。用K15作为给A减2块钱的同时给B加2块的功能。三个按键都是不支持连按！(你也可以自由发挥搞一个封装玩玩)</span></span><br><span class="line"><span class="code">	规定谁先赢得45元时就算胜利，游戏结束。比如A的钱到达或超过45块钱时，B的钱就不显示了，这两个数码管熄灭，如果是B的钱到达或超过45块时，A的钱就不显示了。游戏结束蜂鸣器鸣响。蜂鸣器就间隔鸣叫，鸣叫的时候所有数码管熄灭，不鸣叫的时候就只有4个数码管亮着，数码管呈现间隔显示，蜂鸣器间隔鸣叫。要想重新开始游戏必须复位开发板重启！</span></span><br><span class="line"><span class="code">开发板细节：</span></span><br><span class="line"><span class="code">	1. 初始化LedBuff[]数组的时候第2和第3号元素为0xBF，让数码管2和数码管3显示中间那一杠。</span></span><br><span class="line"><span class="code">	2. 死循环执行完一次循环的时间比以往的例程要多，所以times的判断我们只需要它超过300即可。</span></span><br><span class="line"><span class="code">	3. 因为用上了3个按键，每个按键功能被封装为一个函数了，所以我们定义了一个宏“#define  TIMES  300”，3个按键的函数判断times时，只需书写“if(times&gt;=TIMES&amp;&amp;KEYxx==1)”即可，以后我们写的代码死循环里比这次的例程执行一遍循环的时间还长的话，把宏改为比300还小的数就可以了。</span></span><br><span class="line"><span class="code">	4. 模拟掷骰子，使用python吧，比较简单</span></span><br><span class="line"><span class="code">	5. 不要放弃。</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际 金沙滩开发板</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMES 300 <span class="comment">// 该程序主函数循环一次所要花费的时间比以往的长，所以times设置为300</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">sbit BEEP = P1^<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">sbit KEY13 = P2^<span class="number">4</span>;</span><br><span class="line">sbit KEY14 = P2^<span class="number">5</span>;</span><br><span class="line">sbit KEY15 = P2^<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数码管状态初始化</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code LedChar[<span class="number">16</span>] = {<span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>,<span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xF8</span>, <span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x83</span>, <span class="number">0xC6</span>, <span class="number">0xA1</span>, <span class="number">0x86</span>, <span class="number">0x8E</span>};</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LedBuff[<span class="number">6</span>] = {<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xBF</span>, <span class="number">0xBF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>}; <span class="comment">//数码管缓冲区</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> A = <span class="number">30</span>; <span class="comment">//初始化A和B的钱</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> C = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UPDATE_LED</span><span class="params">()</span> { <span class="comment">//更新数码管显示缓存区</span></span><br><span class="line">	LedBuff[<span class="number">5</span>] = LedChar[A/<span class="number">10</span>];</span><br><span class="line">	LedBuff[<span class="number">4</span>] = LedChar[A%<span class="number">10</span>];</span><br><span class="line">	LedBuff[<span class="number">1</span>] = LedChar[C/<span class="number">10</span>];</span><br><span class="line">	LedBuff[<span class="number">0</span>] = LedChar[C%<span class="number">10</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SEG_task</span><span class="params">()</span> { <span class="comment">// 数码管显示函数</span></span><br><span class="line">	<span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line">	P0 = <span class="number">0xFF</span>;</span><br><span class="line">	<span class="keyword">switch</span>(i) {</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>: ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">0</span>; P0 = LedBuff[<span class="number">0</span>]; i++; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>: ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">1</span>; P0 = LedBuff[<span class="number">1</span>]; i++; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>: ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">1</span>; ADDR0 = <span class="number">0</span>; P0 = LedBuff[<span class="number">2</span>]; i++; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>: ADDR2 = <span class="number">0</span>; ADDR1 = <span class="number">1</span>; ADDR0 = <span class="number">1</span>; P0 = LedBuff[<span class="number">3</span>]; i++; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>: ADDR2 = <span class="number">1</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">0</span>; P0 = LedBuff[<span class="number">4</span>]; i++; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>: ADDR2 = <span class="number">1</span>; ADDR1 = <span class="number">0</span>; ADDR0 = <span class="number">1</span>; P0 = LedBuff[<span class="number">5</span>]; i=<span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY13_task</span><span class="params">()</span> { <span class="comment">// K13按键作用</span></span><br><span class="line">	<span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> key_up = <span class="number">1</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> times = <span class="number">0</span>; <span class="comment">//用来记录进入过按键判断语句的次数</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(key_up == <span class="number">0</span>) {</span><br><span class="line">		times++;</span><br><span class="line">		<span class="keyword">if</span>(KEY13 == <span class="number">1</span> &amp;&amp; times &gt;= TIMES) {</span><br><span class="line">			times = <span class="number">0</span>;</span><br><span class="line">			A += <span class="number">3</span>; <span class="comment">// A的钱加3元</span></span><br><span class="line">			C -= <span class="number">3</span>; <span class="comment">// B的钱减3元</span></span><br><span class="line">			UPDATE_LED(); <span class="comment">//更新数码管显示缓存区</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	key_up = KEY13;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY14_task</span><span class="params">()</span> { <span class="comment">//KEY13按键任务</span></span><br><span class="line">	<span class="type">static</span> <span class="type">unsigned</span> key_up = <span class="number">1</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> times = <span class="number">0</span>; <span class="comment">//用来记录进入过按键判断语句的次数</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(key_up == <span class="number">0</span>) {</span><br><span class="line">		times++;</span><br><span class="line">		<span class="keyword">if</span>(KEY14 == <span class="number">1</span> &amp;&amp; times &gt;= TIMES) {</span><br><span class="line">			times = <span class="number">0</span>;</span><br><span class="line">			A += <span class="number">1</span>; <span class="comment">//A的钱加1</span></span><br><span class="line">			C -= <span class="number">1</span>; <span class="comment">//B的钱减1</span></span><br><span class="line">			UPDATE_LED(); <span class="comment">// 更新数码管缓存区</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	key_up = KEY14;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY15_task</span><span class="params">()</span> { <span class="comment">// 按键15的任务</span></span><br><span class="line">	<span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> key_up = <span class="number">1</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> times = <span class="number">0</span>; <span class="comment">//用来记录进入过按键判断的次数</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(key_up == <span class="number">0</span>) {</span><br><span class="line">		times++;</span><br><span class="line">		<span class="keyword">if</span>(KEY15 == <span class="number">1</span> &amp;&amp; times &gt;= TIMES) {</span><br><span class="line">			times = <span class="number">0</span>;</span><br><span class="line">			A -= <span class="number">2</span>; <span class="comment">//A的钱减2</span></span><br><span class="line">			C += <span class="number">2</span>; <span class="comment">//B的钱加2</span></span><br><span class="line">			UPDATE_LED(); <span class="comment">//更新数码管缓存区</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	key_up = KEY15;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BEEP_ON</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x)</span> { <span class="comment">//游戏结束蜂鸣器鸣叫</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i, time;</span><br><span class="line">	<span class="keyword">for</span>(time = <span class="number">0</span>; time &lt; <span class="number">2000</span>; time++) { <span class="comment">//time&lt;2000决定鸣叫的时间</span></span><br><span class="line">		<span class="keyword">if</span>(x == <span class="number">1</span>)BEEP = !BEEP; <span class="comment">//x=1表明游戏结束</span></span><br><span class="line">		<span class="keyword">else</span> BEEP = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">30</span>; i++);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i, x; <span class="comment">//做循环和延时用</span></span><br><span class="line">	</span><br><span class="line">	ENLED = <span class="number">0</span>;</span><br><span class="line">	ADDR3 = <span class="number">1</span>; <span class="comment">//使能三八译码器</span></span><br><span class="line">	</span><br><span class="line">	P2 = <span class="number">0xFE</span>; <span class="comment">//使KEY13,KEY14, KEY15具备能被拉低的条件</span></span><br><span class="line">	UPDATE_LED(); <span class="comment">//初始化数码管缓存区</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">		SEG_task(); <span class="comment">// 数码管显示函数</span></span><br><span class="line">		KEY13_task(); <span class="comment">//KEY13按键的任务</span></span><br><span class="line">		KEY14_task(); <span class="comment">// KEY14按键的任务</span></span><br><span class="line">		KEY15_task(); <span class="comment">//KEY15按键的任务</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//游戏结束要完成的任务</span></span><br><span class="line">		<span class="keyword">if</span>(A&gt;=<span class="number">45</span> || C &gt;= <span class="number">45</span>) { <span class="comment">// 只要其中一方的钱达到45块以上就结束游戏，程序进入死循环</span></span><br><span class="line">			<span class="keyword">if</span>(A&gt;=<span class="number">45</span>) {</span><br><span class="line">				LedBuff[<span class="number">1</span>] = <span class="number">0xFF</span>;</span><br><span class="line">				LedBuff[<span class="number">0</span>] = <span class="number">0xFF</span>; <span class="comment">// A赢得比赛，B的钱不再显示</span></span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span> {</span><br><span class="line">				LedBuff[<span class="number">5</span>] = <span class="number">0xFF</span>;</span><br><span class="line">				LedBuff[<span class="number">4</span>] = <span class="number">0xFF</span>; <span class="comment">//B赢得比赛，A的钱不再显示</span></span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">				P0 = <span class="number">0xFF</span>; <span class="comment">//熄灭所有数码管</span></span><br><span class="line">				BEEP_ON(<span class="number">1</span>); <span class="comment">// 蜂鸣器鸣叫一段时间</span></span><br><span class="line">				<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">300</span>; i++) { <span class="comment">//让数码管显示一段时间</span></span><br><span class="line">					SEG_task(); <span class="comment">//数码管显示函数</span></span><br><span class="line">					<span class="keyword">for</span>(x = <span class="number">0</span>; x &lt; <span class="number">200</span>; x++); <span class="comment">//加此延时是为了让数码管显示亮亿点点，不然只循环数码管显示函数，显示就会暗一些</span></span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模拟掷硬币</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">coin_toss_simulation</span>(<span class="params">num_trials</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_trials):</span><br><span class="line">        player_1_coin = random.randint(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        player_2_coin = random.randint(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'[%d %d] '</span>%(player_1_coin, player_2_coin), end=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试代码，模拟10次硬币正反面</span></span><br><span class="line">coin_toss_simulation(<span class="number">50</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-5-多模块编程">2.5 多模块编程</h3>
<p>多模块编程非常方便，博主看很多教程都写<code>#include &lt;function.h&gt;</code>，但是我这边建议，我们自己写的头文件最好是用<code>""</code>表示，由下面的代码我们可以简单理解为由<code>function.h</code>建立了main.c文件与function.c的联系。针对里面一些新的定义和简洁函数详情见第第三章第3.5节</p>
<p>文件只需要将<code>function.c</code>和<code>main.c</code>加入即可</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际 金沙滩开发板 main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"function.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{  </span><br><span class="line">    u16 i,x,NUM=<span class="number">12345</span>;</span><br><span class="line">    LED_Init();<span class="comment">//初始化LED硬件模块</span></span><br><span class="line">     </span><br><span class="line">    LED2=<span class="number">0</span>;LED9=<span class="number">0</span>;</span><br><span class="line">    delay_ms(<span class="number">100</span>);</span><br><span class="line">    LED3=<span class="number">0</span>;LED8=<span class="number">0</span>;</span><br><span class="line">    delay_ms(<span class="number">100</span>);</span><br><span class="line">    LED4=<span class="number">0</span>;LED7=<span class="number">0</span>;</span><br><span class="line">    delay_ms(<span class="number">100</span>);</span><br><span class="line">    LED5=<span class="number">0</span>;LED6=<span class="number">0</span>;</span><br><span class="line">    delay_ms(<span class="number">100</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5000</span>;i++)<span class="comment">//蜂鸣器响一下</span></span><br><span class="line">    {</span><br><span class="line">        BEEP=!BEEP;</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;x&lt;<span class="number">30</span>;x++);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    ShowNumber(NUM);<span class="comment">//更新缓存区的内容，首次显示12345在数码管上</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {     </span><br><span class="line">        SEG_Scan();</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">8000</span>)<span class="comment">//隔一段时间更新数码管显示的内容</span></span><br><span class="line">        {</span><br><span class="line">            i=<span class="number">0</span>;</span><br><span class="line">            ShowNumber(NUM++);</span><br><span class="line">        }   </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际 金沙滩开发板 function.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"function.h"</span></span></span><br><span class="line">  </span><br><span class="line">u8 code LedChar[<span class="number">16</span>]={<span class="number">0xC0</span>,<span class="number">0xF9</span>,<span class="number">0xA4</span>,<span class="number">0xB0</span>,<span class="number">0x99</span>,<span class="number">0x92</span>,<span class="number">0x82</span>,<span class="number">0xF8</span>,<span class="number">0x80</span>,<span class="number">0x90</span>,<span class="number">0x88</span>,<span class="number">0x83</span>,<span class="number">0xC6</span>,<span class="number">0xA1</span>,<span class="number">0x86</span>,<span class="number">0x8E</span>};<span class="comment">//数码管状态值初始化</span></span><br><span class="line">u8 LedBuff[<span class="number">6</span>]={<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>};<span class="comment">//初始化数码管显示缓存区</span></span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(u16 x)</span></span><br><span class="line">{</span><br><span class="line">    u16 i,j;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1000</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">19601</span>;i++)<span class="comment">//延时1s</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">5</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">while</span>(x--)<span class="keyword">for</span>(j=<span class="number">115</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    P1|=<span class="number">0x0E</span>;<span class="comment">//让P1.1，P1.2，P1.3强制输出1</span></span><br><span class="line">    P1&amp;=<span class="number">0xEE</span>;<span class="comment">//让P1.0和P1.4强制输出0</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SEG_Scan</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">static</span> u8 i = <span class="number">0</span>;     </span><br><span class="line">    P0 = <span class="number">0xFF</span>;            <span class="comment">//端口状态全部熄灭数码管里的LED达到刷新作用</span></span><br><span class="line">    P1 = (P1 &amp; <span class="number">0xF8</span>) | i; <span class="comment">//i等于0时，就是“ADDR2=0; ADDR1=0; ADDR0=0;”，i等于1时，就是“ADDR2=0; ADDR1=0; ADDR0=1;”，以此类推</span></span><br><span class="line">    P0 = LedBuff[i];      <span class="comment">//6个缓冲区的值轮流赋给P0</span></span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=<span class="number">6</span>)i=<span class="number">0</span>;          <span class="comment">//让i在0~5之间循环变化</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowNumber</span><span class="params">(u32 num)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> i;<span class="comment">//取值范围-128~127</span></span><br><span class="line">    u8 buf[<span class="number">6</span>];    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)    <span class="comment">//把长整型数转换为6位十进制的数组</span></span><br><span class="line">    {</span><br><span class="line">        buf[i] = num % <span class="number">10</span>;</span><br><span class="line">        num = num / <span class="number">10</span>;    <span class="comment">//舍掉个位数，重新装载</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">5</span>; i&gt;=<span class="number">1</span>; i--)   <span class="comment">//从最高位起，遇到0填充不显示的代码，遇到非0则退出循环</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (buf[i] == <span class="number">0</span>)</span><br><span class="line">            LedBuff[i] = <span class="number">0xFF</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> ( ; i&gt;=<span class="number">0</span>; i--)     <span class="comment">//剩余低位都如实转换为数码管显示字符</span></span><br><span class="line">    {</span><br><span class="line">        LedBuff[i] = LedChar[buf[i]];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际 金沙滩开发板 function.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _function_h_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _function_h_</span></span><br><span class="line">  </span><br><span class="line">sbit BEEP  = P1^<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">sbit LED2  = P0^<span class="number">0</span>;</span><br><span class="line">sbit LED3  = P0^<span class="number">1</span>;</span><br><span class="line">sbit LED4  = P0^<span class="number">2</span>;</span><br><span class="line">sbit LED5  = P0^<span class="number">3</span>;</span><br><span class="line">sbit LED6  = P0^<span class="number">4</span>;</span><br><span class="line">sbit LED7  = P0^<span class="number">5</span>;</span><br><span class="line">sbit LED8  = P0^<span class="number">6</span>;</span><br><span class="line">sbit LED9  = P0^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>  u8;   <span class="comment">//对数据类型进行声明定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>  u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> u32;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span>  u8 LedBuff[<span class="number">6</span>];       <span class="comment">//对数码管缓存区进行外部声明</span></span><br><span class="line"><span class="keyword">extern</span>  u8 code LedChar[<span class="number">16</span>]; <span class="comment">//对数码管真值表进行外部声明</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//只要在“function.c”文件中封装有的函数都需要在头文件中声明一下</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(u16 x)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SEG_Scan</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowNumber</span><span class="params">(u32 num)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6438062c0d2dde5777a3bbf1.png" alt=""></p>
<h4 id="2-5-1-带返回值的函数-不支持连按的按键">2.5.1 带返回值的函数（不支持连按的按键）</h4>
<p>之前封装的函数都是void类型无返回值的函数。随着学习的深入，我们需要把C语言的精髓学到家。</p>
<p>前面讲的<code>function.c</code>中没有提及过按键的函数封装。按键功能函数都需要定义全局变量，这种过多的使用全局变量是编程的大忌。随着我们使用按键越来越灵活，就不是简单的让一两个变量加加减减而已了，所以现在我们要更加的去贴合嵌入式编程的方式，那么按键的使用如果用函数封装的话，需要用到函数返回值的相关知识。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"function.h"</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TIMES 1000 <span class="comment">//死循环里的代码量少，所以把阈值调大些</span></span></span><br><span class="line"></span><br><span class="line">sbit KEY4 = P2^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">KEY_Scan</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">static</span> u8 key_up = <span class="number">1</span>;</span><br><span class="line">    <span class="type">static</span> u16 times;</span><br><span class="line">    <span class="keyword">if</span>(key_up == <span class="number">0</span>) {</span><br><span class="line">        times++;</span><br><span class="line">        <span class="keyword">if</span>(KEY4 == <span class="number">1</span> &amp;&amp; times &gt;= TIMES) {</span><br><span class="line">            times = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    key_up = KEY4;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() {</span><br><span class="line">    u8 key; <span class="comment">//用来读取按键动作的返回值</span></span><br><span class="line">    LED_Init(); <span class="comment">//初始化LED硬件模块</span></span><br><span class="line">    P2 = <span class="number">0xF7</span>; <span class="comment">//让K4具备能被拉低的条件</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        key=KEY4_Scan();</span><br><span class="line">        <span class="keyword">if</span>(key==<span class="number">1</span>)LED2=!LED2;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-5-2-支持连按的按键">2.5.2 支持连按的按键</h4>
<p>实验现象就是按着按键不放，那么“key=1;”出现的频率就会比不支持连按代码的时候多，所以就会有左右不断流水的现象</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;function.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMES 2000 <span class="comment">//让流速慢一点</span></span></span><br><span class="line">sbit KEY4 = P2^<span class="number">7</span>;</span><br><span class="line"> </span><br><span class="line">u8 <span class="title function_">KEY4_Scan</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">static</span> u8 key_up=<span class="number">1</span>;</span><br><span class="line">    <span class="type">static</span> u16 times;</span><br><span class="line">    <span class="keyword">if</span>(key_up==<span class="number">0</span>)</span><br><span class="line">    {      </span><br><span class="line">        times++;   </span><br><span class="line">        <span class="keyword">if</span>(times&gt;=TIMES)</span><br><span class="line">        {</span><br><span class="line">            times=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        } </span><br><span class="line">    }</span><br><span class="line">    key_up=KEY4;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{  </span><br><span class="line">    u8 key;     <span class="comment">//用来读取按键动作的返回值</span></span><br><span class="line">    u8 i=<span class="number">0</span>,dir; <span class="comment">//dir是作为切换流水方向</span></span><br><span class="line">    LED_Init(); <span class="comment">//初始化LED硬件模块</span></span><br><span class="line">    P2=<span class="number">0xF7</span>;    <span class="comment">//让K4能具备有被拉低的条件先</span></span><br><span class="line">    P0=<span class="number">0xFE</span>;    <span class="comment">//先点亮LED2</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {      </span><br><span class="line">        key=KEY4_Scan();</span><br><span class="line">        <span class="keyword">if</span>(key==<span class="number">1</span>)<span class="comment">//执行功能代码</span></span><br><span class="line">        {</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">15</span>)i=<span class="number">1</span>;<span class="comment">//让i一直在1~14之间变化</span></span><br><span class="line">       </span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">8</span>)dir=<span class="number">0</span>;<span class="comment">//向左移</span></span><br><span class="line">            <span class="keyword">if</span>(dir==<span class="number">0</span>)P0=~(<span class="number">0x01</span>&lt;&lt;i);</span><br><span class="line">       </span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">8</span>)dir=<span class="number">1</span>;<span class="comment">//向右移 </span></span><br><span class="line">            <span class="keyword">if</span>(dir==<span class="number">1</span>)P0=~( <span class="number">0x80</span>&gt;&gt;(i<span class="number">-7</span>) );<span class="comment">//当i大于等于8之后，(i-7)其实也还是在1~7之间变化    </span></span><br><span class="line">        }  </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>考虑到我们最常用的按键是<code>K4、K8、K12、K16</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/643821610d2dde5777cc6c74.png" alt=""></p>
<p>所以只有<code>P2^7</code>输出低电平之后，对应的4个按键的IO端口才有被拉低的条件</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">KEY_Init</span><span class="params">()</span></span><br><span class="line">{   </span><br><span class="line">    P2=<span class="number">0X7F</span>;<span class="comment">//让P2.7输出低电平，其他IO端口输出高电平，这样就可以使能4个按键了</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-5-3-最终按键程序">2.5.3 最终按键程序</h4>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">u8 <span class="title function_">KEY_Scan</span><span class="params">(u8 mode,u16 TIMES)</span></span><br><span class="line">{  </span><br><span class="line">    <span class="type">static</span> u8 key_up=<span class="number">1</span>; <span class="comment">//按键松开标志</span></span><br><span class="line">    <span class="type">static</span> u16 times;</span><br><span class="line">    <span class="keyword">if</span>(mode)key_up=<span class="number">1</span>;   <span class="comment">//如果mode等于1，支持连按    </span></span><br><span class="line">    <span class="keyword">if</span>(key_up&amp;&amp;(KEY4==<span class="number">0</span>||KEY8==<span class="number">0</span>||KEY12==<span class="number">0</span>||KEY16==<span class="number">0</span>))<span class="comment">//只要在key_up等于1时，其中一个按键被按下就可以进入执行代码</span></span><br><span class="line">    {</span><br><span class="line">        times++;        <span class="comment">//记录进入低电平的时间</span></span><br><span class="line">        <span class="keyword">if</span>(times&gt;=TIMES)<span class="comment">//抖动的时间已经过去</span></span><br><span class="line">        { </span><br><span class="line">            times=<span class="number">0</span>;</span><br><span class="line">            key_up=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(KEY4==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(KEY8==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(KEY12==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(KEY16==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(KEY4==<span class="number">1</span>&amp;&amp;KEY8==<span class="number">1</span>&amp;&amp;KEY12==<span class="number">1</span>&amp;&amp;KEY16==<span class="number">1</span>)key_up=<span class="number">1</span>;      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 无按键按下</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>
<p>假设我们传入的参数mode为0，进入函数，第一次初始化时key_up为1，然后没有去执行“if(mode)key_up=1;”，此时若没有按键按下，则满足“else if(KEY4==1&amp;&amp;KEY8==1&amp;&amp;KEY12==1&amp;&amp;KEY16==1)key_up=1;”，所以key_up还是等于1，返回值为0。</p>
</li>
<li>
<p>假设有按键按下，持续够一定的低电平时间了（抖动时间过去了），清零times，让key_up等于0，然后判断此时是哪个按键按下就返回对应的值。</p>
</li>
<li>
<p>返回对应的值之后，如果我们一直按着不放，第二次执行这个函数就会因为key_up在前一次函数执行中已经等于0，所以我们就算按着按键不放也进入不了“if(key_up&amp;&amp;(KEY4==0||KEY8==0||KEY12==0||KEY16==0))”，那么一次按键动作只能有一次返回值为4、8、12或16的机会，其他时候都是返回0。如果我们按键松手了，那就满足“else if(KEY4==1&amp;&amp;KEY8==1&amp;&amp;KEY12==1&amp;&amp;KEY16==1)key_up=1;”，这样key_up恢复为1了，下次按键动作又能够进入“if(key_up&amp;&amp;(KEY4==0||KEY8==0||KEY12==0||KEY16==0))”从而可以返回对应的按键值。不支持连按模式就讲解完了。</p>
</li>
<li>
<p>参数mode为1时，总会执行“if(mode)key_up=1;”，所以按键按着不放函数的执行都会进入“if(key_up&amp;&amp;(KEY4==0||KEY8==0||KEY12==0||KEY16==0))”，这样返回的按键值的机会比不支持连按时候还要多，这就是mode等于1时呈现的支持连按功能。</p>
</li>
<li>
<p>我们不再使用“#define TIMES 1000”，因为有时“KEY_Scan()”在各种不同的循环体里扫描返回值，有些循环一次执行时间很快，有些却很慢，我们在第五章已经分析过这些情况了，所以TIMES的值需要随机应变。我们决定让TIMES作为按键程序的第二个参数，这样在某些循环体里如果循环一次的时间很快，我们调为“KEY_Scan(0,1000);”，循环一次的时间很慢就改为“KEY_Scan(0,300);”</p>
</li>
</ol>
<p>原理解析就讲解完了，可以看到，该代码在不支持连按模式下是按下之后就执行返回值了的，而不是像以前一样要抬起按键之后才会执行返回值的语句，所以不管我们的按键手速是快是慢，程序都会在最快时间内去执行返回值的语句。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际 金沙滩开发板 把“KEY_Scan(0,1000);”改为“KEY_Scan(1,1000);”就是支持连按了。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;function.h&gt;</span></span></span><br><span class="line">sbit KEY4  = P2^<span class="number">3</span>;</span><br><span class="line">sbit KEY8  = P2^<span class="number">2</span>;</span><br><span class="line">sbit KEY12 = P2^<span class="number">1</span>;</span><br><span class="line">sbit KEY16 = P2^<span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">u8 <span class="title function_">KEY_Scan</span><span class="params">(u8 mode,u16 TIMES)</span></span><br><span class="line">{  </span><br><span class="line">    <span class="type">static</span> u8 key_up=<span class="number">1</span>; <span class="comment">//按键松开标志</span></span><br><span class="line">    <span class="type">static</span> u16 times;</span><br><span class="line">    <span class="keyword">if</span>(mode)key_up=<span class="number">1</span>;   <span class="comment">//如果mode等于1，支持连按    </span></span><br><span class="line">    <span class="keyword">if</span>(key_up&amp;&amp;(KEY4==<span class="number">0</span>||KEY8==<span class="number">0</span>||KEY12==<span class="number">0</span>||KEY16==<span class="number">0</span>))<span class="comment">//只要在key_up等于1时，其中一个按键被按下就可以进入执行代码</span></span><br><span class="line">    {</span><br><span class="line">        times++;        <span class="comment">//记录进入低电平的时间</span></span><br><span class="line">        <span class="keyword">if</span>(times&gt;=TIMES)<span class="comment">//抖动的时间已经过去</span></span><br><span class="line">        { </span><br><span class="line">            times=<span class="number">0</span>;</span><br><span class="line">            key_up=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(KEY4==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(KEY8==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(KEY12==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(KEY16==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(KEY4==<span class="number">1</span>&amp;&amp;KEY8==<span class="number">1</span>&amp;&amp;KEY12==<span class="number">1</span>&amp;&amp;KEY16==<span class="number">1</span>)key_up=<span class="number">1</span>;      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 无按键按下</span></span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY_Init</span><span class="params">()</span></span><br><span class="line">{   </span><br><span class="line">    P2=<span class="number">0X7F</span>;<span class="comment">//让P2.7输出低电平，其他输出高电平，这样就可以使能4个按键了</span></span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{  </span><br><span class="line">    u8 key;    <span class="comment">//用来读取按键动作的返回值</span></span><br><span class="line">    LED_Init();<span class="comment">//初始化LED硬件模块</span></span><br><span class="line">    KEY_Init();<span class="comment">//初始化按键模块</span></span><br><span class="line">    P0=<span class="number">0xFE</span>;   <span class="comment">//先点亮LED2</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {      </span><br><span class="line">        key=KEY_Scan(<span class="number">0</span>,<span class="number">1000</span>); <span class="comment">//不支持连按模式，判断阈值为1000</span></span><br><span class="line">        <span class="keyword">if</span>(key==<span class="number">4</span>)LED2=!LED2; <span class="comment">//执行功能代码</span></span><br><span class="line">        <span class="keyword">if</span>(key==<span class="number">8</span>)LED4=!LED4; <span class="comment">//执行功能代码</span></span><br><span class="line">        <span class="keyword">if</span>(key==<span class="number">12</span>)LED6=!LED6;<span class="comment">//执行功能代码</span></span><br><span class="line">        <span class="keyword">if</span>(key==<span class="number">16</span>)LED8=!LED8;<span class="comment">//执行功能代码</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-5-4-最终的function文件">2.5.4 最终的Function文件</h4>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际 金沙滩开发板 functin.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;function.h&gt;</span> </span></span><br><span class="line">  </span><br><span class="line">u8 code LedChar[<span class="number">16</span>]={<span class="number">0xC0</span>,<span class="number">0xF9</span>,<span class="number">0xA4</span>,<span class="number">0xB0</span>,<span class="number">0x99</span>,<span class="number">0x92</span>,<span class="number">0x82</span>,<span class="number">0xF8</span>,<span class="number">0x80</span>,<span class="number">0x90</span>,<span class="number">0x88</span>,<span class="number">0x83</span>,<span class="number">0xC6</span>,<span class="number">0xA1</span>,<span class="number">0x86</span>,<span class="number">0x8E</span>};<span class="comment">//数码管状态值初始化</span></span><br><span class="line">u8 LedBuff[<span class="number">6</span>]={<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>};<span class="comment">//初始化数码管显示缓存区</span></span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(u16 x)</span></span><br><span class="line">{</span><br><span class="line">    u16 i,j;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1000</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">19601</span>;i++)<span class="comment">//延时1s</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">5</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">while</span>(x--)<span class="keyword">for</span>(j=<span class="number">115</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    P1|=<span class="number">0x0E</span>;<span class="comment">//让P1.1，P1.2，P1.3强制输出1</span></span><br><span class="line">    P1&amp;=<span class="number">0xEE</span>;<span class="comment">//让P1.0和P1.4强制输出0</span></span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY_Init</span><span class="params">()</span></span><br><span class="line">{    </span><br><span class="line">    P2=<span class="number">0X7F</span>;<span class="comment">//让P2.7输出低电平，其他输出高电平，这样就可以使能4个按键了</span></span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line">u8 <span class="title function_">KEY_Scan</span><span class="params">(u8 mode,u16 TIMES)</span></span><br><span class="line">{  </span><br><span class="line">    <span class="type">static</span> u8 key_up=<span class="number">1</span>; <span class="comment">//按键松开标志</span></span><br><span class="line">    <span class="type">static</span> u16 times;</span><br><span class="line">    <span class="keyword">if</span>(mode)key_up=<span class="number">1</span>;   <span class="comment">//如果mode等于1，支持连按      </span></span><br><span class="line">    <span class="keyword">if</span>(key_up&amp;&amp;(KEY4==<span class="number">0</span>||KEY8==<span class="number">0</span>||KEY12==<span class="number">0</span>||KEY16==<span class="number">0</span>))<span class="comment">//只要在key_up等于1时，其中一个按键被按下就可以进入执行代码</span></span><br><span class="line">    {</span><br><span class="line">        times++;        <span class="comment">//记录进入低电平的时间</span></span><br><span class="line">        <span class="keyword">if</span>(times&gt;=TIMES)<span class="comment">//抖动的时间已经过去</span></span><br><span class="line">        {  </span><br><span class="line">            times=<span class="number">0</span>;</span><br><span class="line">            key_up=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(KEY4==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(KEY8==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(KEY12==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(KEY16==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(KEY4==<span class="number">1</span>&amp;&amp;KEY8==<span class="number">1</span>&amp;&amp;KEY12==<span class="number">1</span>&amp;&amp;KEY16==<span class="number">1</span>)key_up=<span class="number">1</span>;       </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 无按键按下</span></span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">SEG_Scan</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">static</span> u8 i = <span class="number">0</span>;     </span><br><span class="line">    P0 = <span class="number">0xFF</span>;             <span class="comment">//端口状态全部熄灭数码管里的LED达到刷新作用</span></span><br><span class="line">    P1 = (P1 &amp; <span class="number">0xF8</span>) | i;  <span class="comment">//i等于0时，就是“ADDR2=0; ADDR1=0; ADDR0=0;”，i等于1时，就是“ADDR2=0; ADDR1=0; ADDR0=1;”，以此类推</span></span><br><span class="line">    P0 = LedBuff[i];       <span class="comment">//6个缓冲区的值轮流赋给P0</span></span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=<span class="number">6</span>)i=<span class="number">0</span>;           <span class="comment">//让i在0~5之间循环变化</span></span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowNumber</span><span class="params">(u32 num)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> i;<span class="comment">//取值范围-128~127</span></span><br><span class="line">    u8 buf[<span class="number">6</span>];    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)    <span class="comment">//把长整型数转换为6位十进制的数组</span></span><br><span class="line">    {</span><br><span class="line">        buf[i] = num % <span class="number">10</span>;</span><br><span class="line">        num = num / <span class="number">10</span>;    <span class="comment">//舍掉个位数，重新装载</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">5</span>; i&gt;=<span class="number">1</span>; i--)   <span class="comment">//从最高位起，遇到0填充不显示的代码，遇到非0则退出循环</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (buf[i] == <span class="number">0</span>)</span><br><span class="line">            LedBuff[i] = <span class="number">0xFF</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> ( ; i&gt;=<span class="number">0</span>; i--)     <span class="comment">//剩余低位都如实转换为数码管显示字符</span></span><br><span class="line">    {</span><br><span class="line">        LedBuff[i] = LedChar[buf[i]];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际 金沙滩开发板 function.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __FUNCTION_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FUNCTION_H__</span></span><br><span class="line">  </span><br><span class="line">sbit BEEP  = P1^<span class="number">6</span>;</span><br><span class="line">sbit KEY4  = P2^<span class="number">3</span>;</span><br><span class="line">sbit KEY8  = P2^<span class="number">2</span>;</span><br><span class="line">sbit KEY12 = P2^<span class="number">1</span>;</span><br><span class="line">sbit KEY16 = P2^<span class="number">0</span>;</span><br><span class="line">sbit LED2  = P0^<span class="number">0</span>;</span><br><span class="line">sbit LED3  = P0^<span class="number">1</span>;</span><br><span class="line">sbit LED4  = P0^<span class="number">2</span>;</span><br><span class="line">sbit LED5  = P0^<span class="number">3</span>;</span><br><span class="line">sbit LED6  = P0^<span class="number">4</span>;</span><br><span class="line">sbit LED7  = P0^<span class="number">5</span>;</span><br><span class="line">sbit LED8  = P0^<span class="number">6</span>;</span><br><span class="line">sbit LED9  = P0^<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>  u8;  <span class="comment">//对数据类型进行声明定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>  u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> u32;</span><br><span class="line"><span class="keyword">extern</span>  u8 LedBuff[<span class="number">6</span>];      <span class="comment">//对数码管缓存区进行外部声明</span></span><br><span class="line"><span class="keyword">extern</span>  u8 code LedChar[<span class="number">16</span>];<span class="comment">//对数码管真值表进行外部声明</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//只要在“function.c”文件中封装有的函数都需要在头文件中声明一下</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(u16 x)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY_Init</span><span class="params">()</span>;</span><br><span class="line">u8 <span class="title function_">KEY_Scan</span><span class="params">(u8 mode,u16 TIMES)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SEG_Scan</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowNumber</span><span class="params">(u32 num)</span>;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际 金沙滩开发板 main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;function.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{  </span><br><span class="line">    u8 key;<span class="comment">//用来读取按键动作的返回值</span></span><br><span class="line">    u8 beep_ok=<span class="number">0</span>;<span class="comment">//定义标志蜂鸣器允许鸣叫的变量，为1时可以鸣叫，为0时不能鸣叫</span></span><br><span class="line">    u8 x;</span><br><span class="line">    u32 NUM=<span class="number">10086</span>;</span><br><span class="line">    LED_Init();<span class="comment">//初始化LED硬件模块</span></span><br><span class="line">    KEY_Init();<span class="comment">//初始化按键模块</span></span><br><span class="line">    ShowNumber(NUM);<span class="comment">//更新数码管缓存区内容</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {        </span><br><span class="line">        SEG_Scan();</span><br><span class="line">        key=KEY_Scan(<span class="number">0</span>,<span class="number">700</span>);                <span class="comment">//不支持连按模式，判断阈值为700</span></span><br><span class="line">        <span class="keyword">if</span>(key==<span class="number">4</span>){NUM++;ShowNumber(NUM);}  <span class="comment">//K4使NUM自加</span></span><br><span class="line">        <span class="keyword">if</span>(key==<span class="number">12</span>){NUM--;ShowNumber(NUM);} <span class="comment">//K12使NUM自减</span></span><br><span class="line">        <span class="keyword">if</span>(key==<span class="number">8</span>)beep_ok=<span class="number">1</span>;                <span class="comment">//K8开启蜂鸣器鸣叫</span></span><br><span class="line">        <span class="keyword">if</span>(key==<span class="number">16</span>)beep_ok=<span class="number">0</span>;               <span class="comment">//K16关闭蜂鸣器鸣叫</span></span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span>(beep_ok==<span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            x++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> x=<span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">3</span>)</span><br><span class="line">        {</span><br><span class="line">            x=<span class="number">0</span>;</span><br><span class="line">            BEEP=!BEEP;   </span><br><span class="line">        }      </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<div class="note success modern"><p>success 这样我们的function文件就囊括了之前所学的单片机外设的代码了，大家要好好消化这一文件</p>
</div>
<h3 id="2-6-外部中断">2.6 外部中断</h3>
<h4 id="2-6-1-ie0的作用">2.6.1 IE0的作用</h4>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"function.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//请提前将P3.2和GND相连</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	LED_Init(); <span class="comment">//初始化LED硬件模块</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">		<span class="keyword">if</span>(IE0 == <span class="number">0</span>) {</span><br><span class="line">			LED2 = !LED2;</span><br><span class="line">			delay_ms(<span class="number">50</span>);</span><br><span class="line">			LED2 = <span class="number">1</span>; <span class="comment">//如果IE0不等于0了，要保证熄灭LED2;</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(IE0 == <span class="number">1</span>) {</span><br><span class="line">			LED9 = !LED9;</span><br><span class="line">			delay_ms(<span class="number">50</span>);</span><br><span class="line">			LED9 = <span class="number">1</span>; <span class="comment">//如果LED0不等于1了，要保证熄灭LED9</span></span><br><span class="line">		}</span><br><span class="line">		delay_ms(<span class="number">50</span>); <span class="comment">//总要执行`if(IE0 == 0)`或者`if(IE0 == 1)`，这个延时要保证其中一盏灯灭的时间，保证总有灯闪烁的现象</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-6-2-中断函数">2.6.2 中断函数</h4>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"function.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	IT0 = <span class="number">1</span>; <span class="comment">//下降沿触发</span></span><br><span class="line">	EX0 = <span class="number">1</span>;</span><br><span class="line">	EA = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	LED_Init(); <span class="comment">//初始化LED硬件模块</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>); <span class="comment">// 主函数什么事都不用做，空循环这条语句</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">()</span> interrupt 0 {</span><br><span class="line">	LED2 = !LED2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>看起来主函数什么内容也没有，但是在拔插杜邦线的过程中触发了中断函数，所以LED2被执行跳变，这就是中断函数的作用。即使主函数一直执行<code>while(1);</code>，中断函数还是能执行的了的。把<code>EX0=1;</code>改为<code>EX0=0;</code>，或者把<code>EA=1;</code>改为<code>EA=0;</code>再编译下载进去拔插杜邦线发现LED2没有反应，因为这样做已经不满足触发中断函数响应了。</p>
<h4 id="2-6-3-外部中断1">2.6.3 外部中断1</h4>
<p>想要使用外部中断1，代码中需要把<code>EX0</code>改为<code>EX1</code>，<code>IT0</code>改为<code>IT1</code>。interrupt后面的0要改为2，函数名我们改为<code>EXTI1_IRQHandler()</code></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"function.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	IT1 = <span class="number">1</span>; <span class="comment">//下降沿触发模式</span></span><br><span class="line">	EA = <span class="number">1</span>;</span><br><span class="line">	EX1 = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	LED_Init(); <span class="comment">//初始化LED硬件电路</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXIT1_IRQHandler</span><span class="params">()</span> interrupt 2 {</span><br><span class="line">	LED2 = !LED2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-6-4-按键控制中断">2.6.4 按键控制中断</h4>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"function.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	IT1 = <span class="number">1</span>; <span class="comment">//设置下降沿触发模式</span></span><br><span class="line">	EA = <span class="number">1</span>;</span><br><span class="line">	EX1 = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	LED_Init(); <span class="comment">//初始化LED电路</span></span><br><span class="line">	KEY_Init(); <span class="comment">//初始化按键电路</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI1_IRQHandler</span><span class="params">()</span> interrupt 2 {</span><br><span class="line">	LED2 = !LED2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们需要对按键进行消抖，这样就可以达到按下松手一次，LED2的状态只能取反一次的灵敏效果。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过在中断函数中添加延时函数消抖，一般不这样做，但编程本就是逆天而行</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"function.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	IT1 = <span class="number">1</span>; <span class="comment">//设置下降沿触发</span></span><br><span class="line">	EA = <span class="number">1</span>;</span><br><span class="line">	EX1 = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	LED_Init(); <span class="comment">//初始化LED电路</span></span><br><span class="line">	KEY_Init(); <span class="comment">//初始化键盘电路</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXIT1_IRQHandler</span><span class="params">()</span> interrupt 2 {</span><br><span class="line">	delay_ms(<span class="number">50</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(INT1 == <span class="number">0</span>) { <span class="comment">// 消抖</span></span><br><span class="line">		LED2 = !LED2; <span class="comment">// P3.3是否还处于低电平的稳定接触状态，INT1已在“#include &lt;reg52.h&gt;”中定义好了</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这样就可以达到按下松手一次，LED2的状态只能取反一次的灵敏效果。如果我们一直按着不放，LED2也只是跳变一次而已，有点像不支持连按功能，这是因为<code>IT1=1;</code>的原因。要是改为<code>IT1=0;</code>，这样K4按键就有种支持连按的感觉从而LED2就会不停闪烁了。按键按下一直不放就会不停地进入中断函数。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过在中断函数中添加延时函数消抖，一般不这样做，但编程本就是逆天而为</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"function.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	IT1 = <span class="number">0</span>; <span class="comment">//低电平下触发中断</span></span><br><span class="line">	EA = <span class="number">1</span>;</span><br><span class="line">	EX1 = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	LED_Init(); <span class="comment">//初始化LED电路</span></span><br><span class="line">	KEY_Init(); <span class="comment">//初始KEY电路</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXIT_IRQHandler</span><span class="params">()</span> interrupt 2 {</span><br><span class="line">	delay_ms(<span class="number">50</span>);</span><br><span class="line">	<span class="keyword">if</span>(INT1 == <span class="number">0</span>) {</span><br><span class="line">		LED2 = !LED2;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-7-定时器">2.7 定时器</h3>
<h4 id="2-7-1-工作模式一之流水灯">2.7.1 工作模式一之流水灯</h4>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 定时器<span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"function.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    u8 i = <span class="number">0</span>;</span><br><span class="line">    LED_Init(); <span class="comment">//初始化LED硬件模块</span></span><br><span class="line">    TMOD = <span class="number">0x01</span>; <span class="comment">//设置定时器0位工作模式1</span></span><br><span class="line">    TH0 = <span class="number">0x4C</span>; <span class="comment">//色湖之定时时间位50ms</span></span><br><span class="line">    TL0 = <span class="number">0x00</span>;</span><br><span class="line">    TR0 = <span class="number">1</span>; <span class="comment">//启动定时器0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">if</span>(TF0 == <span class="number">1</span>) { <span class="comment">//判断定时器0是否溢出，每隔50ms就可以进入一次这个if语句内部</span></span><br><span class="line">            TF0 = <span class="number">0</span>; <span class="comment">//软件清零，定时器0溢出后，清0溢出标志</span></span><br><span class="line">            TH0 = <span class="number">0x4C</span>; <span class="comment">//重新赋值，保证下次溢出时间间隔还是50ms</span></span><br><span class="line">            TL0 = <span class="number">0x00</span>;</span><br><span class="line">            P0 = ~(<span class="number">0x01</span> &lt;&lt; i); <span class="comment">//每盏灯的点亮时间都保持者50ms</span></span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">8</span>) i = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 定时器<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;function.h&gt;</span><span class="comment">//详见第六章第8讲</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{   </span><br><span class="line">    u8 i=<span class="number">0</span>;</span><br><span class="line">    LED_Init();   <span class="comment">//初始化LED硬件模块 </span></span><br><span class="line">    TMOD = <span class="number">0x10</span>;  <span class="comment">//设置定时器1为工作模式1</span></span><br><span class="line">    TH1  = <span class="number">0x4C</span>;  <span class="comment">//设置定时时间为50ms</span></span><br><span class="line">    TL1  = <span class="number">0x00</span>;</span><br><span class="line">    TR1  = <span class="number">1</span>;     <span class="comment">//启动定时器1</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (TF1 == <span class="number">1</span>)     <span class="comment">//判断定时器1是否溢出，每隔50ms就可以进入一次这个if语句</span></span><br><span class="line">        {</span><br><span class="line">            TF1 = <span class="number">0</span>;      <span class="comment">//定时器1溢出后，清0溢出标志</span></span><br><span class="line">            TH1 = <span class="number">0x4C</span>;   <span class="comment">//重新赋初值，保证下次溢出间隔时间还是50ms</span></span><br><span class="line">            TL1 = <span class="number">0x00</span>;</span><br><span class="line">            P0=~(<span class="number">0x01</span>&lt;&lt;i);<span class="comment">//每盏灯的点亮时间都保持着50ms</span></span><br><span class="line">            i++;</span><br><span class="line">        }   </span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">8</span>)i=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-7-2-定时器中断">2.7.2 定时器中断</h4>
<p>右移流水灯，定时时长为30ms</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"function.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    LED_Init(); <span class="comment">//初始化LED硬件模块</span></span><br><span class="line">    EA = <span class="number">1</span>; <span class="comment">//打开总中断开关</span></span><br><span class="line">    TMOD = <span class="number">0x01</span>; <span class="comment">//设置定时器0为工作模式1</span></span><br><span class="line">    TH0 = <span class="number">0x94</span>; <span class="comment">// 设置定时时间为30ms</span></span><br><span class="line">    ET0 = <span class="number">1</span>; <span class="comment">//打开定时器0中断的开关</span></span><br><span class="line">    TR0 = <span class="number">1</span>; <span class="comment">//启动定时器0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM0_IRQHandler</span><span class="params">()</span> interrupt 1 {</span><br><span class="line">    <span class="type">static</span> u8 i;</span><br><span class="line">    TH0 = <span class="number">0x94</span>; <span class="comment">//重新设定时间为30ms</span></span><br><span class="line">    TL0 = <span class="number">0x00</span>;</span><br><span class="line">    </span><br><span class="line">    P0 = ~(<span class="number">0x80</span> &gt;&gt; i); <span class="comment">//流水灯向左移动</span></span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= <span class="number">8</span>) i = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="三-单片机c语言">三、单片机C语言</h2>
<p>该章只记录博主不会的单片机相关C语言知识，不做C语言的详细解释，谁叫博主是个菜鸡呢。对刚入门单片机编程的初学者来说，以前我们C语言基础上机操作的时候都是只见过别人int,char的去定义变量，而在单片机入门编程中看到的都是unsigned int,unsigned char这样定义，原因是<code>单片机在入门的时候用的变量的取值都是0和正整数（正整数不包括0），所以才会用unsigned去定义无符号整形变量</code>。</p>
<h3 id="3-1-特殊功能寄存器和位定义">3.1 特殊功能寄存器和位定义</h3>
<h4 id="3-1-1-sfr-p0-0x80">3.1.1 sfr P0=0x80</h4>
<p>sfr 这个关键字，是 51 单片机特有的，它的作用是定义一个<code>单片机特殊功能寄存器</code>(special function register)。</p>
<p>51 单片机内部有很多个小<code>模块</code>，每个模块居住在拥有唯一房间号的房间内，同时每个模块都有 8 个控制开关。<code>P0 </code>就是一个功能模块，就住在了 <code>0x80</code> 这个房间里，我们就是通过设置 P0 内部这个模块的 8 个开关，来让单片机的 P0 这 8 个 IO 口输出高电平或者低电平的。而 51 单片机内部有很多寄存器，如果我们想使用的话必须提前进行 sfr 声明。不过 Keil 软件已经把所有这些声明都预先写好并保存到一个专门的文件中去了，我们要用的话只要文件开头添加一行#include&lt;reg52.h&gt;即可。</p>
<h4 id="3-1-2-sbit-led-p0-0">3.1.2 sbit LED = P0^0</h4>
<p>这个 <code>sbit</code>，就是对刚才所说的 SFR 里边的 8 个开关其中的一个进行定义。经过上边第二条语句后，以后只要在程序里写 LED，就代表了 P0.0 口。注意这个 P 必须大写，也就是说我们给 P0.0 又取了一个更形象的名字叫做 LED。</p>
<h4 id="3-1-3-单片机的特殊功能寄存器">3.1.3 单片机的特殊功能寄存器</h4>
<p>请注意，每个型号的单片机都会配有生产厂商所编写的数据手册(Datasheet)，所以我们来看一下 STC89C52 的数据手册，从 21 页到 24 页，全部是对特殊功能寄存器的介绍以及地址映射列表。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Gan1Ser/img-url@main/2022/12image-20230331165423783.png" alt="image-20230331165423783"></p>
<p>我们来看一下这个表，其中 P4 口 STC89C52 对标准 51 的扩展，我们先忽略它，只看前边的 P0、P1、P2、P3 这 4 个，每个 P 口本身又有 8 个控制端口。这样就确定了我们的单片机一共有 32 个 IO 口</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/64268bc2a682492fccb2fc91.png" alt=""></p>
<p>其中P0 口所在的地址是0x80，一共有从7 到0 这8 个IO 口控制位，后边有个Reset Value（复位值），这个很重要，是我们看寄存器必看的一个参数，8 个控制位复位值全部都是 1。这就是告诉我们，每当单片机上电复位的时候，所有的引脚的值默认是都是 1，即高电平，<br>
我们在设计电路的时候也要充分的考虑这个问题。</p>
<h3 id="3-2-delay-函数">3.2 Delay()函数</h3>
<p>前期我们在设计时间间隔时经常使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>e</mi><mi>l</mi><mi>a</mi><mi>y</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Delay()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span>函数，最近几位同学一直在研究这个函数，简单的两层<code>for</code>循环，真的能很准确的设置延迟吗？让我们看一下这个简单的延迟的函数。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span> <span class="comment">//简单的延时函数</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">120</span>; j++);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">delay(<span class="number">5000</span>); <span class="comment">//绿灯持续5秒钟</span></span><br></pre></td></tr></tbody></table></figure>
<p>现在思考为什么我们调用函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>l</mi><mi>a</mi><mi>y</mi><mo stretchy="false">(</mo><mn>5000</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">delay(5000)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>就能延迟5秒钟呢？</p>
<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;-- 这里是根据我查阅了一些资料得到的一点理解，如有不对请指正 --&gt;</span><br><span class="line"></span><br><span class="line">根据代码其实很明显，调用delay函数延时的时长是通过循环执行空操作来实现的，也就是说，delay函数并没有真正的即使功能，而是通过程序执行的速度来控制延时的时长。因此，delay(5000)实际上是在循环执行一定次数的空操作后，才返回函数，达到延时5s的效果。</span><br><span class="line"></span><br><span class="line">具体来求解这个5s其实是要考虑很多因素的，延时时长的计算与单片机所使用的时钟频率有关。以一个8MHz的晶振为例，每个时钟周期的时间为1/(8MHz)=0.125us。delay函数中的循环次数是通过将所需延时时间转换为循环次数来实现的，计算公式为：循环次数 = 延时时间 / 单次循环所需时间。对于delay(5000)来说，延时为5s,即5000ms=5000000us。而单次循环所需时间是根据时钟频率计算得到的，对于8MHz晶振，单次循环所需时间为1/(8MHz)·4 = 0.5us(其中4是空操作的指令执行数)。因此，延迟5s需要执行的循环次数为：5000000us/0.5us=10000000次，才能实现延迟5秒的效果。</span><br><span class="line"></span><br><span class="line">&lt;-- 博主的单片机是11.9....MHz的晶振，protues是12MHz的，让我计算一下，以上代码是否真的是5s --&gt;</span><br><span class="line">按照protues中的12MHz，我们计算一下5s需要循环多少次。根据上述原理，我们每个时钟周期的时间为1/(12MHZ),单次循环所需时间为1/(12MHz)·120 = 10us(这里120是空操作的指令执行数见代码for(j = 0; j &lt; 120; j++))。因此，我们要延迟5s需要执行的循环次数为：5000000us/10us = 500000次，但是我们使用delay(5000)一共循环了5000·120=600000次，不管是500000次还是600000次我们发现这都和我们传入的参数5000不符合呀，麻了，这是怎么回事呢？这是因为以上计算公式都是基于单片机汇编语言的，我们使用c语言绝不能这样计算，很明显一条c语句应该是对应很多调汇编语句的，你可以Dedug试试，所以该方法是计算不出来的。</span><br></pre></td></tr></tbody></table></figure>
<p>如何设计我们的循环达到想要的延迟效果？综合上述所讲，我们的误区就落在C语言语句的执行时间，那么我们来实际调试一下看看我们的代码到底运行多久。</p>
<h5 id="3-2-1-空操作循环运行的时间">3.2.1 空操作循环运行的时间</h5>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit RED1 = P2^<span class="number">0</span>; <span class="comment">//第一组红灯</span></span><br><span class="line">sbit YELLOW1 = P2^<span class="number">1</span>; <span class="comment">//第一组黄灯</span></span><br><span class="line">sbit GREEN1 = P2^<span class="number">2</span>; <span class="comment">//第一组绿灯</span></span><br><span class="line">sbit RED2 = P2^<span class="number">3</span>; <span class="comment">//第二组红灯</span></span><br><span class="line">sbit YELLOW2 = P2^<span class="number">4</span>; <span class="comment">//第二组黄灯</span></span><br><span class="line">sbit GREEN2 = P2^<span class="number">5</span>; <span class="comment">//第二组绿灯</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span> <span class="comment">//简单的延时函数</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">120</span>; j++);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//第一组绿灯，第二组红灯</span></span><br><span class="line">        GREEN1 = <span class="number">0</span>;</span><br><span class="line">        YELLOW1 = <span class="number">1</span>;</span><br><span class="line">        RED1 = <span class="number">1</span>;</span><br><span class="line">        GREEN2 = <span class="number">1</span>;</span><br><span class="line">        YELLOW2 = <span class="number">1</span>;</span><br><span class="line">        RED2 = <span class="number">0</span>; </span><br><span class="line">				<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">120</span>; i++); <span class="comment">//验证空操作循环所需时间</span></span><br><span class="line">        delay(<span class="number">5000</span>); <span class="comment">//绿灯持续5秒钟</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一组黄灯，第二组红灯</span></span><br><span class="line">        YELLOW1 = <span class="number">0</span>;</span><br><span class="line">        GREEN1 = <span class="number">1</span>;</span><br><span class="line">        delay(<span class="number">1000</span>); <span class="comment">//黄灯持续1秒钟</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一组红灯，第二组绿灯</span></span><br><span class="line">        RED1 = <span class="number">0</span>;</span><br><span class="line">        YELLOW1 = <span class="number">1</span>;</span><br><span class="line">        GREEN1 = <span class="number">1</span>;</span><br><span class="line">        RED2 = <span class="number">1</span>;</span><br><span class="line">        YELLOW2 = <span class="number">1</span>;</span><br><span class="line">        GREEN2 = <span class="number">0</span>; </span><br><span class="line">        delay(<span class="number">5000</span>); <span class="comment">//绿灯持续5秒钟</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一组红灯，第二组黄灯</span></span><br><span class="line">        YELLOW2 = <span class="number">0</span>;</span><br><span class="line">        GREEN2 = <span class="number">1</span>;</span><br><span class="line">        delay(<span class="number">1000</span>); <span class="comment">//黄灯持续1秒钟</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>首先将我们的晶振频率设置为12MHz，因为新建工程时默认是24MHz</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6428e5f6a682492fccc4d8d7.png" alt="image-20230402090540447"></p>
<ol start="2">
<li>开始调试（为了验证的简单，我们直接在main函数中添加空操作循环）</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6428e628a682492fccc51215.png" alt="image-20230402090813183"></p>
<ol start="3">
<li>打断点</li>
</ol>
<p>我们将断点打到第30行和第31行，点击<code>RST</code>按钮，然后返回main函数，按下<code>run</code>键，通过右侧<code>sec</code>时间可以看到当前程序执行到第30行所用的时间。可以看到程序运行到第30行时花了0.00039400s</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6428e65da682492fccc546ca.png" alt="image-20230402092201907"></p>
<p>我们继续执行第30条语句，查看时间为0.00039500，这条语句花了0.00039500-0.00039400=0.00000100s,也就是1微秒。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6428e694a682492fccc5861b.png" alt="image-20230402092421453"></p>
<p>下面我们执行空操作循环语句，我们继续将断点打在32行（为了计算时间，如果不打断点程序会将31行语句后面的程序全部执行完）。可以看到时间变成0.00135800s。也就是说我们的空操作语句花了0.00135800s-0.00039500=0.000963s，也就是0.963毫秒接近1ms。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6428e6c5a682492fccc5b86e.png" alt="image-20230402092931979"></p>
<p>如此我们就知道为什么我们调用delay(5000)就能够延迟5s秒了，视5000为5000次1ms，就得到5s了。</p>
<h5 id="3-2-2-存在的问题">3.2.2 存在的问题</h5>
<p>如果你调试时候我们的时间是有差异的，那就说明我们使用空操作循环进行延时操作是不完全的。这是为什么呢？</p>
<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们设置的时间参数5000，利用空循环等待一段时间，而这个时间正是通过计算机(晶振)时钟周期数来实现的，它的具体时间取决于计算机的性能和系统负载情况。也就是我们在调试时，这样的结果还和我们的单片机(计算机)硬件有关，因此存在误差是很正常。</span><br><span class="line"></span><br><span class="line">其实我们会发现我们调试出的for(i=0;i&lt;120;i++)并不是1ms，而是0.963ms。我们用此循环5000次，这样的误差会随着循环次数的增加被不断地放大为1535ms,wok，差了1s，这太可怕了。下面是一个验证的GIF，可以看到确实6s（我后点按的倒计时）</span><br></pre></td></tr></tbody></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6428e1b8a682492fccc019c2.gif" alt=""></p>
<p>所以我们单纯的使用空操作循环语句进行延迟实际上是不准确的，但是勉强能用。</p>
<h5 id="3-2-3-设计精确的5s">3.2.3 设计精确的5s</h5>
<p>要设计精确的5s我们可以借助于看门狗(定时器)或者再次调试，后面更新，博主困了，拜拜。</p>
<h3 id="3-3-移位">3.3 移位</h3>
<p>在我们的 C 语言当中，有一个移位操作，其中<code>&lt;&lt;</code>代表的是左移，<code>&gt;&gt;</code>代表的是右移。比如<code>a = 0x01&lt;&lt;1;</code>就是 a 的结果等于 0x01 左移一位。大家注意，移位都是指二进制移位，那么移位完了，本来在第 0 位的 1 移动到了第一位上，移动完了低位是补 0 的。所以 a 的值最终是等于 <code>0x02</code>。 还要学习另外一个运算符~，这个符号是按位取反的意思，同理按位取反也是针对二进制而言。比如 a = ~(0x01); 0x01 的二进制是 0b00000001，按位取反后就是 0b11111110，那么a 的值就是 0xFE 了。这里要注意的是<code>二进制移位</code></p>
<h3 id="3-4-静态变量">3.4 静态变量</h3>
<p><strong>static</strong>一般不用在主函数中，大多数在中断函数和封装好的子函数里运用，它的作用是保证在子函数或中断函数中定义的变量每次调用完之后都可以保持调用完时候的值，也就是保证变量在两个函数中的值使相同且通用的。下面是一个举例，可以下载到单片机中观察现象。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> </span></span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line">  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code LedChar[<span class="number">16</span>]={<span class="number">0xC0</span>,<span class="number">0xF9</span>,<span class="number">0xA4</span>,<span class="number">0xB0</span>,<span class="number">0x99</span>,<span class="number">0x92</span>,<span class="number">0x82</span>,<span class="number">0xF8</span>,<span class="number">0x80</span>,<span class="number">0x90</span>,<span class="number">0x88</span>,<span class="number">0x83</span>,<span class="number">0xC6</span>,<span class="number">0xA1</span>,<span class="number">0x86</span>,<span class="number">0x8E</span>};<span class="comment">//数码管状态值初始化</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1000</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">19601</span>;i++)<span class="comment">//延时1s</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">5</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">while</span>(x--)<span class="keyword">for</span>(j=<span class="number">115</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">SEG0_task</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> i=<span class="number">0</span>; <span class="comment">//静态变量</span></span><br><span class="line">    P0=LedChar[i];</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=<span class="number">16</span>)i=<span class="number">0</span>; <span class="comment">//让i在0~15之间变化</span></span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{  </span><br><span class="line">    ADDR3 = <span class="number">1</span>;<span class="comment">//使能三八译码器</span></span><br><span class="line">    ENLED = <span class="number">0</span>;<span class="comment">// </span></span><br><span class="line">   </span><br><span class="line">    ADDR2 = <span class="number">0</span>;<span class="comment">//**************************</span></span><br><span class="line">    ADDR1 = <span class="number">0</span>;<span class="comment">//只让数码管0显示</span></span><br><span class="line">    ADDR0 = <span class="number">0</span>;<span class="comment">//**************************</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        SEG0_task();</span><br><span class="line">        delay_ms(<span class="number">1000</span>);<span class="comment">//延时1s</span></span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-5-多文件编程">3.5 多文件编程</h3>
<p>运用多文件编程是为了使我们教程无需每次都贴出相同功能的代码，编程的时候已经有很多代码完全可以前往以前的例程里复制即可。</p>
<p>后期的例程里代码量越来越大，显然全部给出就不合适了，所以我们把经常使用的功能模块代码封装起来放在另一个“.c”文件里提供给我们调用，这个“.c”文件命名为“function.c”。以后我们提供的代码就是“main.c”的内容，这样教程供给的代码数量就会精简一些。</p>
<h4 id="3-5-1-前期设置">3.5.1 前期设置</h4>
<p>新建<code>function.c</code>和<code>function.h</code>，并添加到<code>Source Group 1</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6437b42c0d2dde57773c9f9b.png" alt=""></p>
<p>在<code>function.h</code>中添加以下代码</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __FUNCTION_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FUNCTION_H__</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>  u8;<span class="comment">//对数据类型进行声明定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>  u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> u32;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="3-5-2-硬件的初始化">3.5.2 硬件的初始化</h4>
<p>回顾一下要点亮小灯需要的条件</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先</span></span><br><span class="line">sbit LED2  = P0^<span class="number">0</span>;</span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line"><span class="comment">// 然后</span></span><br><span class="line">ADDR3 = <span class="number">1</span>;<span class="comment">//使能三八译码器</span></span><br><span class="line">ENLED = <span class="number">0</span>;<span class="comment">// </span></span><br><span class="line">  </span><br><span class="line">ADDR2 = <span class="number">1</span>;<span class="comment">//**************************</span></span><br><span class="line">ADDR1 = <span class="number">1</span>;<span class="comment">//让三八译码器的IO6输出低电平</span></span><br><span class="line">ADDR0 = <span class="number">0</span>;<span class="comment">//**************************</span></span><br></pre></td></tr></tbody></table></figure>
<p>上面这些条件满足了就叫<code>LED的初始化</code>，也就是说，要想使用硬件上的模块，我们必须配置好它的IO端口输出情况或者设置好函数的参数使其能工作。初始化不是放在while(1)循环中反复执行，而是在主函数开头把相应的IO端口该输出低电平的输出低电平，该输出高电平的输出高电平，配置好这些器件，它只需在主函数开头执行一次即可，后面就是进入死循环去真正的实现相应的功能了。</p>
<h4 id="3-5-3-小灯的初始化">3.5.3 小灯的初始化</h4>
<p>小灯要能正常工作，就要满足P1的5个IO端口的条件，可以将LED小灯的初始化就封装为</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">()</span> {</span><br><span class="line">    P1 |= <span class="number">0X0E</span>; <span class="comment">//让P1.1, P1.2, P1.3强制输出1</span></span><br><span class="line">    P1&amp;=<span class="number">0xEE</span>; <span class="comment">//让P1.0和P1.4强制输出0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当数码管工作时，小灯是暂时发挥不了作用的，因为三八译码器的IO6端口的输出已经切换了。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SEG_task</span><span class="params">()</span> { <span class="comment">//数码管显示函数</span></span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line">    P0 = <span class="number">0xFF</span>; <span class="comment">// 端口状态全部熄灭数码管理的LED达到刷新作用</span></span><br><span class="line">    <span class="keyword">switch</span>(i)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;ADDR1 = <span class="number">0</span>;ADDR0 = <span class="number">0</span>;P0=LedBuff[<span class="number">0</span>];i++;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;ADDR1 = <span class="number">0</span>;ADDR0 = <span class="number">1</span>;P0=LedBuff[<span class="number">1</span>];i++;<span class="keyword">break</span>;     </span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;ADDR1 = <span class="number">1</span>;ADDR0 = <span class="number">0</span>;P0=LedBuff[<span class="number">2</span>];i++;<span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;ADDR1 = <span class="number">1</span>;ADDR0 = <span class="number">1</span>;P0=LedBuff[<span class="number">3</span>];i++;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;ADDR1 = <span class="number">0</span>;ADDR0 = <span class="number">0</span>;P0=LedBuff[<span class="number">4</span>];i++;<span class="keyword">break</span>;     </span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;ADDR1 = <span class="number">0</span>;ADDR0 = <span class="number">1</span>;P0=LedBuff[<span class="number">5</span>];i=<span class="number">0</span>;<span class="keyword">break</span>; </span><br><span class="line">    }  </span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这段代码我们可以简化为</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SEG_task</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line">    P0 = <span class="number">0xFF</span>; <span class="comment">// 端口状态全部熄灭数码管里的LED达到刷新作用</span></span><br><span class="line">    P1 = (p1 &amp; <span class="number">0xF8</span>) | i; <span class="comment">//i等于0时，就是ADDR2 = 0; ADDR1 = 0; ADDR0 = 0; i等于1时，就是ADDR2=0;ADDR1=0;ADDR2=1;一次类推</span></span><br><span class="line">    P0 = LedBuff[i]; <span class="comment">//6个缓冲区的值轮流赋给P0</span></span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=<span class="number">6</span>)i=<span class="number">0</span>; <span class="comment">//让i在0-5之间循环变化</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="3-5-4-function-h的内容">3.5.4 function.h的内容</h4>
<p>分析一下<code>reg52.h</code>文件里发现有P3的8个IO端口的定义</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sbit RD   = P3^<span class="number">7</span>;</span><br><span class="line">sbit WR   = P3^<span class="number">6</span>;</span><br><span class="line">sbit T1   = P3^<span class="number">5</span>;</span><br><span class="line">sbit T0   = P3^<span class="number">4</span>;</span><br><span class="line">sbit INT1 = P3^<span class="number">3</span>;</span><br><span class="line">sbit INT0 = P3^<span class="number">2</span>;</span><br><span class="line">sbit TXD  = P3^<span class="number">1</span>;</span><br><span class="line">sbit RXD  = P3^<span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>那我们也可以懂得把之前的<code>sbit LED2 = P0^0;</code>等放在<code>function.h</code>中，以及在<code>function.c</code>封装有的函数和初始化的数组都需要在<code>function.h</code>中声明一下。比如在<code>function.c</code>中定义好了<code>LED_Init()</code>，在<code>function.h</code>就要<code>void LED_Init();</code>声明一下。</p>
<h4 id="3-5-5-数码管显示函数">3.5.5 数码管显示函数</h4>
<p>有时我们需要6个数码管显示我们想要看到的数字，比如计算结果呈现在数码管上，然而当要显示的数为“520”时又不想前面的3个数码管亮（也就是高位为0不显示），我们把这部分功能代码封装为带参数的函数，传入的参数就是要显示的数值。参数定义的是unsigned long类型，也就是支持0~4294967296的数值（2的32次方等于4294967296）。</p>
<p>示例一</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShowNumber</span><span class="params">(u32 num)</span> {</span><br><span class="line">    LedBuff[<span class="number">0</span>]=LedChar[num%<span class="number">10</span>];</span><br><span class="line">    LedBuff[<span class="number">1</span>]=LedChar[(num/<span class="number">10</span>)%<span class="number">10</span>];</span><br><span class="line">    LedBuff[<span class="number">2</span>]=LedChar[(num/<span class="number">100</span>)%<span class="number">10</span>];</span><br><span class="line">    LedBuff[<span class="number">3</span>]=LedChar[(num/<span class="number">1000</span>)%<span class="number">10</span>];</span><br><span class="line">    LedBuff[<span class="number">4</span>]=LedChar[(num/<span class="number">10000</span>)%<span class="number">10</span>];</span><br><span class="line">    LedBuff[<span class="number">5</span>]=LedChar[(num/<span class="number">100000</span>)%<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">100000</span>)LedBuff[<span class="number">5</span>] = <span class="number">0xFF</span>;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">10000</span>) LedBuff[<span class="number">4</span>] = <span class="number">0xFF</span>;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">1000</span>)  LedBuff[<span class="number">3</span>] = <span class="number">0xFF</span>;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">100</span>)   LedBuff[<span class="number">2</span>] = <span class="number">0xFF</span>;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">10</span>)    LedBuff[<span class="number">1</span>] = <span class="number">0xFF</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>示例二</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShowNumber</span><span class="params">(u32 num)</span></span><br><span class="line">{</span><br><span class="line">    u32 i;</span><br><span class="line">    u8 x=<span class="number">5</span>;<span class="comment">//每次被调用都会从5开始 </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">100000</span>;i&gt;<span class="number">0</span>;i/=<span class="number">10</span>)</span><br><span class="line">    { </span><br><span class="line">        <span class="keyword">if</span>(num&lt;i)LedBuff[x] = <span class="number">0xFF</span>;</span><br><span class="line">        <span class="keyword">else</span> LedBuff[x]=LedChar[(num/i)%<span class="number">10</span>];</span><br><span class="line">        x--;</span><br><span class="line">    }   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这两段代码都能实现我们想要的功能，示例1可读性强，让人一看就明白了代码的作用。而示例2书写量少，比较简洁，但在阅读理解上需要我们转一下弯，经过测试这两段代码的执行时间，发现示例1比示例2快5ms左右，这种情况下毫无疑问我们肯定是选择示例1暂时作为实用代码。</p>
<p>可是在后期的教程中用到定时器中断来扫描数码管显示时，示例1的代码效果不尽人意，关于漏洞在哪大家后面可以尝试自己寻找。</p>
<p>在使用示例2时虽然显示效果比示例1的好，但是费时长，所以这两段代码都不是实用型代码。</p>
<p>代码参考</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShowNumber</span><span class="params">(u32 num)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> i;<span class="comment">//取值范围-128~127</span></span><br><span class="line">    u8 buf[<span class="number">6</span>];    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)    <span class="comment">//把长整型数转换为6位十进制的数组</span></span><br><span class="line">    {</span><br><span class="line">        buf[i] = num % <span class="number">10</span>;</span><br><span class="line">        num = num / <span class="number">10</span>;    <span class="comment">//舍掉个位数，重新装载</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">5</span>; i&gt;=<span class="number">1</span>; i--)   <span class="comment">//从最高位起，遇到0填充不显示的代码，遇到非0则退出循环</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (buf[i] == <span class="number">0</span>)</span><br><span class="line">            LedBuff[i] = <span class="number">0xFF</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> ( ; i&gt;=<span class="number">0</span>; i--)     <span class="comment">//剩余低位都如实转换为数码管显示字符</span></span><br><span class="line">    {</span><br><span class="line">        LedBuff[i] = LedChar[buf[i]];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这部分代码我们来举个例子理解，假如传入的参数为125，第一个for循环就是实现以下功能</p>
<p>buf[5]=0; buf[4]=0; buf[3]=0; buf[2]=1; buf[1]=2; buf[0]=5;</p>
<p>第二个for循环i等于2之后就退出了循环，第三个for循环i是等于2，然后填充好要显示的1,2,5给数码管缓存区。</p>
<h4 id="3-5-6-带返回值的函数">3.5.6 带返回值的函数</h4>
<p>之前封装的函数都是void类型无返回值的函数。随着学习的深入，我们需要把C语言的精髓学到家。</p>
<p>前面讲的<code>function.c</code>中没有提及过按键的函数封装。按键功能函数都需要定义全局变量，这种过多的使用全局变量是编程的大忌。随着我们使用按键越来越灵活，就不是简单的让一两个变量加加减减而已了，所以现在我们要更加的去贴合嵌入式编程的方式，那么按键的使用如果用函数封装的话，需要用到函数返回值的相关知识。</p>
<ul>
<li>举例：首先我们定义一个不带参数且返回值为unsigned char型的函数，函数名为<code>KEY4_Scan()</code>，里面的内容跟以前的不支持连按函数都差不多，只是我们把执行功能代码部分改为<code>return 1</code>。当按键<code>按下抬起</code>时我们函数的返回值为1，其他情况返回值为0，这样死循环里不断更新key的值，而大多数时候没有按键动作，所以死循环里的key的值都是0，有按键动作了，key等于1就执行功能代码，下一个循环没有按键动作了key又等于0就不执行功能代码了。</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"function.h"</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TIMES 1000 <span class="comment">//死循环里的代码量少，所以把阈值调大些</span></span></span><br><span class="line"></span><br><span class="line">sbit KEY4 = P2^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">KEY_Scan</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">static</span> u8 key_up = <span class="number">1</span>;</span><br><span class="line">    <span class="type">static</span> u16 times;</span><br><span class="line">    <span class="keyword">if</span>(key_up == <span class="number">0</span>) {</span><br><span class="line">        times++;</span><br><span class="line">        <span class="keyword">if</span>(KEY4 == <span class="number">1</span> &amp;&amp; times &gt;= TIMES) {</span><br><span class="line">            times = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    key_up = KEY4;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() {</span><br><span class="line">    u8 key; <span class="comment">//用来读取按键动作的返回值</span></span><br><span class="line">    LED_Init(); <span class="comment">//初始化LED硬件模块</span></span><br><span class="line">    P2 = <span class="number">0xF7</span>; <span class="comment">//让K4具备能被拉低的条件</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        key=KEY4_Scan();</span><br><span class="line">        <span class="keyword">if</span>(key==<span class="number">1</span>)LED2=!LED2;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-6-typedef关键字">3.6 typedef关键字</h3>
<p>使用typedef我们可以对代码进行简化，比如<code>unsigned int</code>的定义，我们用<code>typedef unsigned int u16;</code>声明，u16就是用一个更加简洁的名字来取代<code>unsigned int</code>区定义16位的变量。</p>
<p>用<code>typedef unsigned char u8;</code>的话，u8就是用来定义8位的变量，或者像之前定义的数组也可以像这样<code>u8 LEDSET[8]={0xFE,0xFD,0xFB,0xF7,0xEF,0xDF,0xBF,0x7F};</code>去定义。</p>
<p>有时需要定义32位的变量，就用“typedef unsigned long u32;”即可。虽然**#define<strong>与</strong>typedef**的作用有点意思相近，但“#define u16 unsigned int”是不严谨的编写习惯，不建议这样使用，原因大家可上网了解。</p>
<h3 id="3-7-指针">3.7 指针</h3>
<p>指针是C语言的灵魂，利用指针可以直接而快速的处理内存中的各种数据结构中的数据，特别是<code>数组、字符串和内存的动态分配</code>等，它为函数之间各类数据传递提供了简洁便利的方法。</p>
<h4 id="3-7-1-指针的概念与指针变量的声明">3.7.1 指针的概念与指针变量的声明</h4>
<h5 id="3-7-1-1-变量的地址">3.7.1.1 变量的地址</h5>
<p>要研究指针，我们得先来深入理解<code>内存地址</code>这个概念。打个比方：整个内存就相当于一个拥有很多房间的大楼，每个房间都有房间号，比如从 101、102、103 一直到 NNN，我们可以说这些房间号就是房间的地址。相对应的内存中的每个单元也都有自己的编号，比如从0x00、0x01、0x02 一直到 0xNN，我们同样可以说这些编号就是<code>内存单元</code>的地址。房间里可以住人，对应的内存单元里就可以“住进”变量了：假如一位名字叫 A 的人住在 101 房间，我们可以说 A 的住址就是 101，或者 101 就是 A 的住址；对应的，假如一个名为 x 的变量住在编号为 0x00 的这个内存单元中，那么我们可以说变量 x 的内存地址就是 0x00，或者 0x00就是变量 x 的地址。</p>
<p>基本的内存单元是<code>字节</code>，英文单词为 Byte，我们所使用的 STC89C52 单片机共有 <code>512 </code>字节的 RAM，就是我们所谓的内存，但它分为内部 256 字节和外部 256 字节，我们仅以内部的 256 字节为例，很明显其地址的编号从 0 开始就是<code>0x00～0xFF</code>。我们用 C 语言定义的各<br>
种变量就存在 0x00～0xFF 的地址范围内，而不同类型的变量会占用不同数量的内存单元，即字节，可以结合前面讲过的 C 语言变量类型深入理解。假如现在定义了 unsigned char a = 1; unsigned char b = 2; unsigned int c = 3; unsigned long d = 4; 这样 4 个变量，我们把这 4 个变量分别放到内存中，就会是表 12-1 中所列的样子，我们先来大概了解一下他们的存储方式。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.imgdb.cn/item/646099320d2dde5777bf32f9.png" alt=""></p>
<p>变量 a、b 和 c 和 d 之间的变量类型不同，因此在内存中所占的存储单元也不一样，a 和b 都占一个字节，c 占了 2 个字节，而 d 占了 4 个字节。那么，a 的地址就是 0x00，b 的地址就是 0x01，c 的地址就是 0x02，d 的地址就是 0x04，它们的地址的表达方式可以写成：<code>&amp;a，&amp;b，&amp;c，&amp;d</code>。这样就代表了相应变量的地址，C 语言中变量前加一个&amp;表示取这个变量的地址，&amp;在这里就叫做<code>取址符</code>。</p>
<p>讲到这里，有一点延伸内容，大家可以了解下：比如变量 c 是 unsigned int 类型的，占了2 个字节，存储在了0x02 和0x03 这两个内存地址上，那么0x02 是它的<code>低字节</code>还是<code>高字节</code>呢？这个问题由所用的 <code>C 编译器与单片机架构</code>共同决定，单片机类型不同就有可能不同，大家知道这么回事即可。比如：在我们使用的 Keil+51 单片机的环境下，0x02 存的是高字节，0x03存的是低字节。这是编译底层实现上的细节问题，并不影响上层的应用，如下这两种情况在应用上丝毫不受这个细节的影响：强制类型转换——b = (unsigned char) c，那么 b 的值一定是 c 的低字节；取地址——&amp;c，则得到的一定是 0x02，这都是 C 语言本身所决定的规则，不因单片机编译器的不同而有所改变。</p>
<p>实际生活中，我们要寻找一个人有两种方式，一种方式是通过它的名字来找人，还有第二种方式就是通过它的住宅地址来找人。我们在派出所的户籍管理系统的信息输入方框内，输入小明的家庭住址，系统会自动指向小明的相关信息，输入小刚的家庭住址，系统会自动指向小刚的相关信息。这个供我们输入地址的方框，在户籍管理系统叫做<code>地址输入框</code>。</p>
<p>那么，在 C 语言中，我们要访问一个变量，同样有两种方式：</p>
<ol>
<li>一种是通过<code>变量名</code>来访问。</li>
<li>另一种自然是通过变量的地址来访问。</li>
</ol>
<p>在 C 语言中，<code>地址</code>就等同于<code>指针</code>，<code>变量的地址</code>就是<code>变量的指针</code>。我们要把地址送到上边那个所谓的<code>地址输入框</code>内，这个<code>地址输入框</code>既可以输入 x 的指针，又可以输入 y 的指针，所以相当于一个特殊的变量——<code>保存指针</code>的变量，因此称之为指针变量，简称为指针，而通常我们说的指针就是指指针变量。 地址输入框输入谁的地址，指向的就是这个人的信息，而给指针变量输入哪个普通变量的地址，它自然就指向了这个变量的内容，通常的说法就是指针指向了该变量。</p>
<h5 id="3-7-1-2-指针变量的声明">3.7.1.2 指针变量的声明</h5>
<p>在 C 语言中，变量的地址往往都是编译系统<code>自动分配</code>的，对我们用户来说，我们是不知道某个变量的具体地址的。所以我们定义一个指针变量 p，把普通变量 a 的地址直接送给指针变量 p 就是<code>p = &amp;a;</code>这样的写法</p>
<p>对于指针变量 p 的定义和初始化，一般有两种方式：</p>
<ol>
<li>定义时直接进行初始化赋值</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p = &amp;a;</span><br></pre></td></tr></tbody></table></figure>
<ol start="2">
<li>定义后再进行赋值</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line">p = &amp;a;</span><br></pre></td></tr></tbody></table></figure>
<p>大家仔细看会看出来这两种写法的区别，它们都是正确的。我们在定义的指针变量前边加了个*，这个*p 就代表了这个p是个指针变量，不是个普通的变量，它是专门用来存放变量地址的。此外，我们定义*p 的时候，用了unsigned char来定义，这里表示的是这个指针指向的变量类型是 unsigned char 型的</p>
<p>指针变量似乎比较好理解，大家也能很容易就听明白。但是为什么很多人弄不明白指针呢？因为在 C 语言中，有一些运算和定义，他们是有区别的，很多同学就是没弄明白它们的区别，指针就始终学不好。这里我要重点强调两个区别，只要把这两个区别弄明白了，起码指针变量这部分就不是问题了。这两个重点现在大家死记硬背，直接记住即可，靠理解有可能混淆概念。</p>
<ol>
<li>指针变量 p 和普通变量 a 的区别：我们定义一个变量 a，同时也可以给变量 a 赋值 a = 1，也可以赋值 a = 2。但是，我们我们定义一个指针变量 p，另外还定义了一个普通变量 a=1，普通变量 b=2，那么这个指针变量可以指向 a 的地址，也可以指向 b 的地址，可以写成 p = &amp;a，也可以写成 p = &amp;b，但就是不能写成<code>p = 1 或者 p = 2 或者 p = a</code>，这三种表达方式都是错的。因此这个地方，不要看到定义*p 的时候前边有个 unsigned char 型，就错误的赋值 p=1，这个只是说明 p 指向的变量是这个 unsigned char 类型的，而 p 本身，是指针变量，不可以给它赋值普通的值或者变量，后边我们会直接把指针变量称之为指针，大家要注意一下这个小细节。</li>
<li><code>定义</code>指针变量*p 和<code>取值运算</code>*p 的区别： <code>*</code>这个符号，在我们的 C 语言有三个用法，第一个用法很简单，乘法操作就是用这个符号；第二个用法，是定义指针变量的时候用的，比如 <code>unsigned char *p</code>，这个地方使用“*”代表的意思是 p 是一个指针变量，而非普通的变量。还有第三种用法，就是取值运算，和定义指针变量是完全两码事，比如</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line">p = &amp;a;</span><br><span class="line">b = *p;</span><br></pre></td></tr></tbody></table></figure>
<p>这样两步运算完了之后，b 的值就成了 1 了。在这段代码中，&amp;a 表示取 a 这个变量的地址，把这个地址送给 p 之后，再用*p运算表示的是取指针变量p指向的地址的变量的值，又把这个值送给了 b，最终的结果相当于 b=a。同样是*p，放在定义的位置就是定义指针变量，放在执行代码中就是取值运算。</p>
<h5 id="3-7-1-3-简单示例">3.7.1.3 简单示例</h5>
<p>使用指针实现流水灯</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"function.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShiftLeft</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf = <span class="number">0x01</span>;</span><br><span class="line">	LED_Init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">		P0 = ~buf; <span class="comment">//缓冲值取反发送到P0口</span></span><br><span class="line">		delay_ms(<span class="number">2000</span>);</span><br><span class="line">		ShiftLeft(&amp;buf); <span class="comment">//缓冲值左移一位</span></span><br><span class="line">		<span class="keyword">if</span> (buf == <span class="number">0</span>) {</span><br><span class="line">			buf = <span class="number">0x01</span>; </span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将指针变量p指向的字节左移一位*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShiftLeft</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *p)</span> {</span><br><span class="line">	*p = *p &lt;&lt; <span class="number">1</span>; <span class="comment">//利用指针变量可以向函数外输出运算结果</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对比之前的函数调用，大家是否看明白，如果是普通变量传递，只能单向的，也就是说，主函数传递给子函数的值，子函数只能使用却不能改变。而现在我们传递的是指针，不仅仅子函数可以使用 buf 里边的值，而且还可以<code>对 buf 里边的值进行修改</code>。</p>
<p>只要是*p 前边带了变量类型如 unsigned char，就是表示定义了一个指针变量 p，而执行代码中的*p，是指 p 所指向的内容。</p>
<h4 id="3-7-2-指向数组元素的指针">3.7.2 指向数组元素的指针</h4>
<h5 id="3-7-2-1-指向数组元素的指针和运算法则">3.7.2.1 指向数组元素的指针和运算法则</h5>
<p>所谓指向数组元素的指针，其本质还是变量的指针。因为数组中的每个元素，其实都可以直接看成是一个变量，所以指向数组元素的指针，也就是变量的指针。</p>
<p>指向数组元素的指针不难，但很常用。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> number[<span class="number">10</span>] = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>};</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p</span><br></pre></td></tr></tbody></table></figure>
<p>如果我们写<code>p = &amp;number[0];</code>那么指针p就指向了number的第0号元素，也就是把number[0]的地址赋值给了p，同理，如果写<code>p=&amp;number[1];</code>p 就指向了数组 number 的第 1号元素。<code>p = &amp;number[x];</code>其中 x 的取值范围是0～9，就表示<code>p</code>指向了数组number的第 x 号元素。</p>
<p>指针本身，也可以进行几种简单的运算，这几种运算对于数组元素的指针来说应用最多。</p>
<ol>
<li>比较运算。比较的前提是<code>两个指针指向同种类型的对象</code>，比如两个指针变量<code>p</code>和<code>q</code>它们指向了具有同种数据类型的数组，那它们可以进行&lt;，&gt;，&gt;=，&lt;=，==等关系运算。如果<code>p==q</code>为真的话，表示这两个指针指向的是<code>同一个元素</code>。</li>
<li><code>指针</code>和<code>整数</code>可以直接进行加减运算。比如还是上边我们那个指针p和数组number，如果<code>p = &amp;number[0]</code>，那么p+1就指向了number[1]，p+9就指向了number[9]。当然了，如果p = &amp;number[9]，p-9 也就指向了number[0]。</li>
<li>两个指针变量在<code>一定条件下</code>可以进行减法运算。如<code>p = &amp;number[0]; q = &amp;number[9];</code>那么<code>q-p</code>的结果就是 9。但是这个地方要特别注意，这个 9 代表的是<code>元素的个数</code>，而不是真正的地址差值。<code>如果我们的 number 的变量类型是 unsigned int 型，占 2 个字节，q-p 的结果依然是 9，因为它代表的是数组元素的个数</code>。</li>
</ol>
<p>在数组元素指针这里还有一种情况，就是数组名字其实就代表了数组元素的首地址，即</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;number[<span class="number">0</span>];</span><br><span class="line">p = number;</span><br></pre></td></tr></tbody></table></figure>
<p>这两种表达方式是等价的，因此以下几种表达形式和内容需要注意：</p>
<p>根据指针的运算规则，p+x 代表的是 number[x]的<code>地址</code>，那么number+x代表的也是number[x]的<code>地址</code>。或者说，它们指向的都是number数组的第 x 号元素。*(p+x)和*(number+x)都表示 number[x]。</p>
<p>指向数组元素的指针也可以表示成数组的形式，也就是说，允许指针变量带下标，即 p[i]和*(p+i)是等价的。但是为了避免混淆与规范起见，这里我们建议大家不要写成前者，而一律采用后者的写法。但如果看到别人那么写，也知道是怎么回事即可。</p>
<p>二维数组元素的指针和一维数组类似，需要介绍的内容不多。假如现在一个指针变量p和一个二维数组number[3][4]，它的地址的表达方式也就是 p=&amp;number[0][0]，有一个地方要注意，既然数组名代表了数组元素的首地址，那么也就是说p和 number 都是指数组的首地址。对二维数组来说，number[0]，number[1]，number[2]都可以看成是一维数组的数组名字，所以number[0]等价于&amp;number[0[0]，number[1]等价于&amp;number[1][0]，number[2]等价于&amp;number[2][0]。加减运算和一维数组是类似的，不再详述。</p>
<h5 id="3-7-2-1-指向数组元素指针的实例">3.7.2.1 指向数组元素指针的实例</h5>
<p>在 C 语言里，<code>sizeof()</code>可以用来获取括号内的对象所占用的<code>内存字节数</code>，虽然它写作函数的形式，但它并不是一个函数，而是 C 语言的一个关键字，<code>sizeof()</code>整体在程序代码中就相当于一个常量，也就是说这个获取操作是在<code>程序编译</code>的时候进行的，而不是在程序运行的时候进行。这是一个实际编程中很有用的关键字，灵活运用它可以为程序带来更好的可读性、易维护性和可移植性，在后续的例程学习中将会慢慢有所体会的。</p>
<p><code>sizeof()</code>括号中可以是<code>变量名</code>，也可以是<code>变量类型名</code>，其结果是等效的。而其更大的用处是与<code>数组名搭配使用</code>，这样可以<strong>获取整个数组占用的字节数</strong>，就不用自己动手计算了，可以避免错误，而如果日后改变了数组的维数时，也不需要再到执行代码中逐个修改，便于程序的维护和移植。</p>
<p>下面是一个简单的例程</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">bit cmdArrived = <span class="number">0</span>; <span class="comment">//命令到达标志，即接收到上位机下发的命令</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> cmdIndex = <span class="number">0</span>; <span class="comment">//命令索引，即与上位机约定好的数组编号 </span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> cntTxd = <span class="number">0</span>;   <span class="comment">//串口发送计数器 </span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *ptrTxd;      <span class="comment">//串口发送指针 </span></span><br><span class="line"> </span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> array1[<span class="number">1</span>] = {<span class="number">1</span>}; </span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> array2[<span class="number">2</span>] = {<span class="number">1</span>,<span class="number">2</span>}; </span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> array3[<span class="number">4</span>] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>}; </span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> array4[<span class="number">8</span>] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>}; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigUART</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> baud)</span>; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">{ </span><br><span class="line">    EA = <span class="number">1</span>;  <span class="comment">//开总中断 </span></span><br><span class="line"> ConfigUART(<span class="number">9600</span>); <span class="comment">//配置波特率为 9600 </span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">    { </span><br><span class="line">        <span class="keyword">if</span> (cmdArrived) </span><br><span class="line">        { </span><br><span class="line">            cmdArrived = <span class="number">0</span>; </span><br><span class="line">            <span class="keyword">switch</span> (cmdIndex) </span><br><span class="line">            { </span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line"> ptrTxd = array1; <span class="comment">//数组 1 的首地址赋值给发送指针 </span></span><br><span class="line"> cntTxd = <span class="keyword">sizeof</span>(array1); <span class="comment">//数组 1 的长度赋值给发送计数器 </span></span><br><span class="line">                    TI = <span class="number">1</span>;   <span class="comment">//手动方式启动发送中断，处理数据发送 </span></span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: </span><br><span class="line">                    ptrTxd = array2; </span><br><span class="line">                    cntTxd = <span class="keyword">sizeof</span>(array2); </span><br><span class="line">                    TI = <span class="number">1</span>; </span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>: </span><br><span class="line">                    ptrTxd = array3; </span><br><span class="line">                    cntTxd = <span class="keyword">sizeof</span>(array3); </span><br><span class="line">                    TI = <span class="number">1</span>; </span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>: </span><br><span class="line">                    ptrTxd = array4; </span><br><span class="line">                    cntTxd = <span class="keyword">sizeof</span>(array4); </span><br><span class="line">                    TI = <span class="number">1</span>; </span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">            } </span><br><span class="line">        } </span><br><span class="line">    } </span><br><span class="line">} </span><br><span class="line"><span class="comment">/* 串口配置函数，baud-通信波特率 */</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigUART</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> baud)</span> </span><br><span class="line">{ </span><br><span class="line"> SCON = <span class="number">0x50</span>; <span class="comment">//配置串口为模式 1 </span></span><br><span class="line"> TMOD &amp;= <span class="number">0x0F</span>; <span class="comment">//清零 T1 的控制位 </span></span><br><span class="line"> TMOD |= <span class="number">0x20</span>; <span class="comment">//配置 T1 为模式 2 </span></span><br><span class="line"> TH1 = <span class="number">256</span> - (<span class="number">11059200</span>/<span class="number">12</span>/<span class="number">32</span>)/baud; <span class="comment">//计算 T1 重载值 </span></span><br><span class="line">    TL1 = TH1;     <span class="comment">//初值等于重载值 </span></span><br><span class="line"> ET1 = <span class="number">0</span>; <span class="comment">//禁止 T1 中断 </span></span><br><span class="line">    ES  = <span class="number">1</span>;       <span class="comment">//使能串口中断 </span></span><br><span class="line"> TR1 = <span class="number">1</span>; <span class="comment">//启动 T1 </span></span><br><span class="line">} </span><br><span class="line"><span class="comment">/* UART 中断服务函数 */</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptUART</span><span class="params">()</span> interrupt 4 </span><br><span class="line">{ </span><br><span class="line">    <span class="keyword">if</span> (RI)  <span class="comment">//接收到字节 </span></span><br><span class="line">    { </span><br><span class="line">        RI = <span class="number">0</span>;  <span class="comment">//清零接收中断标志位 </span></span><br><span class="line">        cmdIndex = SBUF;  <span class="comment">//接收到的数据保存到命令索引中 </span></span><br><span class="line">        cmdArrived = <span class="number">1</span>;   <span class="comment">//设置命令到达标志 </span></span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">if</span> (TI)  <span class="comment">//字节发送完毕 </span></span><br><span class="line">    { </span><br><span class="line">        TI = <span class="number">0</span>;  <span class="comment">//清零发送中断标志位 </span></span><br><span class="line">        <span class="keyword">if</span> (cntTxd &gt; <span class="number">0</span>)  <span class="comment">//有待发送数据时，继续发送后续字节 </span></span><br><span class="line">        { </span><br><span class="line">            SBUF = *ptrTxd;  <span class="comment">//发出指针指向的数据 </span></span><br><span class="line">            cntTxd--;         <span class="comment">//发送计数器递减 </span></span><br><span class="line">            ptrTxd++;         <span class="comment">//发送指针递增 </span></span><br><span class="line">        } </span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</article><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://pic.gan1ser.top/eassy/imageonline-co-convertedwebpimage%20(1).webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.gan1ser.top/eassy/imageonline-co-convertedwebpimage%20(1).webp" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://pic.gan1ser.top/eassy/imageonline-co-convertedwebpimage.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.gan1ser.top/eassy/imageonline-co-convertedwebpimage.webp" alt="alipay"></a><div class="post-qr-code-desc">alipay</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://www.gan1ser.top/post/dc68b377.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=《单片机原理及运用》学习笔记&amp;url=https://www.gan1ser.top/post/dc68b377.html&amp;pic=https://pic.gan1ser.top/posts/1.webp/cover" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E7%9F%A5%E8%AF%86/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>知识<span class="tagsPageCount">53</span></a><a class="post-meta__box__tags" href="/tags/%E7%AC%94%E8%AE%B0/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>笔记<span class="tagsPageCount">34</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://pic.gan1ser.top/posts/125.webp/cover" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload="this.media='all'"><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer="defer"></script></div></div></div><div class="post-copyright"><i class="anzhiyufont anzhiyu-icon-copyright"></i><div class="post-copyright__author"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://www.gan1ser.top/post/dc68b377.html">原创</a><a class="post-copyright-title"><span>《单片机原理及运用》学习笔记</span></a></div><div class="post-copyright-info-box"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"></span><a class="link" href="https://www.gan1ser.top">GanSer</a></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a class="link" href="https://www.gan1ser.top/post/dc68b377.html">https://www.gan1ser.top/post/dc68b377.html</a></span><span class="copy-button" onclick="rm.copyPageUrl('https://www.gan1ser.top/post/dc68b377.html')"><i class="anzhiyufont anzhiyu-icon-copy"></i></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.gan1ser.top" target="_blank">GanSer</a>！</span></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/38ff18f6.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.gan1ser.top/posts/2.webp/cover" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《概率论与数理统计》学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/post/17311.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.gan1ser.top/posts/54.webp/cover" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">解决Aurora数学公式渲染问题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/1b809c7b.html" title="常用内建模块(一)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.gan1ser.top/posts/18.webp/cover" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-07-30</div><div class="title">常用内建模块(一)</div></div></a></div><div><a href="/post/ca1e50ee.html" title="Deformable ConvNets-可变形卷积学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.gan1ser.top/posts/103.webp/cover" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-14</div><div class="title">Deformable ConvNets-可变形卷积学习</div></div></a></div><div><a href="/post/8c94c2b9.html" title="Markdown公式语法汇总"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.gan1ser.top/posts/109.webp/cover" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-01-10</div><div class="title">Markdown公式语法汇总</div></div></a></div><div><a href="/post/5fac20c9.html" title="Numpy入门（一）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.gan1ser.top/posts/117.webp/cover" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-07-31</div><div class="title">Numpy入门（一）</div></div></a></div><div><a href="/post/22a46f43.html" title="Numpy入门（三）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.gan1ser.top/posts/115.webp/cover" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-08-09</div><div class="title">Numpy入门（三）</div></div></a></div><div><a href="/post/6fbacc11.html" title="Numpy入门（二）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.gan1ser.top/posts/114.webp/cover" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-07-31</div><div class="title">Numpy入门（二）</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="author-info-top"> <div class="card-info-avatar"><a class="avatar-img" href="/about"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/63f16cddf144a010070697c8.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></a><div class="author-status-box"><div class="author-status"><g-emoji class="g-emoji" alias="writing_hand" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/270d.png">✍️</g-emoji><span>on Studying</span></div></div></div></div><div class="author-info__sayhi" id="author-info__sayhi"></div><h1 class="author-info__name">GanSer</h1><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(11, 231, 255);">（づ￣3￣）づ╭❤～恭喜小伙伴发现博客世界的一角，这是一名普通大学生关于<b style="color:#078B99">知识、科技、生活</b>相关的记录和分享，还有<b style="color:#078B99">课外学习</b>和<b style="color:#078B99">搞怪</b>。</div></div><div class="banner-button-group"><a class="banner-button" onclick="pjax.loadUrl(&quot;/about/&quot;)"><span class="banner-button-text">了解更多</span><i class="anzhiyufont anzhiyu-icon-arrow-circle-right" style="font-size: 1.5rem"></i></a></div><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/Gan1Ser" target="_blank" title="Github"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-github"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=1742158140@qq.com" target="_blank" title="Email"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a><a class="social-icon faa-parent animated-hover" href="/atom.xml" target="_blank" title="RSS"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-RSS"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/628891869" target="_blank" title="BiliBili"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg></a></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://pic.imgdb.cn/item/64ba6cbb1ddac507cc15022b.gif) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://pic.imgdb.cn/item/64ba67aa1ddac507cc03647b.gif) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91%E4%B8%8E%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-text">一、单片机开发与仿真环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-keil-%E8%BD%AF%E4%BB%B6"><span class="toc-text">1.1 Keil 软件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-keil%E8%BD%AF%E4%BB%B6%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-text">1.1.1 Keil软件的简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-keil-c51%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%95%8C%E9%9D%A2"><span class="toc-text">1.1.2 Keil C51的工作界面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-keil-c51%E5%BB%BA%E7%AB%8B%E5%B7%A5%E7%A8%8B"><span class="toc-text">1.1.3 Keil C51建立工程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-4-%E5%BB%BA%E7%AB%8B-%E7%BC%96%E8%BE%91c%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="toc-text">1.1.4 建立/编辑C语言源程序文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-5-%E5%B7%A5%E7%A8%8B%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-text">1.1.5 工程的设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-6-keil-c51-%E7%9A%84debug"><span class="toc-text">1.1.6 Keil C51 的Debug</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-7-%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E8%B5%84%E6%BA%90%E7%9A%84%E6%9F%A5%E7%9C%8B%E5%92%8C%E4%BF%AE%E6%94%B9"><span class="toc-text">1.1.7 存储空间资源的查看和修改</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-proteus%E8%BD%AF%E4%BB%B6"><span class="toc-text">1.2 Proteus软件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-proteus%E8%BD%AF%E4%BB%B6%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-text">1.2.1 Proteus软件的简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-proteus%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-text">1.2.2 Proteus简单使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-proteus-8-%E4%B8%8E-keil-c51-%E7%9A%84%E8%81%94%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-text">1.2.3 Proteus 8 与 Keil C51 的联合使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-proteus-%E7%94%BB%E5%87%BA%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F"><span class="toc-text">1.2.4 Proteus 画出单片机的最小系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-5-%E5%AE%9E%E6%88%98%E6%95%99%E5%AD%A6%EF%BC%9A%E6%B5%81%E6%B0%B4%E7%81%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.2.5 实战教学：流水灯的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-stc-isp%E8%BD%AF%E4%BB%B6"><span class="toc-text">1.3 STC-ISP软件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-stc-isp%E8%BD%AF%E4%BB%B6%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-text">1.3.1 STC-ISP软件的简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-stc-isp%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">1.3.2 STC-ISP软件的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-%E5%AE%9E%E6%88%98%E6%95%99%E5%AD%A6%EF%BC%9A-%E7%82%B9%E4%BA%AE%E7%AC%AC%E4%B8%80%E4%B8%AAled%E7%81%AF"><span class="toc-text">1.3.3 实战教学： 点亮第一个LED灯</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%8D%95%E7%89%87%E6%9C%BA%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F"><span class="toc-text">1.4 单片机最小系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-%E7%94%B5%E6%BA%90"><span class="toc-text">1.4.1 电源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-%E6%99%B6%E6%8C%AF"><span class="toc-text">1.4.2 晶振</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3-%E5%A4%8D%E4%BD%8D%E7%94%B5%E8%B7%AF"><span class="toc-text">1.4.3 复位电路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-4-%E5%8D%95%E7%89%87%E6%9C%BA%E7%9C%8B%E9%97%A8%E7%8B%97"><span class="toc-text">1.4.4 单片机看门狗</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-led%E5%B0%8F%E7%81%AF%E5%8E%9F%E7%90%86"><span class="toc-text">1.5 LED小灯原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1-usb%E6%8E%A5%E5%8F%A3%E7%94%B5%E8%B7%AF"><span class="toc-text">1.5.1 USB接口电路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-led%E5%B0%8F%E7%81%AF%E7%94%B5%E8%B7%AF"><span class="toc-text">1.5.2 LED小灯电路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-3-%E5%8D%95%E7%89%87%E6%9C%BA%E7%AB%AF%E5%8F%A3"><span class="toc-text">1.5.3 单片机端口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-4-%E5%AE%9E%E9%99%85led%E7%A1%AC%E4%BB%B6%E8%BF%9E%E6%8E%A5"><span class="toc-text">1.5.4 实际LED硬件连接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-5-4-1-%E4%B8%89%E6%9E%81%E7%AE%A1%E8%AE%A4%E8%AF%86"><span class="toc-text">1.5.4.1 三极管认识</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-5-4-2-%E4%B8%89%E5%85%AB%E8%AF%91%E7%A0%81%E5%99%A8"><span class="toc-text">1.5.4.2 三八译码器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E8%9C%82%E9%B8%A3%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-text">1.6 蜂鸣器原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-1-%E5%8D%95%E7%89%87%E6%9C%BAio%E7%AB%AF%E5%8F%A3%E7%94%B5%E6%B5%81"><span class="toc-text">1.6.1 单片机IO端口电流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-2-%E6%9C%89%E6%BA%90%E8%9C%82%E9%B8%A3%E5%99%A8"><span class="toc-text">1.6.2 有源蜂鸣器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-3-%E6%97%A0%E6%BA%90%E8%9C%82%E9%B8%A3%E5%99%A8"><span class="toc-text">1.6.3 无源蜂鸣器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-4-%E6%97%A0%E6%BA%90%E8%9C%82%E9%B8%A3%E5%99%A8%E9%B8%A3%E5%8F%AB"><span class="toc-text">1.6.4 无源蜂鸣器鸣叫</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE"><span class="toc-text">1.7 独立按键</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-1-%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE%E4%B8%8E%E7%9F%A9%E9%98%B5%E6%8C%89%E9%94%AE"><span class="toc-text">1.7.1 独立按键与矩阵按键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-2-%E6%8C%89%E9%94%AE%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">1.7.2 按键的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-3-%E6%8C%89%E9%94%AE%E7%94%A8%E6%B3%95"><span class="toc-text">1.7.3 按键用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-4-%E6%8C%89%E9%94%AE%E6%A8%A1%E5%BC%8F"><span class="toc-text">1.7.4 按键模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-5-%E4%B8%8D%E6%94%AF%E6%8C%81%E8%BF%9E%E6%8C%89%E6%A8%A1%E5%BC%8F"><span class="toc-text">1.7.5 不支持连按模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-6-%E5%9B%9E%E5%BD%92%E6%8C%89%E9%94%AE"><span class="toc-text">1.7.6 回归按键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-7-%E6%94%AF%E6%8C%81%E8%BF%9E%E6%8C%89-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">1.7.7 支持连按（全局变量）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-8-%E5%8F%8C%E6%A8%A1%E5%BC%8F%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85"><span class="toc-text">1.7.8 双模式函数封装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD"><span class="toc-text">1.8 外部中断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-1-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">1.8.1 寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-8-1-1-%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E5%86%85%E9%83%A8%E8%B5%84%E6%BA%90"><span class="toc-text">1.8.1.1 单片机的内部资源</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-8-1-2-ie0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">1.8.1.2 IE0的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-8-1-3-it0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">1.8.1.3 IT0的作用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-2-%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0"><span class="toc-text">1.8.2 中断函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-8-2-1-%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0%E7%9A%84%E4%B9%A6%E5%86%99"><span class="toc-text">1.8.2.1 中断函数的书写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-8-2-2-ex0%E5%92%8Cea"><span class="toc-text">1.8.2.2 EX0和EA</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-3-%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%90%86%E8%A7%A3%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0"><span class="toc-text">1.8.3 进一步理解中断函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-8-3-1-%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD1"><span class="toc-text">1.8.3.1 外部中断1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-8-3-2-%E6%8C%89%E9%94%AE%E8%A7%A6%E5%8F%91%E4%B8%AD%E6%96%AD"><span class="toc-text">1.8.3.2 按键触发中断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-8-3-3-%E6%8C%89%E9%94%AE%E8%A7%A6%E5%8F%91%E4%B8%AD%E6%96%AD%E6%B6%88%E6%8A%96"><span class="toc-text">1.8.3.3 按键触发中断消抖</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">1.9 定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-9-1-%E6%BA%A2%E5%87%BA"><span class="toc-text">1.9.1 溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-9-2-%E4%B8%A4%E7%A7%8D%E5%AE%9A%E6%97%B6%E6%A8%A1%E5%BC%8F"><span class="toc-text">1.9.2 两种定时模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-9-3-%E5%AE%9A%E6%97%B6%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">1.9.3 定时器模式的选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-9-4-%E5%AE%9A%E6%97%B6%E6%97%B6%E9%95%BF%E7%9A%84%E5%81%9A%E6%B3%95"><span class="toc-text">1.9.4 定时时长的做法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-9-5-%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AE%80%E5%8D%95%E8%BF%90%E7%94%A8"><span class="toc-text">1.9.5 定时器简单运用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-9-6-%E5%AE%9A%E6%97%B6%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F2"><span class="toc-text">1.9.6 定时器工作模式2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-9-7-%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">1.9.7 定时器中断函数的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-9-8-%E5%AE%9A%E6%97%B6%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BC%98%E5%8C%96"><span class="toc-text">1.9.8 定时器初始化优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-9-9-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="toc-text">1.9.9 初始化需要注意的点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-9-10-%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83"><span class="toc-text">1.9.10 代码参考</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-9-11-%E5%BE%AE%E8%B0%83%E5%AE%9A%E6%97%B6%E7%B2%BE%E7%A1%AE%E6%97%B6%E9%97%B4"><span class="toc-text">1.9.11 微调定时精确时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-9-12-%E5%B0%81%E8%A3%85%E5%87%BD%E6%95%B0"><span class="toc-text">1.9.12 封装函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-9-13-%E5%91%BC%E5%90%B8%E7%81%AF"><span class="toc-text">1.9.13 呼吸灯</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-%E8%88%B5%E6%9C%BA"><span class="toc-text">1.10 舵机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-10-1-%E8%AE%A4%E8%AF%86%E8%88%B5%E6%9C%BA"><span class="toc-text">1.10.1 认识舵机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-10-2-%E8%88%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-text">1.10.2 舵机控制原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-10-3-%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6%E8%88%B5%E6%9C%BA"><span class="toc-text">1.10.3 按键控制舵机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-10-4-%E5%91%BC%E5%90%B8%E7%81%AF%E4%B8%8E%E8%88%B5%E6%9C%BA"><span class="toc-text">1.10.4 呼吸灯与舵机</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-11-%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1"><span class="toc-text">1.11 串口通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-11-1-%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E5%85%A5%E9%97%A8"><span class="toc-text">1.11.1 串口通信入门</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-11-2-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E7%BD%AE"><span class="toc-text">1.11.2 软件设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-11-3-%E4%B8%B2%E5%8F%A3%E9%85%8D%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-text">1.11.3 串口配置函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-11-4-ascii%E7%A0%81%E4%B8%8E%E9%80%9A%E4%BF%A1%E6%95%B0%E6%8D%AE"><span class="toc-text">1.11.4 ASCII码与通信数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-11-5-printf%E7%B3%BB%E5%88%97%E7%9A%84%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.11.5 printf系列的函数实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-12-1602%E6%B6%B2%E6%99%B6%E5%B1%8F"><span class="toc-text">1.12 1602液晶屏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%AE%9E%E6%88%98%E6%95%99%E5%AD%A6%E4%BB%A5%E5%8F%8A%E4%BD%9C%E5%93%81%E5%B1%95%E7%A4%BA"><span class="toc-text">二、实战教学以及作品展示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-led"><span class="toc-text">2.1 LED</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E7%82%B9%E4%BA%AE%E7%AC%AC%E4%B8%80%E4%B8%AAled%E7%81%AF"><span class="toc-text">2.1.1 点亮第一个LED灯</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1-1-%E6%BA%90%E7%A0%81"><span class="toc-text">2.1.1.1 源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1-2-%E4%BB%BF%E7%9C%9F"><span class="toc-text">2.1.1.2 仿真</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1-3-%E5%AE%9E%E7%89%A9"><span class="toc-text">2.1.1.3 实物</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E9%97%AA%E7%83%81%E7%9A%84led%E7%81%AF"><span class="toc-text">2.1.2 闪烁的LED灯</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-2-1-%E6%BA%90%E7%A0%81"><span class="toc-text">2.1.2.1 源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-2-2-%E4%BB%BF%E7%9C%9F"><span class="toc-text">2.1.2.2 仿真</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-2-3-%E5%AE%9E%E7%89%A9"><span class="toc-text">2.1.2.3 实物</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-%E4%B8%89%E4%B8%AA%E5%B0%8F%E7%81%AF%E5%90%8C%E6%97%B6%E9%97%AA%E7%83%81"><span class="toc-text">2.1.3 三个小灯同时闪烁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-3-1-%E6%BA%90%E7%A0%81"><span class="toc-text">2.1.3.1 源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-3-2-%E4%BB%BF%E7%9C%9F"><span class="toc-text">2.1.3.2 仿真</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-3-3-%E5%AE%9E%E7%89%A9"><span class="toc-text">2.1.3.3 实物</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-3-4-%E4%BC%98%E5%8C%96"><span class="toc-text">2.1.3.4 优化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-%E6%B5%81%E6%B0%B4%E7%81%AF"><span class="toc-text">2.1.4 流水灯</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-4-1-%E6%BA%90%E7%A0%81"><span class="toc-text">2.1.4.1 源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-4-2-%E4%BB%BF%E7%9C%9F"><span class="toc-text">2.1.4.2 仿真</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-4-3-%E5%AE%9E%E7%89%A9"><span class="toc-text">2.1.4.3 实物</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-4-4-%E4%BC%98%E5%8C%96"><span class="toc-text">2.1.4.4 优化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-%E4%BA%A4%E9%80%9A%E7%81%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.1.4 交通灯的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-4-1-%E6%BA%90%E7%A0%81"><span class="toc-text">2.1.4.1 源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-4-2-%E4%BB%BF%E7%9C%9F"><span class="toc-text">2.1.4.2 仿真</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-5-%E8%8A%B1%E5%BC%8F%E6%B5%81%E6%B0%B4%E7%81%AF"><span class="toc-text">2.1.5 花式流水灯</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-5-1-%E5%8F%B3%E7%A7%BB%E6%B5%81%E6%B0%B4%E7%81%AF%E6%BA%90%E7%A0%81"><span class="toc-text">2.1.5.1 右移流水灯源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-5-2-%E5%BE%AA%E7%8E%AF%E6%B5%81%E6%B0%B4%E7%81%AF"><span class="toc-text">2.1.5.2 循环流水灯</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-5-3-%E5%A5%87%E5%81%B6%E6%B5%81%E6%B0%B4%E7%81%AF"><span class="toc-text">2.1.5.3 奇偶流水灯</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-5-4-%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6%E6%B5%81%E6%B0%B4%E7%81%AF"><span class="toc-text">2.1.5.4 按键控制流水灯</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%9C%82%E9%B8%A3%E5%99%A8"><span class="toc-text">2.2 蜂鸣器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E8%9C%82%E9%B8%A3%E5%99%A8%E9%A9%B1%E5%8A%A8%E4%BB%A3%E7%A0%81"><span class="toc-text">2.2.1 蜂鸣器驱动代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E8%9C%82%E9%B8%A3%E5%99%A8%E9%B8%A3%E5%8F%AB"><span class="toc-text">2.2.2 蜂鸣器鸣叫</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E6%8E%A7%E5%88%B6%E8%9C%82%E9%B8%A3%E5%99%A8"><span class="toc-text">2.2.3 控制蜂鸣器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-%E8%9C%82%E9%B8%A3%E5%99%A8-led%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B"><span class="toc-text">2.2.4 蜂鸣器+LED实际案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%95%B0%E7%A0%81%E7%AE%A1"><span class="toc-text">2.3 数码管</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E6%95%B0%E7%A0%81%E7%AE%A1%E5%8E%9F%E7%90%86"><span class="toc-text">2.3.1 数码管原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E9%9D%99%E6%80%81%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA"><span class="toc-text">2.3.2 静态数码管显示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-%E5%8A%A8%E6%80%81%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA"><span class="toc-text">2.3.3 动态数码管显示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4-4%E5%8F%AA%E6%95%B0%E7%A0%81%E7%AE%A1%E6%BB%9A%E5%8A%A8%E6%98%BE%E7%A4%BA0-3"><span class="toc-text">2.3.4 4只数码管滚动显示0~3</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-4-1-%E6%BA%90%E7%A0%81"><span class="toc-text">2.3.4.1 源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-4-2-%E4%BB%BF%E7%9C%9F"><span class="toc-text">2.3.4.2 仿真</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-5-8%E5%8F%AA%E6%95%B0%E7%A0%81%E7%AE%A1%E6%BB%9A%E5%8A%A8%E6%98%BE%E7%A4%BA8-f"><span class="toc-text">2.3.5 8只数码管滚动显示8~F</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-5-1-%E6%BA%90%E7%A0%81"><span class="toc-text">2.3.5.1 源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-5-2-%E4%BB%BF%E7%9C%9F"><span class="toc-text">2.3.5.2 仿真</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-6-8%E5%8F%AA%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%90%8C%E5%AD%97%E7%AC%A6"><span class="toc-text">2.3.6 8只数码管显示不同字符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-6-1-%E6%BA%90%E7%A0%81"><span class="toc-text">2.3.6.1 源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-6-2-%E4%BB%BF%E7%9C%9F"><span class="toc-text">2.3.6.2 仿真</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE"><span class="toc-text">2.4 独立按键</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E6%8C%89%E4%B8%8B%E6%8C%89%E9%94%AEled%E5%B0%8F%E7%81%AF%E4%BA%AE"><span class="toc-text">2.4.1 按下按键LED小灯亮</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E6%8C%89%E9%94%AE%E6%8C%89%E4%B8%8B%E8%9C%82%E9%B8%A3%E5%99%A8%E9%B8%A3%E5%93%8D"><span class="toc-text">2.4.2 按键按下蜂鸣器鸣响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-%E6%B5%8B%E8%AF%95-%E6%8C%89%E9%94%AE%E6%8C%89%E4%B8%8B%E6%97%B6p2-7%E7%9A%84%E7%8A%B6%E6%80%81-%E6%8C%81%E7%BB%AD%E7%9A%84%E6%97%B6%E9%97%B4%E5%88%B0%E5%BA%95%E6%98%AF%E5%A4%9A%E9%95%BF"><span class="toc-text">2.4.3 测试“按键按下时P2.7的状态”持续的时间到底是多长</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4-%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6%E7%81%AF%E4%BA%AE%E7%81%AF%E7%81%AD"><span class="toc-text">2.4.4 按键控制灯亮灯灭</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-5-%E4%B8%8D%E6%94%AF%E6%8C%81%E8%BF%9E%E6%8C%89%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.4.5 不支持连按模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-6-%E5%9B%9E%E5%BD%92%E6%8C%89%E9%94%AE"><span class="toc-text">2.4.6 回归按键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-7-%E6%94%AF%E6%8C%81%E8%BF%9E%E6%8C%89"><span class="toc-text">2.4.7 支持连按</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-8-%E4%BC%98%E5%8C%96%E4%B8%8D%E6%94%AF%E6%8C%81%E8%BF%9E%E6%8C%89%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-text">2.4.8 优化不支持连按的代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-9-%E5%8F%8C%E6%A8%A1%E5%BC%8F%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85"><span class="toc-text">2.4.9 双模式函数封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-10-%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B"><span class="toc-text">2.4.10 综合案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%A4%9A%E6%A8%A1%E5%9D%97%E7%BC%96%E7%A8%8B"><span class="toc-text">2.5 多模块编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0-%E4%B8%8D%E6%94%AF%E6%8C%81%E8%BF%9E%E6%8C%89%E7%9A%84%E6%8C%89%E9%94%AE"><span class="toc-text">2.5.1 带返回值的函数（不支持连按的按键）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-%E6%94%AF%E6%8C%81%E8%BF%9E%E6%8C%89%E7%9A%84%E6%8C%89%E9%94%AE"><span class="toc-text">2.5.2 支持连按的按键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-3-%E6%9C%80%E7%BB%88%E6%8C%89%E9%94%AE%E7%A8%8B%E5%BA%8F"><span class="toc-text">2.5.3 最终按键程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-4-%E6%9C%80%E7%BB%88%E7%9A%84function%E6%96%87%E4%BB%B6"><span class="toc-text">2.5.4 最终的Function文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD"><span class="toc-text">2.6 外部中断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-ie0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">2.6.1 IE0的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0"><span class="toc-text">2.6.2 中断函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3-%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD1"><span class="toc-text">2.6.3 外部中断1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-4-%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6%E4%B8%AD%E6%96%AD"><span class="toc-text">2.6.4 按键控制中断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">2.7 定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1-%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E4%B8%80%E4%B9%8B%E6%B5%81%E6%B0%B4%E7%81%AF"><span class="toc-text">2.7.1 工作模式一之流水灯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-2-%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD"><span class="toc-text">2.7.2 定时器中断</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%8D%95%E7%89%87%E6%9C%BAc%E8%AF%AD%E8%A8%80"><span class="toc-text">三、单片机C语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%89%B9%E6%AE%8A%E5%8A%9F%E8%83%BD%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E4%BD%8D%E5%AE%9A%E4%B9%89"><span class="toc-text">3.1 特殊功能寄存器和位定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-sfr-p0-0x80"><span class="toc-text">3.1.1 sfr P0=0x80</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-sbit-led-p0-0"><span class="toc-text">3.1.2 sbit LED = P0^0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E7%89%B9%E6%AE%8A%E5%8A%9F%E8%83%BD%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">3.1.3 单片机的特殊功能寄存器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-delay-%E5%87%BD%E6%95%B0"><span class="toc-text">3.2 Delay()函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-1-%E7%A9%BA%E6%93%8D%E4%BD%9C%E5%BE%AA%E7%8E%AF%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-text">3.2.1 空操作循环运行的时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">3.2.2 存在的问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-3-%E8%AE%BE%E8%AE%A1%E7%B2%BE%E7%A1%AE%E7%9A%845s"><span class="toc-text">3.2.3 设计精确的5s</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%A7%BB%E4%BD%8D"><span class="toc-text">3.3 移位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-text">3.4 静态变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B"><span class="toc-text">3.5 多文件编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1-%E5%89%8D%E6%9C%9F%E8%AE%BE%E7%BD%AE"><span class="toc-text">3.5.1 前期设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-2-%E7%A1%AC%E4%BB%B6%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">3.5.2 硬件的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-3-%E5%B0%8F%E7%81%AF%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">3.5.3 小灯的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-4-function-h%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-text">3.5.4 function.h的内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-5-%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA%E5%87%BD%E6%95%B0"><span class="toc-text">3.5.5 数码管显示函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-6-%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">3.5.6 带返回值的函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-typedef%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">3.6 typedef关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E6%8C%87%E9%92%88"><span class="toc-text">3.7 指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-1-%E6%8C%87%E9%92%88%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-text">3.7.1 指针的概念与指针变量的声明</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-7-1-1-%E5%8F%98%E9%87%8F%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-text">3.7.1.1 变量的地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-7-1-2-%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-text">3.7.1.2 指针变量的声明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-7-1-3-%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="toc-text">3.7.1.3 简单示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-2-%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-text">3.7.2 指向数组元素的指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-7-2-1-%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E6%8C%87%E9%92%88%E5%92%8C%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99"><span class="toc-text">3.7.2.1 指向数组元素的指针和运算法则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-7-2-1-%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-text">3.7.2.1 指向数组元素指针的实例</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/6a236522.html" title="Serv00部署Memos"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.gan1ser.top/posts/125.webp/cover" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Serv00部署Memos"></a><div class="content"><a class="title" href="/post/6a236522.html" title="Serv00部署Memos">Serv00部署Memos</a><time datetime="2024-08-03T11:23:00.000Z" title="发表于 2024-08-03 11:23:00">2024-08-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/754a429b.html" title="信盈达实习记录"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.gan1ser.top/posts/93.webp/cover" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="信盈达实习记录"></a><div class="content"><a class="title" href="/post/754a429b.html" title="信盈达实习记录">信盈达实习记录</a><time datetime="2024-07-07T09:13:00.000Z" title="发表于 2024-07-07 09:13:00">2024-07-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/b9a95f5e.html" title="数字信号的2FSK调制与解调"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.gan1ser.top/posts/6.webp/cover" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数字信号的2FSK调制与解调"></a><div class="content"><a class="title" href="/post/b9a95f5e.html" title="数字信号的2FSK调制与解调">数字信号的2FSK调制与解调</a><time datetime="2024-06-26T20:13:00.000Z" title="发表于 2024-06-26 20:13:00">2024-06-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/ab4c01cf.html" title="OFDM学习过程及仿真"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.gan1ser.top/posts/118.webp/cover" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OFDM学习过程及仿真"></a><div class="content"><a class="title" href="/post/ab4c01cf.html" title="OFDM学习过程及仿真">OFDM学习过程及仿真</a><time datetime="2024-06-23T12:07:00.000Z" title="发表于 2024-06-23 12:07:00">2024-06-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/4c7a50a7.html" title="NLP谷歌语音指令训练大作业"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.gan1ser.top/posts/112.webp/cover" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NLP谷歌语音指令训练大作业"></a><div class="content"><a class="title" href="/post/4c7a50a7.html" title="NLP谷歌语音指令训练大作业">NLP谷歌语音指令训练大作业</a><time datetime="2024-04-29T21:13:00.000Z" title="发表于 2024-04-29 21:13:00">2024-04-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="shine-footer-bar"><div class="footer-logo"><i class="iconfont icon-GanSer" style="width: 2.5em; height: 1.5em; margin-right: 4px;"><use xlink:href="#icon-GanSer"></use></i></div><div class="footer-bar-description">来自 GanSer - 紫箫吟断,素笺恨切💕</div><a class="footer-bar-link" data-pjax-state="" href="/">了解更多</a></div><div id="footer_deal"><a class="deal_link" href="mailto:1742158140@qq.com" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://weibo.com/u/7793068106" title="微博"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://www.facebook.com/profile.php?id=124072204066287&amp;sk=about" title="facebook"><i class="anzhiyufont anzhiyu-icon-facebook1"></i></a><img class="footer_mini_logo" title="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/63f16cddf144a010070697c8.jpg" size="50px"><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/Gan1Ser/" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://space.bilibili.com/628891869" title="Bilibili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://v.douyin.com/iXbJbQ9/" title="抖音"><i class="anzhiyufont anzhiyu-icon-tiktok"></i></a></div><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">服务</div><div class="footer-links"><a class="footer-item" title="51la统计" target="_blank" href="https://v6.51.la/">51la统计</a><a class="footer-item" title="十年之约" target="_blank" href="https://www.foreverblog.cn/">十年之约</a><a class="footer-item" title="开往" target="_blank" href="https://github.com/travellings-link/travellings">开往</a></div></div><div class="footer-group"><div class="footer-title">主题</div><div class="footer-links"><a class="footer-item" title="文档" target="_blank" href="https://blog.anheyu.com/docs/">文档</a><a class="footer-item" title="源码" target="_blank" href="https://github.com/Gan1Ser/Gan1Ser.github.io">源码</a><a class="footer-item" title="更新日志" target="_blank" href="/update/">更新日志</a></div></div><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="即刻短文" target="_blank" href="/essay/">即刻短文</a><a class="footer-item" title="友链文章" target="_blank" href="/fcircle/">友链文章</a><a class="footer-item" title="留言板" target="_blank" href="/comments/">留言板</a></div></div><div class="footer-group"><div class="footer-title">协议</div><div class="footer-links"><a class="footer-item" title="隐私协议" target="_blank" href="/privacy/">隐私协议</a><a class="footer-item" title="Cookies" target="_blank" href="/cookies/">Cookies</a><a class="footer-item" title="版权协议" target="_blank" href="/copyright/">版权协议</a></div></div><div class="footer-group"><div class="footer-title-group"><div class="footer-title">友链</div><a class="random-friends-btn" id="footer-random-friends-btn" href="javascript:addFriendLinksInFooter();" title="换一批友情链接"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i></a></div><div class="footer-links" id="friend-links-in-footer"></div></div></div><div class="copyright">©2022 - 2024 By GanSer</div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"></a><a class="github-badge" target="_blank" href="https://anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"></a><a class="github-badge" target="_blank" href="https://www.dogecloud.com/" style="margin-inline:5px" data-title="本站使用多吉云为静态资源提供CDN加速" title="本站使用多吉云为静态资源提供CDN加速"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/CDN-多吉云-3693F3.svg" alt="本站使用多吉云为静态资源提供CDN加速"></a><a class="github-badge" target="_blank" href="https://beian.miit.gov.cn/" style="margin-inline:5px" data-title="本站已在豫进行备案" title="本站已在豫进行备案"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/65140754c458853aef47c0b4.jpg" alt="本站已在豫进行备案"></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></footer></div></div></div><div id="sidebar"><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/63f16cddf144a010070697c8.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">128</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">28</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">33</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/memos/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 即刻短文</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=7750616521&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/collect/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 影漫佳选</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/todolist/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 待办清单</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div></div><div id="keyboard-tips"><div class="keyboardTitle">博客快捷键</div><div class="keybordList"><div class="keybordItem"><div class="keyGroup"><div class="key">shift K</div></div><div class="keyContent"><div class="content">关闭快捷键功能</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift A</div></div><div class="keyContent"><div class="content">打开中控台</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift M</div></div><div class="keyContent"><div class="content">播放/暂停音乐</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift D</div></div><div class="keyContent"><div class="content">深色/浅色显示模式</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift S</div></div><div class="keyContent"><div class="content">站内搜索</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift R</div></div><div class="keyContent"><div class="content">随机访问</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift H</div></div><div class="keyContent"><div class="content">返回首页</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift F</div></div><div class="keyContent"><div class="content">友链鱼塘</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift L</div></div><div class="keyContent"><div class="content">友链页面</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift P</div></div><div class="keyContent"><div class="content">关于本站</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift I</div></div><div class="keyContent"><div class="content">原版右键菜单</div></div></div></div></div><script>var anzhiyu_intype = false
var anzhiyu_keyUpEvent_timeoutId = null
var anzhiyu_keyUpShiftDelayEvent_timeoutId = null
function addKeyShotListener() {
  const windowObject = window;
  windowObject.removeEventListener("keydown", keyDownEvent);
  windowObject.removeEventListener("keyup", keyUpEvent);
  windowObject.addEventListener("keydown", keyDownEvent);
  windowObject.addEventListener("keyup", keyUpEvent);
}

function keyDownEvent(event) {
  const isEscapeKeyPressed = event.keyCode === 27;
  const isShiftKeyPressed = event.shiftKey;
  const isKeyboardEnabled = anzhiyu_keyboard;
  const isInInputField = anzhiyu_intype;

  if (isEscapeKeyPressed) {
    anzhiyu.hideLoading();
    anzhiyu.hideConsole();
    rm.hideRightMenu();
  }

  if (isKeyboardEnabled && isShiftKeyPressed && !isInInputField) {
    anzhiyu_keyUpShiftDelayEvent_timeoutId = setTimeout(()=>{
      switch (event.keyCode) {
        case 16:
          anzhiyu_keyUpEvent_timeoutId = setTimeout(()=>{
            document.querySelector("#keyboard-tips").classList.add("show");
          }, 200);
          break;
        case 65:
          anzhiyu.showConsole();
          break;
        case 77:
          anzhiyu.musicToggle();
          break;
        case 75:
          anzhiyu.keyboardToggle();
          break;
        case 73:
          anzhiyu.rightMenuToggle();
          break;
        case 82:
          toRandomPost();
          break;
        case 72:
          pjax.loadUrl("/");
          break;
        case 68:
          anzhiyu.switchDarkMode();
          break;
        case 70:
          pjax.loadUrl("/fcircle/");
          break;
        case 76:
          pjax.loadUrl("/link/");
          break;
        case 80:
          pjax.loadUrl("/about/");
          break;
        default:
          break;
      }

      event.preventDefault();
    }, 100);
  }
}

addKeyShotListener();

window.onfocus = function() {
  document.getElementById("keyboard-tips").classList.remove("show")
}

function setInputFocusListener() {
  const inputs = document.querySelectorAll("input, textarea");

  inputs.forEach((input) => {
    input.addEventListener("focus", () => {
      setAnzhiyuIntype(true);
    });

    input.addEventListener("blur", () => {
      setAnzhiyuIntype(false);
    });
  });
}

function setanzhiyuIntype(value) {
  anzhiyu_intype = value;
}

function keyUpEvent(event) {
  anzhiyu_keyUpEvent_timeoutId && clearTimeout(anzhiyu_keyUpEvent_timeoutId);
  anzhiyu_keyUpShiftDelayEvent_timeoutId && clearTimeout(anzhiyu_keyUpShiftDelayEvent_timeoutId);
  if (event.keyCode === 16) {
    const keyboardTips = document.querySelector("#keyboard-tips");
    keyboardTips.classList.remove("show");
  }
}

function listenToPageInputPress() {
  const inputElement = document.getElementById("toPageText");
  const buttonElement = document.getElementById("toPageButton");

  if (!inputElement) {
    return;
  }

  inputElement.addEventListener("keydown", (event) => {
    if (event.keyCode === 13) {
      event.preventDefault();
      anzhiyu.toPage();
      pjax.loadUrl(buttonElement.href);
    }
  });

  inputElement.addEventListener("input", () => {
    const value = inputElement.value;
    if (!value || value === "0") {
      buttonElement.classList.remove("haveValue");
    } else {
      buttonElement.classList.add("haveValue");
    }

    const pageNumbers = document.querySelectorAll(".page-number");
    const maxPageNumber = +pageNumbers[pageNumbers.length - 1].innerHTML;

    if (+value > maxPageNumber) {
      inputElement.value = maxPageNumber;
    }
  });
}

setInputFocusListener()</script><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch_commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="7750616521" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.4.0/source/js/utils.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.4.0/source/js/main.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.4.0/source/js/tw_cn.js"></script><script src="https://npm.elemecdn.com/@fancyapps/ui@4.0.31/dist/fancybox.umd.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.js"></script><canvas id="universe"></canvas><script async="" src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async="" src="/anzhiyu/random.js"></script><script src="https://npm.elemecdn.com/algoliasearch@4.14.2/dist/algoliasearch-lite.umd.js"></script><script src="https://npm.elemecdn.com/instantsearch.js@4.46.1/dist/instantsearch.production.min.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.4.0/source/js/search/algolia.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://npm.elemecdn.com/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.gan1ser.top/',
      region: '',
      onCommentLoaded: function () {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.gan1ser.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init();
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/twikoo/1.4.18/twikoo.all.min.js').then(runFn)
  }
  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.gan1ser.top/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/twikoo/1.4.18/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick}</span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async="" data-pjax="" src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "1742158140@qq.com";</script><script>//动态标题
let leaveTitle = 'w(ﾟДﾟ)w 不要走！再看看嘛！';
let backTitle = '♪(^∇^*)欢迎肥来！';
let OriginTitile = document.title
let titleTime
document.addEventListener('visibilitychange', function () {
  if (document.hidden) {
    //离开当前页面时标签显示内容
    document.title = leaveTitle
    clearTimeout(titleTime)
  } else {
    //返回当前页面时标签显示内容
    document.title = backTitle + OriginTitile
    //两秒后变回正常标题
    titleTime = setTimeout(function () {
      document.title = OriginTitile
    }, 2000)
  }
})</script><script data-pjax="true">if (document.querySelector(".comment-barrage")){
  var commentBarrageConfig = {
    maxBarrage: 1,
    barrageTime: 4000,
    twikooUrl: "https://twikoo.gan1ser.top/",
    accessToken: "034aa2035fc6c553efefed34b8041214",
    mailMd5: "",
    pageUrl: window.location.pathname,
    barrageTimer: [],
    barrageList: [],
    barrageIndex: 0,
    dom: document.querySelector(".comment-barrage"),
  };
  var commentInterval = null;
  var hoverOnCommentBarrage = false;
  
  document.querySelector(".comment-barrage").addEventListener("mouseenter", function() {
    hoverOnCommentBarrage = true;
  });
  document.querySelector(".comment-barrage").addEventListener("mouseleave", function() {
    hoverOnCommentBarrage = false;
  });

  function initCommentBarrage() {
    if (!commentBarrageConfig.dom) return;

    var data = JSON.stringify({
      event: "COMMENT_GET",
      "commentBarrageConfig.accessToken": commentBarrageConfig.accessToken,
      url: commentBarrageConfig.pageUrl,
    });
    var xhr = new XMLHttpRequest();
    xhr.withCredentials = true;
    xhr.addEventListener("readystatechange", function () {
      if (this.readyState === 4 && this.responseText) {
        commentBarrageConfig.barrageList = commentLinkFilter(JSON.parse(this.responseText).data);
        commentBarrageConfig.dom.innerHTML = "";
      }
    });
    xhr.open("POST", commentBarrageConfig.twikooUrl);
    xhr.setRequestHeader("Content-Type", "application/json");
    xhr.send(data);

    clearInterval(commentInterval);
    commentInterval = null;

    commentInterval = setInterval(() => {
      if (commentBarrageConfig.barrageList.length && !hoverOnCommentBarrage) {
        popCommentBarrage(commentBarrageConfig.barrageList[commentBarrageConfig.barrageIndex]);
        commentBarrageConfig.barrageIndex += 1;
        commentBarrageConfig.barrageIndex %= commentBarrageConfig.barrageList.length;
      }
      if (
        commentBarrageConfig.barrageTimer.length >
          (commentBarrageConfig.barrageList.length > commentBarrageConfig.maxBarrage
            ? commentBarrageConfig.maxBarrage
            : commentBarrageConfig.barrageList.length) &&
        !hoverOnCommentBarrage
      ) {
        removeCommentBarrage(commentBarrageConfig.barrageTimer.shift());
      }
    }, commentBarrageConfig.barrageTime);
  }

  function commentLinkFilter(data) {
    data.sort((a, b) => {
      return a.created - b.created;
    });
    let newData = [];
    data.forEach(item => {
      newData.push(...getCommentReplies(item));
    });
    return newData;
  }

  function getCommentReplies(item) {
    if (item.replies) {
      let replies = [item];
      item.replies.forEach(item => {
        replies.push(...getCommentReplies(item));
      });
      return replies;
    } else {
      return [];
    }
  }

  function popCommentBarrage(data) {
    let barrage = document.createElement("div");
    barrage.className = "comment-barrage-item";
    barrage.innerHTML = `
        <div class="barrageHead">
          <a class="barrageTitle ${
            data.mailMd5 === commentBarrageConfig.mailMd5 ? "barrageBloggerTitle" : ""
          }" href="javascript:anzhiyu.scrollTo('#post-comment')"">
            ${data.mailMd5 === commentBarrageConfig.mailMd5 ? "博主" : "热评"}
          </a>
          <div class="barrageNick">${data.nick}</div>
          <img class="nolazyload barrageAvatar" src="https://cravatar.cn/avatar/${data.mailMd5}"/>
          <a class="comment-barrage-close" href="javascript:anzhiyu.switchCommentBarrage()"><i class="anzhiyufont anzhiyu-icon-xmark"></i></a>
        </div>
        <a class="barrageContent" href="#${data.id}">
          <object>${data.comment}</object>
        </a>
      `;
    commentBarrageConfig.barrageTimer.push(barrage);
    commentBarrageConfig.dom.append(barrage);
  }

  function removeCommentBarrage(barrage) {
    barrage.className = "comment-barrage-item out";

    setTimeout(() => {
      if (commentBarrageConfig.dom && commentBarrageConfig.dom.contains(barrage)) {
        commentBarrageConfig.dom.removeChild(barrage);
      }
      }, 1000);
    }

    // 自动隐藏
    const commentEntryCallback = (entries) => {
      const commentBarrage = document.querySelector(".comment-barrage");
      const postComment = document.getElementById("post-comment");

      entries.forEach(entry => {
        if (postComment && commentBarrage && document.body.clientWidth > 768) {
          commentBarrage.style.bottom = entry.isIntersecting ? "-200px" : "0";
        }
      });
    };
    // 创建IntersectionObserver实例
    const observer = new IntersectionObserver(commentEntryCallback, {
      root: null,
      rootMargin: "0px",
      threshold: 0
    });
    // 监视目标元素
    const postCommentTarget = document.getElementById("post-comment");
    if (postCommentTarget) {
      observer.observe(postCommentTarget);
    }

    initCommentBarrage();

    if (localStorage.getItem("commentBarrageSwitch") !== "false") {
      document.querySelector(".comment-barrage").style.display = "flex";
      document.querySelector(".menu-commentBarrage-text").textContent = "关闭热评";
    } else {
      document.querySelector(".comment-barrage").style.display = "none";
      document.querySelector(".menu-commentBarrage-text").textContent = "显示热评";
    }

    document.addEventListener("pjax:send", function () {
      clearInterval(commentInterval);
    });

  }</script><script async="" data-pjax="" src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script>// 初始化函数
let rm = {};

//禁止图片与超链接拖拽
let aElements = document.getElementsByTagName("a");
for (let i = 0; i < aElements.length; i++) {
  aElements[i].setAttribute("draggable", "false");
  let imgElements = aElements[i].getElementsByTagName("img");
  for (let j = 0; j < imgElements.length; j++) {
    imgElements[j].setAttribute("draggable", "false");
  }
}

// 显示菜单
rm.showRightMenu = function (isTrue, x = 0, y = 0) {
  console.info(x, y)
  let rightMenu = document.getElementById("rightMenu");
  rightMenu.style.top = x + "px";
  rightMenu.style.left = y + "px";
  if (isTrue) {
    rightMenu.style.display = "block";
    stopMaskScroll();
  } else {
    rightMenu.style.display = "none";
  }
};

// 隐藏菜单
rm.hideRightMenu = function () {
  rm.showRightMenu(false);
  let rightMenuMask = document.querySelector("#rightmenu-mask");
  rightMenuMask.style.display = "none";
};

// 尺寸
let rmWidth = document.getElementById("rightMenu").offsetWidth;
let rmHeight = document.getElementById("rightMenu").offsetHeight;

// 重新定义尺寸
rm.reloadrmSize = function () {
  rightMenu.style.visibility = "hidden";
  rightMenu.style.display = "block";
  // 获取宽度和高度
  rmWidth = document.getElementById("rightMenu").offsetWidth;
  rmHeight = document.getElementById("rightMenu").offsetHeight;
  rightMenu.style.visibility = "visible";
};

// 获取点击的href
let domhref = "";
let domImgSrc = "";
let globalEvent = null;

var oncontextmenuFunction = function (event) {
  if (document.body.clientWidth > 768) {
    let pageX = event.clientX + 10; //加10是为了防止显示时鼠标遮在菜单上
    let pageY = event.clientY;

    //其他额外菜单
    const $rightMenuOther = document.querySelector(".rightMenuOther");
    const $rightMenuPlugin = document.querySelector(".rightMenuPlugin");
    const $rightMenuCopyText = document.querySelector("#menu-copytext");
    const $rightMenuPasteText = document.querySelector("#menu-pastetext");
    const $rightMenuCommentText = document.querySelector("#menu-commenttext");
    const $rightMenuNewWindow = document.querySelector("#menu-newwindow");
    const $rightMenuNewWindowImg = document.querySelector("#menu-newwindowimg");
    const $rightMenuCopyLink = document.querySelector("#menu-copylink");
    const $rightMenuCopyImg = document.querySelector("#menu-copyimg");
    const $rightMenuDownloadImg = document.querySelector("#menu-downloadimg");
    const $rightMenuSearch = document.querySelector("#menu-search");
    const $rightMenuSearchBaidu = document.querySelector("#menu-searchBaidu");
    const $rightMenuMusicToggle = document.querySelector("#menu-music-toggle");
    const $rightMenuMusicBack = document.querySelector("#menu-music-back");
    const $rightMenuMusicForward = document.querySelector("#menu-music-forward");
    const $rightMenuMusicPlaylist = document.querySelector("#menu-music-playlist");
    const $rightMenuMusicCopyMusicName = document.querySelector("#menu-music-copyMusicName");

    let href = event.target.href;
    let imgsrc = event.target.currentSrc;

    // 判断模式 扩展模式为有事件
    let pluginMode = false;
    $rightMenuOther.style.display = "block";
    globalEvent = event;

    // 检查是否需要复制 是否有选中文本
    if (selectTextNow && window.getSelection()) {
      pluginMode = true;
      $rightMenuCopyText.style.display = "block";
      $rightMenuCommentText.style.display = "block";
      $rightMenuSearch.style.display = "block";
      $rightMenuSearchBaidu.style.display = "block";
    } else {
      $rightMenuCopyText.style.display = "none";
      $rightMenuCommentText.style.display = "none";
      $rightMenuSearchBaidu.style.display = "none";
      $rightMenuSearch.style.display = "none";
    }

    //检查是否右键点击了链接a标签
    if (href) {
      pluginMode = true;
      $rightMenuNewWindow.style.display = "block";
      $rightMenuCopyLink.style.display = "block";
      domhref = href;
    } else {
      $rightMenuNewWindow.style.display = "none";
      $rightMenuCopyLink.style.display = "none";
    }

    //检查是否需要复制图片
    if (imgsrc) {
      pluginMode = true;
      $rightMenuCopyImg.style.display = "block";
      $rightMenuDownloadImg.style.display = "block";
      $rightMenuNewWindowImg.style.display = "block";
      document.getElementById("rightMenu").style.width="12rem"
      domImgSrc = imgsrc;
    } else {
      $rightMenuCopyImg.style.display = "none";
      $rightMenuDownloadImg.style.display = "none";
      $rightMenuNewWindowImg.style.display = "none";
    }

    // 判断是否为输入框
    if (event.target.tagName.toLowerCase() === "input" || event.target.tagName.toLowerCase() === "textarea") {
      pluginMode = true;
      $rightMenuPasteText.style.display = "block";
    } else {
      $rightMenuPasteText.style.display = "none";
    }
    const navMusicEl = document.querySelector("#nav-music");
    //判断是否是音乐
    if (navMusicEl && navMusicEl.contains(event.target)) {
      pluginMode = true;
      $rightMenuMusicToggle.style.display = "block";
      $rightMenuMusicBack.style.display = "block";
      $rightMenuMusicForward.style.display = "block";
      $rightMenuMusicPlaylist.style.display = "block";
      $rightMenuMusicCopyMusicName.style.display = "block";
    } else {
      $rightMenuMusicToggle.style.display = "none";
      $rightMenuMusicBack.style.display = "none";
      $rightMenuMusicForward.style.display = "none";
      $rightMenuMusicPlaylist.style.display = "none";
      $rightMenuMusicCopyMusicName.style.display = "none";
    }

    // 如果不是扩展模式则隐藏扩展模块
    if (pluginMode) {
      $rightMenuOther.style.display = "none";
      $rightMenuPlugin.style.display = "block";
    } else {
      $rightMenuPlugin.style.display = "none";
    }

    rm.reloadrmSize();

    // 鼠标默认显示在鼠标右下方，当鼠标靠右或靠下时，将菜单显示在鼠标左方\上方
    if (pageX + rmWidth > window.innerWidth) {
      pageX -= rmWidth + 10;
    }
    if (pageY + rmHeight > window.innerHeight) {
      pageY -= pageY + rmHeight - window.innerHeight;
    }

    rm.showRightMenu(true, pageY, pageX);
    document.getElementById("rightmenu-mask").style.display = "flex";
    return false;
  }
};

// 监听右键初始化
window.oncontextmenu = oncontextmenuFunction

// 下载图片状态
rm.downloadimging = false;

// 复制图片到剪贴板
rm.writeClipImg = function (imgsrc) {
  console.log("按下复制");
  rm.hideRightMenu();
  anzhiyu.snackbarShow("正在下载中，请稍后", false, 10000);
  if (rm.downloadimging == false) {
    rm.downloadimging = true;
    setTimeout(function () {
      copyImage(imgsrc);
      anzhiyu.snackbarShow("复制成功！图片已添加盲水印，请遵守版权协议");
      rm.downloadimging = false;
    }, "10000");
  }
};

function imageToBlob(imageURL) {
  const img = new Image();
  const c = document.createElement("canvas");
  const ctx = c.getContext("2d");
  img.crossOrigin = "";
  img.src = imageURL;
  return new Promise(resolve => {
    img.onload = function () {
      c.width = this.naturalWidth;
      c.height = this.naturalHeight;
      ctx.drawImage(this, 0, 0);
      c.toBlob(
        blob => {
          // here the image is a blob
          resolve(blob);
        },
        "image/png",
        0.75
      );
    };
  });
}

async function copyImage(imageURL) {
  const blob = await imageToBlob(imageURL);
  const item = new ClipboardItem({ "image/png": blob });
  navigator.clipboard.write([item]);
}

rm.copyUrl = function (id) {
  const input = document.createElement("input"); // Create a new <input> element
  input.id = "copyVal"; // Set the id of the new element to "copyVal"
  document.body.appendChild(input); // Append the new element to the end of the <body> element
  
  const text = id;
  input.value = text;
  input.select();
  input.setSelectionRange(0, input.value.length);
  document.execCommand("copy");
  
  input.remove(); // Remove the <input> element from the DOM
};

function stopMaskScroll() {
  if (document.getElementById("rightmenu-mask")) {
    let xscroll = document.getElementById("rightmenu-mask");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      { passive: true }
    );
  }
  if (document.getElementById("rightMenu")) {
    let xscroll = document.getElementById("rightMenu");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      { passive: true }
    );
  }
}

rm.rightmenuCopyText = function (txt) {
  if (navigator.clipboard) {
    navigator.clipboard.writeText(txt);
  }
  rm.hideRightMenu();
};

rm.copyPageUrl = function (url) {
  if (!url) {
    url = window.location.href;
  }
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制本页链接地址成功", false, 2000);
  rm.hideRightMenu();
};

rm.sharePage = function () {
  var content = window.location.href;
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制本页链接地址成功", false, 2000);
  rm.hideRightMenu();
};

// 复制当前选中文本
var selectTextNow = "";
document.onmouseup = document.ondblclick = selceText;

function selceText() {
  var txt;
  if (document.selection) {
    txt = document.selection.createRange().text;
  } else {
    txt = window.getSelection().toString();
  }
  selectTextNow = txt !== "" ? txt : "";
}

// 读取剪切板
rm.readClipboard = function () {
  if (navigator.clipboard) {
    navigator.clipboard.readText().then(clipText => rm.insertAtCaret(globalEvent.target, clipText));
  }
};

// 粘贴文本到焦点
rm.insertAtCaret = function (elemt, value) {
  const startPos = elemt.selectionStart,
    endPos = elemt.selectionEnd;
  if (document.selection) {
    elemt.focus();
    var sel = document.selection.createRange();
    sel.text = value;
    elemt.focus();
  } else {
    if (startPos || startPos == "0") {
      var scrollTop = elemt.scrollTop;
      elemt.value = elemt.value.substring(0, startPos) + value + elemt.value.substring(endPos, elemt.value.length);
      elemt.focus();
      elemt.selectionStart = startPos + value.length;
      elemt.selectionEnd = startPos + value.length;
      elemt.scrollTop = scrollTop;
    } else {
      elemt.value += value;
      elemt.focus();
    }
  }
};

//粘贴文本
rm.pasteText = function () {
  const result = rm.readClipboard() || "";
  rm.hideRightMenu();
};

//引用到评论
rm.rightMenuCommentText = function (txt) {
  rm.hideRightMenu();
  const postCommentDom = document.getElementById("post-comment");
  var domTop = postCommentDom.offsetTop;
  window.scrollTo(0, domTop - 80);
  if (txt == "undefined" || txt == "null") txt = "好棒！";
  function setText() {
    setTimeout(() => {
      var input = document.getElementsByClassName("el-textarea__inner")[0];
      if (!input) setText();
      let evt = document.createEvent("HTMLEvents");
      evt.initEvent("input", true, true);
      let inputValue = replaceAll(txt, "\n", "\n> ");
      input.value = "> " + inputValue + "\n\n";
      input.dispatchEvent(evt);
      input.focus();
      input.setSelectionRange(-1, -1);
      if (document.getElementById("comment-tips")) {
        document.getElementById("comment-tips").classList.add("show");
      }
    }, 100);
  }
  setText();
};

//替换所有内容
function replaceAll(string, search, replace) {
  return string.split(search).join(replace);
}

// 百度搜索
rm.searchBaidu = function () {
  anzhiyu.snackbarShow("即将跳转到百度搜索", false, 2000);
  setTimeout(function () {
    window.open("https://www.baidu.com/s?wd=" + selectTextNow);
  }, "2000");
  rm.hideRightMenu();
};

//分享链接
rm.copyLink = function () {
  rm.rightmenuCopyText(domhref);
  anzhiyu.snackbarShow("已复制链接地址");
};

function addRightMenuClickEvent() {
  // 添加点击事件
  document.getElementById("menu-backward").addEventListener("click", function () {
  window.history.back();
    rm.hideRightMenu();
  });

  document.getElementById("menu-forward").addEventListener("click", function () {
    window.history.forward();
    rm.hideRightMenu();
  });

  document.getElementById("menu-refresh").addEventListener("click", function () {
    window.location.reload();
  });

  document.getElementById("menu-top").addEventListener("click", function () {
    anzhiyu.scrollToDest(0, 500);
    rm.hideRightMenu();
  });

  const menuLinks = document.querySelectorAll(".menu-link");
  menuLinks.forEach(function (link) {
    link.addEventListener("click", rm.hideRightMenu);
  });

  document.getElementById("menu-darkmode").addEventListener("click", anzhiyu.switchDarkMode);

  document.getElementById("menu-home") && document.getElementById("menu-home").addEventListener("click", function () {
    window.location.href = window.location.origin;
  });

  document.getElementById("menu-randomPost").addEventListener("click", function () {
    toRandomPost();
  });

  document.getElementById("menu-commentBarrage").addEventListener("click", anzhiyu.switchCommentBarrage);

  document.getElementById("rightmenu-mask").addEventListener("click", rm.hideRightMenu);

  document.getElementById("rightmenu-mask").addEventListener("contextmenu", function (event) {
    rm.hideRightMenu();
    event.preventDefault(); // Prevent the default context menu from appearing
  });

  document.getElementById("menu-copy").addEventListener("click", rm.copyPageUrl);

  document.getElementById("menu-pastetext").addEventListener("click", rm.pasteText);

  document.getElementById("menu-copytext").addEventListener("click", function () {
    rm.rightmenuCopyText(selectTextNow);
    anzhiyu.snackbarShow("复制成功，复制和转载请标注本文地址");
  });

  document.getElementById("menu-commenttext").addEventListener("click", function () {
    rm.rightMenuCommentText(selectTextNow);
  });

  document.getElementById("menu-newwindow").addEventListener("click", function () {
    window.open(domhref, "_blank");
    rm.hideRightMenu();
  });

  document.getElementById("menu-copylink").addEventListener("click", rm.copyLink);

  document.getElementById("menu-downloadimg").addEventListener("click", function () {
    anzhiyu.downloadImage(domImgSrc, "anzhiyu");
  });

  document.getElementById("menu-newwindowimg").addEventListener("click", function () {
    window.open(domImgSrc, "_blank");
    rm.hideRightMenu();
  });

  document.getElementById("menu-copyimg").addEventListener("click", function () {
    rm.writeClipImg(domImgSrc);
  });

  document.getElementById("menu-searchBaidu").addEventListener("click", rm.searchBaidu);

  //音乐
  document.getElementById("menu-music-toggle").addEventListener("click", anzhiyu.musicToggle);

  document.getElementById("menu-music-back").addEventListener("click", anzhiyu.musicSkipBack);

  document.getElementById("menu-music-forward").addEventListener("click", anzhiyu.musicSkipForward);

  document.getElementById("menu-music-copyMusicName").addEventListener("click", function () {
    rm.rightmenuCopyText(anzhiyu.musicGetName());
    anzhiyu.snackbarShow("复制歌曲名称成功", false, 3000);
  });

}

addRightMenuClickEvent();</script><script data-pjax="">var themeColorMeta = document.querySelector('meta[name="theme-color"]');
var pageHeaderEl = document.getElementById("page-header");
var navMusicEl = document.getElementById("nav-music");
var consoleEl = document.getElementById("console");
// 已随机的歌曲
var selectRandomSong = [];
// 音乐默认声音大小
var musicVolume = 0.8;
// 是否切换了周杰伦音乐列表
var changeMusicListFlag = false;
// 当前默认播放列表
var defaultPlayMusicList = [];

document.getElementById("page-name").innerText = document.title.split(" | GanSer")[0];
anzhiyu.initIndexEssay();
anzhiyu.changeTimeInEssay();
anzhiyu.removeBodyPaceClass();
anzhiyu.qrcodeCreate();
anzhiyu.changeTimeInAlbumDetail();
anzhiyu.reflashEssayWaterFall();
anzhiyu.sayhi();
anzhiyu.stopImgRightDrag();
anzhiyu.addNavBackgroundInit();
anzhiyu.setValueToBodyType();
anzhiyu.catalogActive();
anzhiyu.tagsPageActive();
anzhiyu.categoriesBarActive();
anzhiyu.topCategoriesBarScroll();
anzhiyu.switchRightClickMenuHotReview();
anzhiyu.getCustomPlayList();
anzhiyu.addEventListenerConsoleMusicList(false);
setTimeout(() => {
  if (typeof addFriendLinksInFooter === "function") {
    addFriendLinksInFooter();
  }
}, 200)</script><script charset="UTF-8" id="LA_COLLECT" src="https://sdk.51.la/js-sdk-pro.min.js"></script><script src="https://sdk.51.la/perf/js-sdk-perf.min.js" crossorigin="anonymous"></script><script>LA.init({id: "K2Vkt1ZVOZBb2pOv", ck: "K2Vkt1ZVOZBb2pOv"});
new LingQue.Monitor().init({id: "K2VmAqpeb53up8NV", sendSpaPv:true});</script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.1.4/icon/ali_iconfont_css.css"><script async="" data-pjax="" src="/js/imgloaded.js?1"></script><script defer="" src="//at.alicdn.com/t/c/font_3816086_jveqqa1cjpg.js"></script><script data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}" src="https://cdn.jsdelivr.net/npm/pace-js@latest/pace.min.js"></script><script async="" src="https://npm.onmicrosoft.cn/naokuo-blog@1.2.10/js/SmoothScroll.min.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://npm.elemecdn.com/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://npm.elemecdn.com/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div></body></html>